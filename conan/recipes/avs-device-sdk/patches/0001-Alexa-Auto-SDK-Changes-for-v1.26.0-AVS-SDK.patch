From 6278078669536271460c42cf4d5a4cba35459634 Mon Sep 17 00:00:00 2001
From: Muni Sakkuru <muni.sakkuru@gmail.com>
Date: Tue, 2 May 2023 15:05:47 -0700
Subject: [PATCH] Alexa Auto SDK Changes for v1.26.0 AVS SDK

For internal reference: bcf418f7
---
 ACL/include/ACL/AVSConnectionManager.h        |    3 +-
 .../ACL/Transport/DownchannelHandler.h        |    8 +
 ACL/include/ACL/Transport/HTTP2Transport.h    |    8 +
 .../ACL/Transport/HTTP2TransportFactory.h     |    8 +
 ACL/include/ACL/Transport/MessageRouter.h     |   31 +-
 .../MessageRouterObserverInterface.h          |    9 +-
 .../ACL/Transport/TransportFactoryInterface.h |   22 +
 ACL/src/AVSConnectionManager.cpp              |    8 +-
 ACL/src/Transport/DownchannelHandler.cpp      |   38 +-
 ACL/src/Transport/HTTP2Transport.cpp          |   27 +-
 ACL/src/Transport/HTTP2TransportFactory.cpp   |   19 +
 ACL/src/Transport/MessageRequestHandler.cpp   |   22 +-
 ACL/src/Transport/MessageRouter.cpp           |  116 +-
 ACL/test/AVSConnectionManagerTest.cpp         |    4 +-
 ACL/test/Transport/HTTP2TransportTest.cpp     |    4 +
 ACL/test/Transport/MessageRouterTest.cpp      |    1 +
 ACL/test/Transport/MessageRouterTest.h        |   13 +
 ACL/test/Transport/MockAuthDelegate.h         |    4 +-
 .../Transport/MockMessageRouterObserver.h     |   20 +-
 ADSL/include/ADSL/ADSLComponent.h             |    4 +-
 ADSL/include/ADSL/DirectiveProcessor.h        |   21 +-
 ADSL/include/ADSL/DirectiveSequencer.h        |   21 +-
 ADSL/include/ADSL/MessageInterpreter.h        |    7 +-
 ADSL/src/CMakeLists.txt                       |    6 +-
 ADSL/src/DirectiveProcessor.cpp               |   71 ++
 ADSL/src/DirectiveRouter.cpp                  |   19 +-
 ADSL/src/DirectiveSequencer.cpp               |   37 +-
 ADSL/src/MessageInterpreter.cpp               |   10 +-
 ADSL/test/CMakeLists.txt                      |    2 +-
 ADSL/test/DirectiveProcessorTest.cpp          |   92 ++
 ADSL/test/DirectiveRouterTest.cpp             |   12 +-
 ADSL/test/DirectiveSequencerTest.cpp          |  159 ++-
 ADSL/test/MessageInterpreterTest.cpp          |   49 +-
 AFML/src/AudioActivityTracker.cpp             |    3 +-
 .../AVS/include/AVSCommon/AVS/AVSDirective.h  |   46 +-
 .../AVS/AVSDiscoveryEndpointAttributes.h      |    4 +
 .../AVS/include/AVSCommon/AVS/AVSMessage.h    |   28 +-
 AVSCommon/AVS/include/AVSCommon/AVS/AgentId.h |   62 +
 .../include/AVSCommon/AVS/AgentInitiator.h    |   59 +
 .../include/AVSCommon/AVS/CapabilityAgent.h   |   16 +-
 .../AVS/include/AVSCommon/AVS/CapabilityTag.h |   38 +-
 .../AVSCommon/AVS/DialogUXStateAggregator.h   |   35 +-
 .../AVSCommon/AVS/DirectiveRoutingRule.h      |   97 +-
 .../include/AVSCommon/AVS/EndpointResources.h |  188 +++
 .../AVS/ExceptionEncounteredSender.h          |   16 +-
 AVSCommon/AVS/include/AVSCommon/AVS/Locale.h  |   36 +
 .../include/AVSCommon/AVS/MessageRequest.h    |   79 +-
 .../include/AVSCommon/AVS/NamespaceAndName.h  |   16 +-
 .../AVSCommon/AVS/WaitableMessageRequest.h    |   10 +-
 AVSCommon/AVS/src/AVSDirective.cpp            |   43 +-
 AVSCommon/AVS/src/AVSMessage.cpp              |   19 +-
 AVSCommon/AVS/src/AgentId.cpp                 |   73 ++
 AVSCommon/AVS/src/CapabilityAgent.cpp         |   23 +
 AVSCommon/AVS/src/CapabilityTag.cpp           |   35 +-
 AVSCommon/AVS/src/DialogUXStateAggregator.cpp |  129 +-
 AVSCommon/AVS/src/DirectiveRoutingRule.cpp    |   51 +-
 AVSCommon/AVS/src/EndpointResources.cpp       |  221 ++++
 .../AVS/src/ExceptionEncounteredSender.cpp    |   11 +-
 AVSCommon/AVS/src/MessageRequest.cpp          |   60 +-
 AVSCommon/AVS/src/NamespaceAndName.cpp        |    7 +
 AVSCommon/AVS/src/WaitableMessageRequest.cpp  |    7 +
 AVSCommon/AVS/test/CMakeLists.txt             |    2 +-
 .../AVS/test/DialogUXStateAggregatorTest.cpp  |  303 +++--
 .../AVS/test/EditableMessageRequestTest.cpp   |    8 +-
 AVSCommon/AVS/test/MessageRequestTest.cpp     |   20 +
 AVSCommon/AVS/test/NamespaceAndNameTest.cpp   |   18 +-
 AVSCommon/CMakeLists.txt                      |   16 +-
 .../AudioInputProcessorObserverInterface.h    |    7 +-
 .../SDKInterfaces/ContextManagerInterface.h   |   62 +
 .../DialogUXStateObserverInterface.h          |    5 +-
 .../Endpoints/EndpointBuilderInterface.h      |   20 +-
 .../ExceptionEncounteredSenderInterface.h     |   22 +
 .../LocaleAssetsManagerInterface.h            |    6 +-
 .../SDKInterfaces/MessageObserverInterface.h  |   10 +-
 .../Messaging/MessagingObserverInterface.h    |  129 ++
 .../SpeechSynthesizerObserverInterface.h      |   34 +-
 .../SDKInterfaces/MockContextManager.h        |   14 +
 .../MockExceptionEncounteredSender.h          |    7 +
 .../LibcurlUtils/CurlEasyHandleWrapper.h      |   41 +-
 .../AVSCommon/Utils/LibcurlUtils/HttpDelete.h |   83 ++
 .../Utils/LibcurlUtils/HttpDeleteInterface.h  |   56 +
 .../AVSCommon/Utils/LibcurlUtils/HttpGet.h    |   83 ++
 .../Utils/LibcurlUtils/HttpGetInterface.h     |    7 +-
 .../Utils/LibcurlUtils/LibcurlUtils.h         |    5 +-
 .../AVSCommon/Utils/Logger/ThreadMoniker.h    |   11 +-
 .../AVSCommon/Utils/Metrics/MetricContext.h   |   46 +
 .../AVSCommon/Utils/Metrics/MetricEvent.h     |   29 +-
 .../Utils/Metrics/MetricEventBuilder.h        |   12 +
 .../Utils/Metrics/UplCalculatorInterface.h    |   18 +-
 .../AVSCommon/Utils/Metrics/UplContext.h      |   71 ++
 .../include/AVSCommon/Utils/Metrics/Utils.h   |   47 +
 .../LibcurlUtils/CurlEasyHandleWrapper.cpp    |   90 +-
 .../Utils/src/LibcurlUtils/HttpDelete.cpp     |  129 ++
 AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp  |  129 ++
 .../Utils/src/LibcurlUtils/LibcurlUtils.cpp   |   18 +-
 AVSCommon/Utils/src/Logger/Logger.cpp         |    2 +-
 AVSCommon/Utils/src/Logger/ThreadMoniker.cpp  |    5 +-
 AVSCommon/Utils/src/Metrics/MetricEvent.cpp   |   23 +-
 .../Utils/src/Metrics/MetricEventBuilder.cpp  |   12 +-
 .../Utils/Common/TestableMessageObserver.h    |    3 +-
 .../Utils/LibcurlUtils/MockHttpGet.h          |    2 +-
 .../test/Common/TestableMessageObserver.cpp   |    7 +-
 AVSCommon/Utils/test/MetricEventTest.cpp      |   28 +
 .../DefaultClient/ConnectionRetryTrigger.h    |    3 +-
 .../include/DefaultClient/DefaultClient.h     |    8 +-
 .../DefaultClient/DefaultClientComponent.h    |    6 +-
 .../DefaultClient/src/CMakeLists.txt          |    4 +-
 .../src/ConnectionRetryTrigger.cpp            |    6 +-
 .../DefaultClient/src/DefaultClient.cpp       |   21 +-
 .../src/DefaultClientComponent.cpp            |    4 +-
 .../CapabilitiesDelegate.h                    |    3 +
 .../DiscoveryEventSender.h                    |   13 +-
 .../src/CapabilitiesDelegate.cpp              |    6 +-
 .../src/DiscoveryEventSender.cpp              |   24 +-
 .../src/Utils/DiscoveryUtils.cpp              |   31 +-
 .../AIP/include/AIP/AudioInputProcessor.h     |   83 +-
 CapabilityAgents/AIP/include/AIP/Initiator.h  |   59 -
 .../AIP/src/AudioInputProcessor.cpp           |  242 +++-
 CapabilityAgents/AIP/src/CMakeLists.txt       |    4 +-
 .../AIP/test/AudioInputProcessorTest.cpp      | 1088 ++++++++++++-----
 CapabilityAgents/AIP/test/CMakeLists.txt      |    2 +-
 CapabilityAgents/AIP/test/MockObserver.h      |    6 +-
 CapabilityAgents/CMakeLists.txt               |    1 +
 .../InteractionModelFactory.h                 |   57 +
 .../InteractionModelCapabilityAgent.h         |   14 +
 .../acsdkInteractionModel/src/CMakeLists.txt  |    1 +
 .../src/InteractionModelCapabilityAgent.cpp   |   49 +-
 .../src/InteractionModelFactory.cpp           |   47 +
 .../InteractionModelCapabilityAgentTest.cpp   |   66 +-
 ...nModelRequestProcessingObserverInterface.h |    6 +-
 CapabilityAgents/Messaging/CMakeLists.txt     |    5 +
 .../Messaging/MessagingCapabilityAgent.h      |  513 ++++++++
 CapabilityAgents/Messaging/src/CMakeLists.txt |   13 +
 .../src/MessagingCapabilityAgent.cpp          |  697 +++++++++++
 .../Messaging/test/CMakeLists.txt             |    8 +
 .../SpeakerManager/SpeakerManagerConstants.h  |    9 +-
 .../SpeechSynthesizer/SpeechSynthesizer.h     |   99 +-
 .../SpeechSynthesizer/src/CMakeLists.txt      |    2 +-
 .../src/SpeechSynthesizer.cpp                 |  219 +++-
 .../SpeechSynthesizer/test/CMakeLists.txt     |    2 +-
 .../test/SpeechSynthesizerTest.cpp            |  306 ++++-
 .../include/TemplateRuntime/TemplateRuntime.h |    1 +
 .../TemplateRuntime/src/TemplateRuntime.cpp   |    5 +-
 .../test/TemplateRuntimeTest.cpp              |    5 +
 .../include/Captions/CaptionParserInterface.h |    2 +-
 .../include/Captions/LibwebvttParserAdapter.h |    2 +-
 .../Implementation/src/CaptionManager.cpp     |    7 +-
 .../src/LibwebvttParserAdapter.cpp            |   10 +-
 .../test/LibwebvttParserAdapterTest.cpp       |   16 +-
 .../Implementation/test/MockCaptionParser.h   |    2 +-
 CertifiedSender/src/CertifiedSender.cpp       |   12 +-
 .../include/ContextManager/ContextManager.h   |   21 +
 ContextManager/src/ContextManager.cpp         |  122 +-
 ContextManager/test/ContextManagerTest.cpp    |  219 ++++
 .../Endpoints/DefaultEndpointBuilder.h        |    1 +
 .../Endpoints/EndpointAttributeValidation.h   |    8 +
 Endpoints/include/Endpoints/EndpointBuilder.h |    5 +
 Endpoints/src/DefaultEndpointBuilder.cpp      |    6 +
 Endpoints/src/EndpointAttributeValidation.cpp |    4 +
 Endpoints/src/EndpointBuilder.cpp             |   22 +-
 .../include/Integration/AipStateObserver.h    |    4 +-
 .../Integration/ClientMessageHandler.h        |    3 +-
 .../TestExceptionEncounteredSender.h          |    6 +
 .../TestSpeechSynthesizerObserver.h           |    4 +-
 Integration/src/AipStateObserver.cpp          |    4 +-
 Integration/src/ClientMessageHandler.cpp      |    5 +-
 .../src/TestExceptionEncounteredSender.cpp    |   18 +
 .../src/TestSpeechSynthesizerObserver.cpp     |    4 +-
 Integration/test/AlertsIntegrationTest.cpp    |    4 +-
 .../AudioInputProcessorIntegrationTest.cpp    |    6 +-
 .../test/AudioPlayerIntegrationTest.cpp       |    8 +-
 Integration/test/CMakeLists.txt               |    1 +
 Metrics/UplCalculator/CMakeLists.txt          |    3 +-
 .../include/Metrics/BaseUplCalculator.h       |   16 +-
 .../include/Metrics/MediaUplCalculator.h      |   29 +-
 .../include/Metrics/TtsUplCalculator.h        |   21 +-
 .../UplCalculator/src/BaseUplCalculator.cpp   |   88 +-
 .../UplCalculator/src/MediaUplCalculator.cpp  |  181 ++-
 .../UplCalculator/src/TtsUplCalculator.cpp    |  124 +-
 Metrics/UplCalculator/src/UplMetricSink.cpp   |   19 +-
 .../test/BaseUplCalculatorTest.cpp            |  200 +++
 Metrics/UplCalculator/test/CMakeLists.txt     |    7 +
 .../test/MediaUplCalculatorTest.cpp           |  216 ++++
 .../test/Metrics/MockMetricRecorder.h         |   41 +
 .../test/TtsUplCalculatorTest.cpp             |  216 ++++
 .../UplCalculator/test/UplMetricSinkTest.cpp  |   70 ++
 .../include/SampleApp/InteractionManager.h    |    2 +-
 SampleApp/include/SampleApp/UIManager.h       |    2 +-
 SampleApp/src/InteractionManager.cpp          |    2 +-
 SampleApp/src/UIManager.cpp                   |    2 +-
 .../include/Settings/DeviceSettingsManager.h  |   14 +-
 .../Settings/Types/GeolocationEnablement.h    |  146 +++
 .../OpusEncoderContext/src/CMakeLists.txt     |   11 +-
 .../AlexaCommunicationsComponent.h            |    2 +
 .../PreviewAlexaClientComponent.h             |    4 +-
 .../src/PreviewAlexaClient.cpp                |    3 +-
 .../src/PreviewAlexaClientComponent.cpp       |    4 +-
 .../include/acsdkAudioPlayer/AudioPlayer.h    |   24 +-
 .../acsdkAudioPlayer/AudioPlayerComponent.h   |    3 +
 .../acsdkAudioPlayer/src/AudioPlayer.cpp      |   45 +-
 .../src/AudioPlayerComponent.cpp              |    2 +
 .../acsdkAudioPlayer/src/CMakeLists.txt       |    2 +
 .../acsdkAudioPlayer/test/AudioPlayerTest.cpp |   27 +
 .../acsdkAudioPlayer/test/CMakeLists.txt      |    2 +-
 .../acsdkDeviceSetup/DeviceSetupFactory.h     |   49 +
 .../acsdkDeviceSetup/src/CMakeLists.txt       |    1 +
 .../src/DeviceSetupFactory.cpp                |   38 +
 .../DoNotDisturbCapabilityAgent.h             |    3 +
 .../src/DNDSettingProtocol.cpp                |    8 +-
 .../src/DoNotDisturbCapabilityAgent.cpp       |   13 +-
 .../acsdkMultiRoomMusic/MRMCapabilityAgent.h  |    1 +
 .../src/MRMCapabilityAgent.cpp                |    1 +
 .../NotificationsCapabilityAgent.h            |   23 +
 .../src/NotificationsCapabilityAgent.cpp      |   49 +
 cmakeBuild/BuildDefaults.cmake                |    5 +
 cmakeBuild/cmake/BuildOptions.cmake           |   30 +-
 cmakeBuild/cmake/Crypto.cmake                 |    7 +-
 cmakeBuild/cmake/Sqlite.cmake                 |    7 +-
 .../LWA/LWAAuthorizationStorage.h             |    2 +
 .../src/LWA/LWAAuthorizationStorage.cpp       |    4 +
 .../test/LWAAuthorizationAdapterTest.cpp      |    2 +-
 core/CMakeLists.txt                           |   23 +-
 core/Crypto/acsdkPkcs11/src/CMakeLists.txt    |    4 +-
 core/MultiAgent/CMakeLists.txt                |    5 +
 core/MultiAgent/MultiAgent/.clang-format      |  102 ++
 .../AgentConfigurationsExample.json           |   77 ++
 .../AlexaAgentConfiguration.json              |   98 ++
 .../MultiAgent/AgentConfigurations/README.md  |  119 ++
 core/MultiAgent/MultiAgent/CMakeLists.txt     |    7 +
 core/MultiAgent/MultiAgent/README.md          |    2 +
 .../acsdk/MultiAgent/AgentManagerFactory.h    |   45 +
 .../AlexaAgentConnectionManagerFactory.h      |   48 +
 .../acsdk/MultiAgent/Agent/AVSInterface.h     |  130 ++
 .../acsdk/MultiAgent/Agent/Agent.h            |  361 ++++++
 .../acsdk/MultiAgent/Agent/ConfigParser.h     |   51 +
 .../acsdk/MultiAgent/Agent/Locale.h           |   71 ++
 .../acsdk/MultiAgent/AgentManager.h           |  184 +++
 .../Connection/AlexaAgentConnectionManager.h  |   84 ++
 .../acsdk/MultiAgent/Utils/JSONUtils.h        |   60 +
 .../MultiAgent/src/Agent/AVSInterface.cpp     |   99 ++
 .../MultiAgent/MultiAgent/src/Agent/Agent.cpp |  340 ++++++
 .../MultiAgent/src/Agent/ConfigParser.cpp     |  416 +++++++
 .../MultiAgent/src/Agent/Locale.cpp           |   80 ++
 .../MultiAgent/src/AgentManager.cpp           |  679 ++++++++++
 .../MultiAgent/src/AgentManagerFactory.cpp    |   38 +
 core/MultiAgent/MultiAgent/src/CMakeLists.txt |   26 +
 .../AlexaAgentConnectionManager.cpp           |  105 ++
 .../AlexaAgentConnectionManagerFactory.cpp    |   45 +
 .../MultiAgent/src/Utils/JSONUtils.cpp        |   88 ++
 .../MultiAgent/test/AVSInterfaceTest.cpp      |  106 ++
 .../MultiAgent/test/AgentManagerTest.cpp      |  103 ++
 core/MultiAgent/MultiAgent/test/AgentTest.cpp |   60 +
 .../MultiAgent/MultiAgent/test/CMakeLists.txt |    9 +
 .../MultiAgent/test/ConfigParserTest.cpp      |  188 +++
 .../MultiAgent/MultiAgent/test/LocaleTest.cpp |  117 ++
 .../MultiAgent/test/AgentConfigStrings.h      |  646 ++++++++++
 .../MultiAgentInterface/.clang-format         |  102 ++
 .../MultiAgentInterface/CMakeLists.txt        |   13 +
 .../Agent/LocaleInterface.h                   |   99 ++
 .../AgentManagerInterface.h                   |  334 +++++
 .../AgentConnectionManagerInterface.h         |   99 ++
 .../AgentConnectionObserverInterface.h        |   73 ++
 .../AgentEnablementObserverInterface.h        |   54 +
 .../Observer/AgentGestureObserverInterface.h  |   53 +
 .../Observer/AgentLocaleObserverInterface.h   |   57 +
 .../MultiAgentInterface/test/CMakeLists.txt   |    7 +
 .../MultiAgentInterface/MockAgentManager.h    |  110 ++
 .../Observer/MockAgentEnablementObserver.h    |   40 +
 core/MultiAgent/README.md                     |    2 +
 .../include/acsdkCore/CoreComponent.h         |    2 +
 .../RegistrationManagerFactory.h              |   57 +
 .../src/CMakeLists.txt                        |    1 +
 .../src/RegistrationManagerFactory.cpp        |   51 +
 273 files changed, 14457 insertions(+), 1275 deletions(-)
 create mode 100644 AVSCommon/AVS/include/AVSCommon/AVS/AgentId.h
 create mode 100644 AVSCommon/AVS/include/AVSCommon/AVS/AgentInitiator.h
 create mode 100644 AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h
 create mode 100644 AVSCommon/AVS/include/AVSCommon/AVS/Locale.h
 create mode 100644 AVSCommon/AVS/src/AgentId.cpp
 create mode 100644 AVSCommon/AVS/src/EndpointResources.cpp
 create mode 100644 AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/Metrics/MetricContext.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/Metrics/UplContext.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/Metrics/Utils.h
 create mode 100644 AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
 create mode 100644 AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
 delete mode 100644 CapabilityAgents/AIP/include/AIP/Initiator.h
 create mode 100644 CapabilityAgents/InteractionModel/acsdkInteractionModel/include/acsdkInteractionModel/InteractionModelFactory.h
 create mode 100644 CapabilityAgents/InteractionModel/acsdkInteractionModel/src/InteractionModelFactory.cpp
 create mode 100644 CapabilityAgents/Messaging/CMakeLists.txt
 create mode 100644 CapabilityAgents/Messaging/include/Messaging/MessagingCapabilityAgent.h
 create mode 100644 CapabilityAgents/Messaging/src/CMakeLists.txt
 create mode 100644 CapabilityAgents/Messaging/src/MessagingCapabilityAgent.cpp
 create mode 100644 CapabilityAgents/Messaging/test/CMakeLists.txt
 create mode 100644 Metrics/UplCalculator/test/BaseUplCalculatorTest.cpp
 create mode 100644 Metrics/UplCalculator/test/CMakeLists.txt
 create mode 100644 Metrics/UplCalculator/test/MediaUplCalculatorTest.cpp
 create mode 100644 Metrics/UplCalculator/test/Metrics/MockMetricRecorder.h
 create mode 100644 Metrics/UplCalculator/test/TtsUplCalculatorTest.cpp
 create mode 100644 Metrics/UplCalculator/test/UplMetricSinkTest.cpp
 create mode 100644 Settings/include/Settings/Types/GeolocationEnablement.h
 create mode 100644 capabilities/DeviceSetup/acsdkDeviceSetup/include/acsdkDeviceSetup/DeviceSetupFactory.h
 create mode 100644 capabilities/DeviceSetup/acsdkDeviceSetup/src/DeviceSetupFactory.cpp
 create mode 100644 core/MultiAgent/CMakeLists.txt
 create mode 100644 core/MultiAgent/MultiAgent/.clang-format
 create mode 100644 core/MultiAgent/MultiAgent/AgentConfigurations/AgentConfigurationsExample.json
 create mode 100644 core/MultiAgent/MultiAgent/AgentConfigurations/AlexaAgentConfiguration.json
 create mode 100644 core/MultiAgent/MultiAgent/AgentConfigurations/README.md
 create mode 100644 core/MultiAgent/MultiAgent/CMakeLists.txt
 create mode 100644 core/MultiAgent/MultiAgent/README.md
 create mode 100644 core/MultiAgent/MultiAgent/include/acsdk/MultiAgent/AgentManagerFactory.h
 create mode 100644 core/MultiAgent/MultiAgent/include/acsdk/MultiAgent/Connection/AlexaAgentConnectionManagerFactory.h
 create mode 100644 core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Agent/AVSInterface.h
 create mode 100644 core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Agent/Agent.h
 create mode 100644 core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Agent/ConfigParser.h
 create mode 100644 core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Agent/Locale.h
 create mode 100644 core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/AgentManager.h
 create mode 100644 core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Connection/AlexaAgentConnectionManager.h
 create mode 100644 core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Utils/JSONUtils.h
 create mode 100644 core/MultiAgent/MultiAgent/src/Agent/AVSInterface.cpp
 create mode 100644 core/MultiAgent/MultiAgent/src/Agent/Agent.cpp
 create mode 100644 core/MultiAgent/MultiAgent/src/Agent/ConfigParser.cpp
 create mode 100644 core/MultiAgent/MultiAgent/src/Agent/Locale.cpp
 create mode 100644 core/MultiAgent/MultiAgent/src/AgentManager.cpp
 create mode 100644 core/MultiAgent/MultiAgent/src/AgentManagerFactory.cpp
 create mode 100644 core/MultiAgent/MultiAgent/src/CMakeLists.txt
 create mode 100644 core/MultiAgent/MultiAgent/src/Connection/AlexaAgentConnectionManager.cpp
 create mode 100644 core/MultiAgent/MultiAgent/src/Connection/AlexaAgentConnectionManagerFactory.cpp
 create mode 100644 core/MultiAgent/MultiAgent/src/Utils/JSONUtils.cpp
 create mode 100644 core/MultiAgent/MultiAgent/test/AVSInterfaceTest.cpp
 create mode 100644 core/MultiAgent/MultiAgent/test/AgentManagerTest.cpp
 create mode 100644 core/MultiAgent/MultiAgent/test/AgentTest.cpp
 create mode 100644 core/MultiAgent/MultiAgent/test/CMakeLists.txt
 create mode 100644 core/MultiAgent/MultiAgent/test/ConfigParserTest.cpp
 create mode 100644 core/MultiAgent/MultiAgent/test/LocaleTest.cpp
 create mode 100644 core/MultiAgent/MultiAgent/test/include/acsdk/MultiAgent/test/AgentConfigStrings.h
 create mode 100644 core/MultiAgent/MultiAgentInterface/.clang-format
 create mode 100644 core/MultiAgent/MultiAgentInterface/CMakeLists.txt
 create mode 100644 core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Agent/LocaleInterface.h
 create mode 100644 core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/AgentManagerInterface.h
 create mode 100644 core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Connection/AgentConnectionManagerInterface.h
 create mode 100644 core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Connection/AgentConnectionObserverInterface.h
 create mode 100644 core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Observer/AgentEnablementObserverInterface.h
 create mode 100644 core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Observer/AgentGestureObserverInterface.h
 create mode 100644 core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Observer/AgentLocaleObserverInterface.h
 create mode 100644 core/MultiAgent/MultiAgentInterface/test/CMakeLists.txt
 create mode 100644 core/MultiAgent/MultiAgentInterface/test/include/acsdk/MultiAgentInterface/MockAgentManager.h
 create mode 100644 core/MultiAgent/MultiAgentInterface/test/include/acsdk/MultiAgentInterface/Observer/MockAgentEnablementObserver.h
 create mode 100644 core/MultiAgent/README.md
 create mode 100644 core/acsdkRegistrationManager/include/RegistrationManager/RegistrationManagerFactory.h
 create mode 100644 core/acsdkRegistrationManager/src/RegistrationManagerFactory.cpp

diff --git a/ACL/include/ACL/AVSConnectionManager.h b/ACL/include/ACL/AVSConnectionManager.h
index 33faa2ed..bc6604fb 100644
--- a/ACL/include/ACL/AVSConnectionManager.h
+++ b/ACL/include/ACL/AVSConnectionManager.h
@@ -174,7 +174,8 @@ private:
         const std::vector<ConnectionStatusObserverInterface::EngineConnectionStatus>& engineConnectionStatuses)
         override;
 
-    void receive(const std::string& contextId, const std::string& message) override;
+    void receive(avsCommon::avs::AgentId::IdType agentId, const std::string& contextId, const std::string& message)
+        override;
 
     std::shared_ptr<MessageRouterInterface> getMessageRouter() const;
 
diff --git a/ACL/include/ACL/Transport/DownchannelHandler.h b/ACL/include/ACL/Transport/DownchannelHandler.h
index e9f919c8..5777ed94 100644
--- a/ACL/include/ACL/Transport/DownchannelHandler.h
+++ b/ACL/include/ACL/Transport/DownchannelHandler.h
@@ -18,6 +18,7 @@
 
 #include <memory>
 
+#include <AVSCommon/AVS/AgentId.h>
 #include <AVSCommon/AVS/Attachment/AttachmentManagerInterface.h>
 #include <AVSCommon/Utils/HTTP2/HTTP2RequestSourceInterface.h>
 #include <AVSCommon/Utils/Metrics/MetricRecorderInterface.h>
@@ -44,6 +45,7 @@ public:
     /**
      * Create a DownchannelHandler, and send the downchannel request.
      *
+     * @param agentId the AgentId associated with the downchannel.
      * @param context The ExchangeContext in which this MessageRequest handler will operate.
      * @param authToken The token to use to authorize the request.
      * @param messageConsumer Object to send decoded messages to.
@@ -52,6 +54,7 @@ public:
      * @return The new DownchannelHandler or nullptr if the operation failed.
      */
     static std::shared_ptr<DownchannelHandler> create(
+        avsCommon::avs::AgentId::IdType agentId,
         std::shared_ptr<ExchangeHandlerContextInterface> context,
         const std::string& authToken,
         std::shared_ptr<MessageConsumerInterface> messageConsumer,
@@ -62,11 +65,13 @@ private:
     /**
      * Constructor.
      *
+     * @param agentId the AgentId associated with the downchannel.
      * @param context The ExchangeContext in which this MessageRequest handler will operate.
      * @param authToken The token to use to authorize the request.
      * @param metricRecorder The pointer to the recorder used to log metrics.
      */
     DownchannelHandler(
+        avsCommon::avs::AgentId::IdType agentId,
         std::shared_ptr<ExchangeHandlerContextInterface> context,
         const std::string& authToken,
         const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder);
@@ -90,6 +95,9 @@ private:
 
     /// The recorder used to log metrics.
     std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
+
+    /// The @c AgentId associated with the downchannel.
+    const avsCommon::avs::AgentId::IdType m_agentId;
 };
 
 }  // namespace acl
diff --git a/ACL/include/ACL/Transport/HTTP2Transport.h b/ACL/include/ACL/Transport/HTTP2Transport.h
index 95e6c961..520656ea 100644
--- a/ACL/include/ACL/Transport/HTTP2Transport.h
+++ b/ACL/include/ACL/Transport/HTTP2Transport.h
@@ -25,6 +25,7 @@
 #include <thread>
 #include <unordered_set>
 
+#include <AVSCommon/AVS/AgentId.h>
 #include <AVSCommon/AVS/Attachment/AttachmentManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/AuthDelegateInterface.h>
 #include <AVSCommon/SDKInterfaces/EventTracerInterface.h>
@@ -74,6 +75,7 @@ public:
     /**
      * A function that creates a HTTP2Transport object.
      *
+     * @param agentID The AgentId associated with the transport.
      * @param authDelegate The AuthDelegate implementation.
      * @param avsGateway The URL for the AVS gateway of this object.
      * @param http2Connection Instance of HTTP2ConnectionInterface with which to perform HTTP2 operations.
@@ -88,6 +90,7 @@ public:
      * @return A shared pointer to a HTTP2Transport object.
      */
     static std::shared_ptr<HTTP2Transport> create(
+        avsCommon::avs::AgentId::IdType agentId,
         std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface> authDelegate,
         const std::string& avsGateway,
         std::shared_ptr<avsCommon::utils::http2::HTTP2ConnectionInterface> http2Connection,
@@ -208,6 +211,7 @@ private:
     /**
      * HTTP2Transport Constructor.
      *
+     * @param agentId The AgentId associated with the transport.
      * @param authDelegate The AuthDelegate implementation.
      * @param avsGateway The URL for the AVS gateway of this object.
      * @param http2Connection Instance of HTTP2ConnectionInterface with which to perform HTTP2 operations.
@@ -221,6 +225,7 @@ private:
      * @param eventTracer The object used to trace events sent to AVS.
      */
     HTTP2Transport(
+        avsCommon::avs::AgentId::IdType agentId,
         std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface> authDelegate,
         const std::string& avsGateway,
         std::shared_ptr<avsCommon::utils::http2::HTTP2ConnectionInterface> http2Connection,
@@ -448,6 +453,9 @@ private:
 
     /// The power resource to prevent the device from going into LPM when a messageRequest is active.
     std::shared_ptr<avsCommon::utils::power::PowerResource> m_requestActivityPowerResource;
+
+    /// The AgentId of the HTTP2 transport.
+    const avsCommon::avs::AgentId::IdType m_agentId;
 };
 
 }  // namespace acl
diff --git a/ACL/include/ACL/Transport/HTTP2TransportFactory.h b/ACL/include/ACL/Transport/HTTP2TransportFactory.h
index 4e0c6d7e..45b3c2d4 100644
--- a/ACL/include/ACL/Transport/HTTP2TransportFactory.h
+++ b/ACL/include/ACL/Transport/HTTP2TransportFactory.h
@@ -76,6 +76,14 @@ public:
         std::shared_ptr<MessageConsumerInterface> messageConsumerInterface,
         std::shared_ptr<TransportObserverInterface> transportObserverInterface,
         std::shared_ptr<SynchronizedMessageRequestQueue> sharedMessageRequestQueue) override;
+    std::shared_ptr<TransportInterface> createTransport(
+        avsCommon::avs::AgentId::IdType agentId,
+        std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface> authDelegate,
+        std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface> attachmentManager,
+        const std::string& avsGateway,
+        std::shared_ptr<MessageConsumerInterface> messageConsumerInterface,
+        std::shared_ptr<TransportObserverInterface> transportObserverInterface,
+        std::shared_ptr<SynchronizedMessageRequestQueue> sharedMessageRequestQueue) override;
     /// @}
 
     /**
diff --git a/ACL/include/ACL/Transport/MessageRouter.h b/ACL/include/ACL/Transport/MessageRouter.h
index 5618d335..1332a93b 100644
--- a/ACL/include/ACL/Transport/MessageRouter.h
+++ b/ACL/include/ACL/Transport/MessageRouter.h
@@ -22,6 +22,7 @@
 #include <vector>
 
 #include <acsdkShutdownManagerInterfaces/ShutdownNotifierInterface.h>
+#include <AVSCommon/AVS/AgentId.h>
 #include <AVSCommon/AVS/Attachment/AttachmentManagerInterface.h>
 #include <AVSCommon/AVS/MessageRequest.h>
 #include <AVSCommon/SDKInterfaces/AuthDelegateInterface.h>
@@ -69,7 +70,7 @@ public:
         const std::shared_ptr<TransportFactoryInterface>& transportFactory);
 
     /**
-     * Constructor.
+     * Constructor for a @c MessageRouter for the Alexa agent.
      *
      * @deprecated
      * @param authDelegate An implementation of an AuthDelegate, which will provide valid access tokens with which
@@ -92,6 +93,31 @@ public:
         int engineType = avsCommon::sdkInterfaces::ENGINE_TYPE_ALEXA_VOICE_SERVICES,
         std::chrono::milliseconds serverSideDisconnectGracePeriod = DEFAULT_SERVER_SIDE_DISCONNECT_GRACE_PERIOD);
 
+    /**
+     * Constructor.
+     *
+     * @param agentId The agentId associated with the @c MessageRouter.
+     * @param authDelegate An implementation of an AuthDelegate, which will provide valid access tokens with which
+     * the MessageRouter can authorize the client to AVS.
+     * @param attachmentManager The AttachmentManager, which allows ACL to write attachments received from AVS.
+     * @param transportFactory Factory used to create new transport objects.
+     * @param avsGateway The gateway to connect to AVS. The value will be set by the @c AVSGatewayManager based on
+     * either the previously verified gateway or a value from the config file. If both are not present, a default value
+     * is used.
+     * @param engineType optional parameter of engine type associated with this MessageRouter. Default to be
+     * ENGINE_TYPE_ALEXA_VOICE_SERVICES.
+     * @param serverSideDisconnectGracePeriod How long to allow for an automatic reconnection before reporting
+     * a server side disconnect to our observer.
+     */
+    MessageRouter(
+        avsCommon::avs::AgentId::IdType agentId,
+        std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface> authDelegate,
+        std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface> attachmentManager,
+        std::shared_ptr<TransportFactoryInterface> transportFactory,
+        const std::string& avsGateway = "",
+        int engineType = avsCommon::sdkInterfaces::ENGINE_TYPE_ALEXA_VOICE_SERVICES,
+        std::chrono::milliseconds serverSideDisconnectGracePeriod = DEFAULT_SERVER_SIDE_DISCONNECT_GRACE_PERIOD);
+
     /// @name MessageRouterInterface methods.
     /// @{
     void enable() override;
@@ -257,6 +283,9 @@ private:
     /// Amount of time to allow for an automatic reconnect before notifying of a server side disconnect.
     const std::chrono::milliseconds m_serverSideReconnectGracePeriod;
 
+    /// The AgentId associated with this @c MessageRouter.
+    const avsCommon::avs::AgentId::IdType m_agentId;
+
 protected:
     /**
      * Executor to perform asynchronous operations:
diff --git a/ACL/include/ACL/Transport/MessageRouterObserverInterface.h b/ACL/include/ACL/Transport/MessageRouterObserverInterface.h
index 220d2d1e..c0336514 100644
--- a/ACL/include/ACL/Transport/MessageRouterObserverInterface.h
+++ b/ACL/include/ACL/Transport/MessageRouterObserverInterface.h
@@ -19,6 +19,8 @@
 #include <memory>
 #include <AVSCommon/SDKInterfaces/ConnectionStatusObserverInterface.h>
 
+#include <AVSCommon/AVS/AgentId.h>
+
 namespace alexaClientSDK {
 namespace acl {
 
@@ -48,11 +50,14 @@ public:
 
     /**
      * This function will be called when a Message arrives from AVS.
-     *
+     * @param agentId is the agent that is associated with the message.
      * @param contextId The contextId of the AVS message, which is used when acquiring attachments.
      * @param message The AVS message that has been received.
      */
-    virtual void receive(const std::string& contextId, const std::string& message) = 0;
+    virtual void receive(
+        avsCommon::avs::AgentId::IdType agentId,
+        const std::string& contextId,
+        const std::string& message) = 0;
 };
 
 }  // namespace acl
diff --git a/ACL/include/ACL/Transport/TransportFactoryInterface.h b/ACL/include/ACL/Transport/TransportFactoryInterface.h
index 083b7f98..cfb8a5fc 100644
--- a/ACL/include/ACL/Transport/TransportFactoryInterface.h
+++ b/ACL/include/ACL/Transport/TransportFactoryInterface.h
@@ -20,6 +20,7 @@
 #include <string>
 
 #include <AVSCommon/SDKInterfaces/AuthDelegateInterface.h>
+#include <AVSCommon/AVS/AgentId.h>
 #include <AVSCommon/AVS/Attachment/AttachmentManagerInterface.h>
 
 #include "ACL/Transport/TransportInterface.h"
@@ -35,9 +36,29 @@ namespace acl {
  */
 class TransportFactoryInterface {
 public:
+    /**
+     * Creates a new transport for the Alexa Agent.
+     *
+     * @param authDelegate The AuthDelegateInterface to use for authentication and authorization with AVS.
+     * @param attachmentManager The attachment manager that manages the attachments.
+     * @param avsGateway The URL for the AVS server we will connect to.
+     * @param messageConsumerInterface The object which should be notified on messages which arrive from AVS.
+     * @param transportObserverInterface A pointer to the transport observer the new transport should notify.
+     * @param sharedRequestQueue Request queue shared by all instances of TransportInterface.
+     * @return A new MessageRouter object.
+     */
+    virtual std::shared_ptr<TransportInterface> createTransport(
+        std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface> authDelegate,
+        std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface> attachmentManager,
+        const std::string& avsGateway,
+        std::shared_ptr<MessageConsumerInterface> messageConsumerInterface,
+        std::shared_ptr<TransportObserverInterface> transportObserverInterface,
+        std::shared_ptr<SynchronizedMessageRequestQueue> sharedMessageRequestQueue) = 0;
+
     /**
      * Creates a new transport.
      *
+     * @param agentId The AgentId associated with the Transport.
      * @param authDelegate The AuthDelegateInterface to use for authentication and authorization with AVS.
      * @param attachmentManager The attachment manager that manages the attachments.
      * @param avsGateway The URL for the AVS server we will connect to.
@@ -47,6 +68,7 @@ public:
      * @return A new MessageRouter object.
      */
     virtual std::shared_ptr<TransportInterface> createTransport(
+        avsCommon::avs::AgentId::IdType agentId,
         std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface> authDelegate,
         std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface> attachmentManager,
         const std::string& avsGateway,
diff --git a/ACL/src/AVSConnectionManager.cpp b/ACL/src/AVSConnectionManager.cpp
index c5983a6c..74b71063 100644
--- a/ACL/src/AVSConnectionManager.cpp
+++ b/ACL/src/AVSConnectionManager.cpp
@@ -13,6 +13,7 @@
  * permissions and limitations under the License.
  */
 
+#include "AVSCommon/AVS/AgentId.h"
 #include "AVSCommon/AVS/Initialization/AlexaClientSDKInit.h"
 #include "AVSCommon/Utils/Logger/Logger.h"
 #include "AVSCommon/Utils/Memory/Memory.h"
@@ -281,7 +282,10 @@ void AVSConnectionManager::onConnectionStatusChanged(
     updateConnectionStatus(status, engineConnectionStatuses);
 }
 
-void AVSConnectionManager::receive(const std::string& contextId, const std::string& message) {
+void AVSConnectionManager::receive(
+    avsCommon::avs::AgentId::IdType agentId,
+    const std::string& contextId,
+    const std::string& message) {
     std::unique_lock<std::mutex> lock{m_messageObserverMutex};
     std::unordered_set<std::shared_ptr<avsCommon::sdkInterfaces::MessageObserverInterface>> observers{
         m_messageObservers};
@@ -289,7 +293,7 @@ void AVSConnectionManager::receive(const std::string& contextId, const std::stri
 
     for (auto observer : observers) {
         if (observer) {
-            observer->receive(contextId, message);
+            observer->receive(agentId, contextId, message);
         }
     }
 }
diff --git a/ACL/src/Transport/DownchannelHandler.cpp b/ACL/src/Transport/DownchannelHandler.cpp
index f68908c0..a270f9fe 100644
--- a/ACL/src/Transport/DownchannelHandler.cpp
+++ b/ACL/src/Transport/DownchannelHandler.cpp
@@ -60,16 +60,21 @@ static const std::string RESPONSE_FINISHED = "RESPONSE_FINISHED";
 
 /**
  * Creates a MetricEvent with the given event name and datapoint and submits it with the metric recorder.
+ * @param agentId The AgentId associated with the downchannel.
  * @param metricRecorder The @c MetricRecorderInterface used log the metric.
  * @param eventName The event name of the metric to be logged.
  * @param dataPoint The @c DataPoint to be added to the metric.
  */
 void submitMetric(
     const std::shared_ptr<MetricRecorderInterface>& metricRecorder,
+    avsCommon::avs::AgentId::IdType agentId,
     const std::string& eventName,
     const DataPoint& dataPoint) {
-    auto metricEvent =
-        MetricEventBuilder{}.setActivityName(METRIC_SOURCE_PREFIX + eventName).addDataPoint(dataPoint).build();
+    auto metricEvent = MetricEventBuilder{}
+                           .setMetricContext({agentId})
+                           .setActivityName(METRIC_SOURCE_PREFIX + eventName)
+                           .addDataPoint(dataPoint)
+                           .build();
 
     if (!metricEvent) {
         ACSDK_ERROR(LX("submitMetricFailed").d("reason", "invalid metric event"));
@@ -83,10 +88,12 @@ void submitMetric(
  * Submits a metric when the downchannel stream is closed either because it is closed from the server, due to internal
  * error or due to timeouts.
  *
+ * @param agentId The AgentId associated with the downchannel.
  * @param metricRecorder The pointer to the metric recorder used to log the metric.
  * @param status The @c HTTP2ResponseFinishedStatus status with which the downchannel stream is closed.
  */
 void submitResponseFinishedMetric(
+    avsCommon::avs::AgentId::IdType agentId,
     const std::shared_ptr<MetricRecorderInterface>& metricRecorder,
     HTTP2ResponseFinishedStatus status) {
     if (!metricRecorder) {
@@ -102,28 +109,29 @@ void submitResponseFinishedMetric(
     ss << status;
     auto dataPoint = DataPointCounterBuilder{}.setName(ss.str()).increment(1).build();
 
-    submitMetric(metricRecorder, RESPONSE_FINISHED, dataPoint);
+    submitMetric(metricRecorder, agentId, RESPONSE_FINISHED, dataPoint);
 }
 
 std::shared_ptr<DownchannelHandler> DownchannelHandler::create(
+    avsCommon::avs::AgentId::IdType agentId,
     std::shared_ptr<ExchangeHandlerContextInterface> context,
     const std::string& authToken,
     std::shared_ptr<MessageConsumerInterface> messageConsumer,
     std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface> attachmentManager,
     const std::shared_ptr<MetricRecorderInterface>& metricRecorder) {
-    ACSDK_DEBUG9(LX("create").d("context", context.get()));
+    ACSDK_DEBUG9(LX("create").d("agentId", agentId).d("context", context.get()));
 
     if (!context) {
-        ACSDK_CRITICAL(LX("createFailed").d("reason", "nullHttp2Transport"));
+        ACSDK_CRITICAL(LX("createFailed").d("agentId", agentId).d("reason", "nullHttp2Transport"));
         return nullptr;
     }
 
     if (authToken.empty()) {
-        ACSDK_DEBUG9(LX("createFailed").d("reason", "emptyAuthToken"));
+        ACSDK_DEBUG9(LX("createFailed").d("agentId", agentId).d("reason", "emptyAuthToken"));
         return nullptr;
     }
 
-    std::shared_ptr<DownchannelHandler> handler(new DownchannelHandler(context, authToken, metricRecorder));
+    std::shared_ptr<DownchannelHandler> handler(new DownchannelHandler(agentId, context, authToken, metricRecorder));
 
     HTTP2RequestConfig cfg{
         HTTP2RequestType::GET, context->getAVSGateway() + AVS_DOWNCHANNEL_URL_PATH_EXTENSION, DOWNCHANNEL_ID_PREFIX};
@@ -136,7 +144,7 @@ std::shared_ptr<DownchannelHandler> DownchannelHandler::create(
     auto request = context->createAndSendRequest(cfg);
 
     if (!request) {
-        ACSDK_ERROR(LX("createFailed").d("reason", "createAndSendRequestFailed"));
+        ACSDK_ERROR(LX("createFailed").d("agentId", agentId).d("reason", "createAndSendRequestFailed"));
         return nullptr;
     }
 
@@ -144,21 +152,23 @@ std::shared_ptr<DownchannelHandler> DownchannelHandler::create(
 }
 
 std::vector<std::string> DownchannelHandler::getRequestHeaderLines() {
-    ACSDK_DEBUG9(LX("getRequestHeaderLines"));
+    ACSDK_DEBUG9(LX("getRequestHeaderLines").d("agentId", m_agentId));
     return {m_authHeader};
 }
 
 HTTP2SendDataResult DownchannelHandler::onSendData(char* bytes, size_t size) {
-    ACSDK_DEBUG9(LX("onSendData").d("size", size));
+    ACSDK_DEBUG9(LX("onSendData").d("agentId", m_agentId).d("size", size));
     return HTTP2SendDataResult::COMPLETE;
 }
 
 DownchannelHandler::DownchannelHandler(
+    avsCommon::avs::AgentId::IdType agentId,
     std::shared_ptr<ExchangeHandlerContextInterface> context,
     const std::string& authToken,
     const std::shared_ptr<MetricRecorderInterface>& metricRecorder) :
         ExchangeHandler{context, authToken},
-        m_metricRecorder{metricRecorder} {
+        m_metricRecorder{metricRecorder},
+        m_agentId{agentId} {
     ACSDK_DEBUG9(LX("init").d("context", context.get()));
     m_powerResource = PowerMonitor::getInstance()->createLocalPowerResource(TAG);
     if (m_powerResource) {
@@ -171,7 +181,7 @@ void DownchannelHandler::onActivity() {
 }
 
 bool DownchannelHandler::onReceiveResponseCode(long responseCode) {
-    ACSDK_DEBUG5(LX("onReceiveResponseCode").d("responseCode", responseCode));
+    ACSDK_DEBUG5(LX("onReceiveResponseCode").d("agentId", m_agentId).d("responseCode", responseCode));
     switch (intToHTTPResponseCode(responseCode)) {
         case HTTPResponseCode::HTTP_RESPONSE_CODE_UNDEFINED:
         case HTTPResponseCode::SUCCESS_CREATED:
@@ -205,9 +215,9 @@ bool DownchannelHandler::onReceiveResponseCode(long responseCode) {
 }
 
 void DownchannelHandler::onResponseFinished(HTTP2ResponseFinishedStatus status, const std::string& nonMimeBody) {
-    ACSDK_DEBUG5(LX("onResponseFinished").d("status", status).d("nonMimeBody", nonMimeBody));
+    ACSDK_DEBUG5(LX("onResponseFinished").d("agentId", m_agentId).d("status", status).d("nonMimeBody", nonMimeBody));
     m_context->onDownchannelFinished();
-    submitResponseFinishedMetric(m_metricRecorder, status);
+    submitResponseFinishedMetric(m_agentId, m_metricRecorder, status);
 }
 
 }  // namespace acl
diff --git a/ACL/src/Transport/HTTP2Transport.cpp b/ACL/src/Transport/HTTP2Transport.cpp
index 5d50ad78..6ea19a2b 100644
--- a/ACL/src/Transport/HTTP2Transport.cpp
+++ b/ACL/src/Transport/HTTP2Transport.cpp
@@ -58,7 +58,7 @@ static const std::string TAG("HTTP2Transport");
  *
  * @param event The event string for this @c LogEntry.
  */
-#define LX_P(event) LX(event).p("this", this).sensitive("gateway", m_avsGateway)
+#define LX_P(event) LX(event).p("this", this).d("agentId", m_agentId).sensitive("gateway", m_avsGateway)
 
 /// The maximum number of streams we can have active at once.  Please see here for more information:
 /// https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/docs/managing-an-http-2-connection
@@ -85,10 +85,12 @@ static const std::string DISCONNECT_REASON = "DISCONNECT_REASON";
 /**
  * Capture metric for Disconnects along with Disconnect reason.
  *
+ * @param agentId The AgentId associated with the transport.
  * @param metricRecorder The metric recorder object.
  * @param reason The @c ConnectionStatusObserverInterface::ChangedReason for disconnection.
  */
 static void submitDisconnectReasonMetric(
+    avsCommon::avs::AgentId::IdType agentId,
     const std::shared_ptr<MetricRecorderInterface>& metricRecorder,
     ConnectionStatusObserverInterface::ChangedReason reason) {
     if (!metricRecorder) {
@@ -104,6 +106,7 @@ static void submitDisconnectReasonMetric(
     ss << reason;
 
     auto metricEvent = MetricEventBuilder{}
+                           .setMetricContext({agentId})
                            .setActivityName(HTTP2TRANSPORT_METRIC_SOURCE_PREFIX + DISCONNECT_REASON)
                            .addDataPoint(DataPointCounterBuilder{}.setName(ss.str()).increment(1).build())
                            .build();
@@ -119,10 +122,12 @@ static void submitDisconnectReasonMetric(
 /**
  * Capture metric for cases where there are internal message send errors or timeouts.
  *
+ * @param agentId The AgentId associated with the transport.
  * @param metricRecorder The metric recorder object.
  * @param status The @c MessageRequestObserverInterface::Status of the message.
  */
 static void submitMessageSendErrorMetric(
+    avsCommon::avs::AgentId::IdType agentId,
     const std::shared_ptr<MetricRecorderInterface>& metricRecorder,
     MessageRequestObserverInterface::Status status) {
     if (!metricRecorder) {
@@ -140,6 +145,7 @@ static void submitMessageSendErrorMetric(
     }
 
     auto metricEvent = MetricEventBuilder{}
+                           .setMetricContext({agentId})
                            .setActivityName(HTTP2TRANSPORT_METRIC_SOURCE_PREFIX + MESSAGE_SEND_ERROR)
                            .addDataPoint(DataPointCounterBuilder{}.setName(ss.str()).increment(1).build())
                            .build();
@@ -187,6 +193,7 @@ HTTP2Transport::Configuration::Configuration() : inactivityTimeout{INACTIVITY_TI
 }
 
 std::shared_ptr<HTTP2Transport> HTTP2Transport::create(
+    AgentId::IdType agentId,
     std::shared_ptr<AuthDelegateInterface> authDelegate,
     const std::string& avsGateway,
     std::shared_ptr<HTTP2ConnectionInterface> http2Connection,
@@ -199,6 +206,7 @@ std::shared_ptr<HTTP2Transport> HTTP2Transport::create(
     std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder,
     std::shared_ptr<EventTracerInterface> eventTracer) {
     ACSDK_DEBUG5(LX("create")
+                     .d("agentId", agentId)
                      .d("authDelegate", authDelegate.get())
                      .d("avsGateway", avsGateway)
                      .d("http2Connection", http2Connection.get())
@@ -244,6 +252,7 @@ std::shared_ptr<HTTP2Transport> HTTP2Transport::create(
     }
 
     auto transport = std::shared_ptr<HTTP2Transport>(new HTTP2Transport(
+        agentId,
         std::move(authDelegate),
         avsGateway,
         std::move(http2Connection),
@@ -260,6 +269,7 @@ std::shared_ptr<HTTP2Transport> HTTP2Transport::create(
 }
 
 HTTP2Transport::HTTP2Transport(
+    avsCommon::avs::AgentId::IdType agentId,
     std::shared_ptr<AuthDelegateInterface> authDelegate,
     const std::string& avsGateway,
     std::shared_ptr<HTTP2ConnectionInterface> http2Connection,
@@ -285,7 +295,8 @@ HTTP2Transport::HTTP2Transport(
         m_countOfUnfinishedMessageHandlers{0},
         m_postConnected{false},
         m_configuration{configuration},
-        m_disconnectReason{ConnectionStatusObserverInterface::ChangedReason::NONE} {
+        m_disconnectReason{ConnectionStatusObserverInterface::ChangedReason::NONE},
+        m_agentId{agentId} {
     m_observers.insert(transportObserver);
 
     m_mainLoopPowerResource = PowerMonitor::getInstance()->createLocalPowerResource(TAG + "_mainLoop");
@@ -420,7 +431,7 @@ void HTTP2Transport::sendMessage(std::shared_ptr<MessageRequest> request) {
         lock.unlock();
         auto status = MessageRequestObserverInterface::Status::NOT_CONNECTED;
         request->sendCompleted(status);
-        submitMessageSendErrorMetric(m_metricRecorder, status);
+        submitMessageSendErrorMetric(m_agentId, m_metricRecorder, status);
     }
 }
 
@@ -722,7 +733,7 @@ HTTP2Transport::State HTTP2Transport::handleConnecting() {
     }
 
     auto downchannelHandler = DownchannelHandler::create(
-        shared_from_this(), authToken, m_messageConsumer, m_attachmentManager, m_metricRecorder);
+        m_agentId, shared_from_this(), authToken, m_messageConsumer, m_attachmentManager, m_metricRecorder);
 
     if (!downchannelHandler) {
         ACSDK_ERROR(LX_P("handleConnectingFailed").d("reason", "createDownchannelHandlerFailed"));
@@ -788,7 +799,7 @@ HTTP2Transport::State HTTP2Transport::handleServerSideDisconnect() {
     ACSDK_INFO(LX_P("handleServerSideDisconnect"));
     notifyObserversOnServerSideDisconnect();
     submitDisconnectReasonMetric(
-        m_metricRecorder, ConnectionStatusObserverInterface::ChangedReason::SERVER_SIDE_DISCONNECT);
+        m_agentId, m_metricRecorder, ConnectionStatusObserverInterface::ChangedReason::SERVER_SIDE_DISCONNECT);
     return State::DISCONNECTING;
 }
 
@@ -823,7 +834,7 @@ HTTP2Transport::State HTTP2Transport::handleShutdown() {
     m_http2Connection->disconnect();
 
     notifyObserversOnDisconnect(m_disconnectReason);
-    submitDisconnectReasonMetric(m_metricRecorder, m_disconnectReason);
+    submitDisconnectReasonMetric(m_agentId, m_metricRecorder, m_disconnectReason);
 
     return State::SHUTDOWN;
 }
@@ -851,7 +862,7 @@ HTTP2Transport::State HTTP2Transport::monitorSharedQueueWhileWaiting(
             auto request = m_sharedRequestQueue->dequeueOldestRequest();
             auto status = MessageRequestObserverInterface::Status::TIMEDOUT;
             request->sendCompleted(status);
-            submitMessageSendErrorMetric(m_metricRecorder, status);
+            submitMessageSendErrorMetric(m_agentId, m_metricRecorder, status);
         }
 
         auto messageRequestTime = m_sharedRequestQueue->peekRequestTime();
@@ -916,7 +927,7 @@ HTTP2Transport::State HTTP2Transport::sendMessagesAndPings(
                 if (!handler) {
                     auto status = MessageRequestObserverInterface::Status::INTERNAL_ERROR;
                     messageRequest->sendCompleted(status);
-                    submitMessageSendErrorMetric(m_metricRecorder, status);
+                    submitMessageSendErrorMetric(m_agentId, m_metricRecorder, status);
                 }
             } else {
                 ACSDK_ERROR(LX_P("failedToCreateMessageHandler").d("reason", "invalidAuth"));
diff --git a/ACL/src/Transport/HTTP2TransportFactory.cpp b/ACL/src/Transport/HTTP2TransportFactory.cpp
index 805536fb..89561548 100644
--- a/ACL/src/Transport/HTTP2TransportFactory.cpp
+++ b/ACL/src/Transport/HTTP2TransportFactory.cpp
@@ -53,6 +53,24 @@ std::shared_ptr<TransportFactoryInterface> HTTP2TransportFactory::createTranspor
 }
 
 std::shared_ptr<TransportInterface> HTTP2TransportFactory::createTransport(
+    std::shared_ptr<AuthDelegateInterface> authDelegate,
+    std::shared_ptr<AttachmentManagerInterface> attachmentManager,
+    const std::string& avsGateway,
+    std::shared_ptr<MessageConsumerInterface> messageConsumerInterface,
+    std::shared_ptr<TransportObserverInterface> transportObserverInterface,
+    std::shared_ptr<SynchronizedMessageRequestQueue> sharedMessageRequestQueue) {
+    return createTransport(
+        avsCommon::avs::AgentId::getAlexaAgentId(),
+        authDelegate,
+        attachmentManager,
+        avsGateway,
+        messageConsumerInterface,
+        transportObserverInterface,
+        sharedMessageRequestQueue);
+}
+
+std::shared_ptr<TransportInterface> HTTP2TransportFactory::createTransport(
+    avsCommon::avs::AgentId::IdType agentId,
     std::shared_ptr<AuthDelegateInterface> authDelegate,
     std::shared_ptr<AttachmentManagerInterface> attachmentManager,
     const std::string& avsGateway,
@@ -65,6 +83,7 @@ std::shared_ptr<TransportInterface> HTTP2TransportFactory::createTransport(
     }
 
     return HTTP2Transport::create(
+        agentId,
         authDelegate,
         avsGateway,
         connection,
diff --git a/ACL/src/Transport/MessageRequestHandler.cpp b/ACL/src/Transport/MessageRequestHandler.cpp
index 4a036005..cd03db02 100644
--- a/ACL/src/Transport/MessageRequestHandler.cpp
+++ b/ACL/src/Transport/MessageRequestHandler.cpp
@@ -106,20 +106,23 @@ static const std::string HTTP_KEY_VALUE_SEPARATOR = ": ";
  * Capture metric for the last send data result.
  *
  * @param metricRecorder The metric recorder object.
+ * @param messageRequest The @c MessageRequest object.
  * @param count Number of errors.
  * @param readStatus The read status.
  */
 static void collectSendDataResultMetric(
     const std::shared_ptr<MetricRecorderInterface>& metricRecorder,
+    const std::shared_ptr<avsCommon::avs::MessageRequest>& messageRequest,
     int count,
     const std::string& readStatus) {
-    if (!metricRecorder) {
+    if (!metricRecorder || !messageRequest) {
         return;
     }
 
     recordMetric(
         metricRecorder,
         MetricEventBuilder{}
+            .setMetricContext({messageRequest->getAgentId()})
             .setActivityName(ACL_METRIC_SOURCE_PREFIX + SEND_DATA_ERROR)
             .addDataPoint(DataPointCounterBuilder{}.setName(SEND_DATA_ERROR).increment(count).build())
             .addDataPoint(DataPointStringBuilder{}.setName(READ_STATUS_TAG).setValue(readStatus).build())
@@ -130,12 +133,14 @@ static void collectSendDataResultMetric(
  * Capture metric for cases where there are internal message send errors or timeouts.
  *
  * @param metricRecorder The metric recorder object.
+ * @param messageRequest The @c MessageRequest object.
  * @param status The @c MessageRequestObserverInterface::Status of the message.
  */
 static void submitMessageSendErrorMetric(
     const std::shared_ptr<MetricRecorderInterface>& metricRecorder,
+    const std::shared_ptr<avsCommon::avs::MessageRequest>& messageRequest,
     MessageRequestObserverInterface::Status status) {
-    if (!metricRecorder) {
+    if (!metricRecorder || !messageRequest) {
         return;
     }
 
@@ -156,6 +161,7 @@ static void submitMessageSendErrorMetric(
     }
 
     auto metricEvent = MetricEventBuilder{}
+                           .setMetricContext({messageRequest->getAgentId()})
                            .setActivityName(ACL_METRIC_SOURCE_PREFIX + MESSAGE_SEND_ERROR)
                            .addDataPoint(DataPointCounterBuilder{}.setName(ss.str()).increment(1).build())
                            .build();
@@ -187,6 +193,7 @@ void MessageRequestHandler::recordStreamMetric(int bytes) {
     }
     if (threshold <= m_streamBytesRead) {
         auto metricEvent = MetricEventBuilder{}
+                               .setMetricContext({m_messageRequest->getAgentId()})
                                .setActivityName(ACL_METRIC_SOURCE_PREFIX + metricName)
                                .addDataPoint(DataPointCounterBuilder{}.setName(metricName).increment(1).build())
                                .build();
@@ -200,11 +207,12 @@ void MessageRequestHandler::recordStreamMetric(int bytes) {
 }
 
 void MessageRequestHandler::recordStartOfEventMetric() {
-    if (!m_metricRecorder) {
+    if (!m_metricRecorder || !m_messageRequest) {
         return;
     }
     auto metricEvent =
         MetricEventBuilder{}
+            .setMetricContext({m_messageRequest->getAgentId()})
             .setActivityName(ACL_METRIC_SOURCE_PREFIX + START_EVENT_SENT_TO_CLOUD)
             .addDataPoint(DataPointCounterBuilder{}.setName(START_EVENT_SENT_TO_CLOUD).increment(1).build())
             .build();
@@ -398,17 +406,17 @@ HTTP2SendDataResult MessageRequestHandler::onSendMimePartData(char* bytes, size_
                 // Stream consumed.  Move on to next part.
                 m_namedReader.reset();
                 m_countOfPartsSent++;
-                collectSendDataResultMetric(m_metricRecorder, 0, SEND_COMPLETED);
+                collectSendDataResultMetric(m_metricRecorder, m_messageRequest, 0, SEND_COMPLETED);
                 return HTTP2SendDataResult::COMPLETE;
 
             // Handle any attachment read errors.
             case AttachmentReader::ReadStatus::ERROR_OVERRUN:
-                collectSendDataResultMetric(m_metricRecorder, 1, ERROR_READ_OVERRUN);
+                collectSendDataResultMetric(m_metricRecorder, m_messageRequest, 1, ERROR_READ_OVERRUN);
                 // Stream failure.  Abort sending the request.
                 return HTTP2SendDataResult::ABORT;
 
             case AttachmentReader::ReadStatus::ERROR_INTERNAL:
-                collectSendDataResultMetric(m_metricRecorder, 1, ERROR_INTERNAL);
+                collectSendDataResultMetric(m_metricRecorder, m_messageRequest, 1, ERROR_INTERNAL);
                 // Stream failure.  Abort sending the request.
                 return HTTP2SendDataResult::ABORT;
 
@@ -506,7 +514,7 @@ void MessageRequestHandler::onResponseFinished(HTTP2ResponseFinishedStatus statu
 
     m_messageRequest->sendCompleted(m_resultStatus);
 
-    submitMessageSendErrorMetric(m_metricRecorder, m_resultStatus);
+    submitMessageSendErrorMetric(m_metricRecorder, m_messageRequest, m_resultStatus);
 }
 
 }  // namespace acl
diff --git a/ACL/src/Transport/MessageRouter.cpp b/ACL/src/Transport/MessageRouter.cpp
index 752ad20a..39273b34 100644
--- a/ACL/src/Transport/MessageRouter.cpp
+++ b/ACL/src/Transport/MessageRouter.cpp
@@ -31,7 +31,7 @@ using namespace avsCommon::avs::attachment;
 using namespace avsCommon::avs;
 
 /// String to identify log entries originating from this file.
-static const std::string TAG("MessageRouter");
+#define TAG "MessageRouter"
 
 /// String for logging purpose as the key for the size of m_transports.
 static constexpr const char* KEY_SIZEOF_TRANSPORTS = "sizeOf m_transports";
@@ -45,6 +45,8 @@ const std::chrono::milliseconds MessageRouter::DEFAULT_SERVER_SIDE_DISCONNECT_GR
  */
 #define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
 
+#define LX_WITH_AGENT_ID(event) LX(event).d("agentId", m_agentId)
+
 std::shared_ptr<MessageRouterInterface> MessageRouter::createMessageRouterInterface(
     const std::shared_ptr<acsdkShutdownManagerInterfaces::ShutdownNotifierInterface>& shutdownNotifier,
     const std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface>& authDelegate,
@@ -90,7 +92,32 @@ MessageRouter::MessageRouter(
         m_requestQueue{std::make_shared<SynchronizedMessageRequestQueue>()},
         m_serverSideDisconnectNotificationPending{false},
         m_lastReportedConnectionStatus{ConnectionStatusObserverInterface::Status::DISCONNECTED},
-        m_serverSideReconnectGracePeriod{serverSideDisconnectGracePeriod} {
+        m_serverSideReconnectGracePeriod{serverSideDisconnectGracePeriod},
+        m_agentId{AgentId::getAlexaAgentId()} {
+}
+
+MessageRouter::MessageRouter(
+    avsCommon::avs::AgentId::IdType agentId,
+    std::shared_ptr<AuthDelegateInterface> authDelegate,
+    std::shared_ptr<AttachmentManagerInterface> attachmentManager,
+    std::shared_ptr<TransportFactoryInterface> transportFactory,
+    const std::string& avsGateway,
+    int engineType,
+    std::chrono::milliseconds serverSideDisconnectGracePeriod) :
+        MessageRouterInterface{"MessageRouter"},
+        m_avsGateway{avsGateway},
+        m_authDelegate{authDelegate},
+        m_connectionStatus{ConnectionStatusObserverInterface::Status::DISCONNECTED},
+        m_connectionReason{ConnectionStatusObserverInterface::ChangedReason::ACL_CLIENT_REQUEST},
+        m_engineType{engineType},
+        m_isEnabled{false},
+        m_attachmentManager{attachmentManager},
+        m_transportFactory{transportFactory},
+        m_requestQueue{std::make_shared<SynchronizedMessageRequestQueue>()},
+        m_serverSideDisconnectNotificationPending{false},
+        m_lastReportedConnectionStatus{ConnectionStatusObserverInterface::Status::DISCONNECTED},
+        m_serverSideReconnectGracePeriod{serverSideDisconnectGracePeriod},
+        m_agentId{agentId} {
 }
 
 MessageRouterInterface::ConnectionStatus MessageRouter::getConnectionStatus() {
@@ -99,16 +126,16 @@ MessageRouterInterface::ConnectionStatus MessageRouter::getConnectionStatus() {
 }
 
 void MessageRouter::enable() {
-    ACSDK_INFO(LX("enable"));
+    ACSDK_INFO(LX_WITH_AGENT_ID("enable"));
     std::lock_guard<std::mutex> lock{m_connectionMutex};
 
     if (m_isEnabled) {
-        ACSDK_INFO(LX("enableFailed").m("already enabled"));
+        ACSDK_INFO(LX_WITH_AGENT_ID("enableFailed").m("already enabled"));
         return;
     }
 
     if (m_activeTransport != nullptr) {
-        ACSDK_ERROR(LX("enableFailed").d("reason", "activeTransportNotNull"));
+        ACSDK_ERROR(LX_WITH_AGENT_ID("enableFailed").d("reason", "activeTransportNotNull"));
         return;
     }
 
@@ -137,7 +164,7 @@ void MessageRouter::doShutdown() {
 }
 
 void MessageRouter::disable() {
-    ACSDK_INFO(LX("disable"));
+    ACSDK_INFO(LX_WITH_AGENT_ID("disable"));
     std::unique_lock<std::mutex> lock{m_connectionMutex};
     m_isEnabled = false;
     disconnectAllTransportsLocked(lock, ConnectionStatusObserverInterface::ChangedReason::ACL_CLIENT_REQUEST);
@@ -145,12 +172,12 @@ void MessageRouter::disable() {
 
 void MessageRouter::sendMessage(std::shared_ptr<MessageRequest> request) {
     if (!request) {
-        ACSDK_ERROR(LX("sendFailed").d("reason", "nullRequest"));
+        ACSDK_ERROR(LX_WITH_AGENT_ID("sendFailed").d("reason", "nullRequest"));
         return;
     }
 
     if (!request->isResolved()) {
-        ACSDK_ERROR(LX("sendFailed").d("reason", "requestNotReady"));
+        ACSDK_ERROR(LX_WITH_AGENT_ID("sendFailed").d("reason", "requestNotReady"));
         request->sendCompleted(MessageRequestObserverInterface::Status::BAD_REQUEST);
         return;
     }
@@ -160,13 +187,13 @@ void MessageRouter::sendMessage(std::shared_ptr<MessageRequest> request) {
         m_requestQueue->enqueueRequest(request);
         m_activeTransport->onRequestEnqueued();
     } else {
-        ACSDK_ERROR(LX("sendFailed").d("reason", "noActiveTransport"));
+        ACSDK_ERROR(LX_WITH_AGENT_ID("sendFailed").d("reason", "noActiveTransport"));
         request->sendCompleted(MessageRequestObserverInterface::Status::NOT_CONNECTED);
     }
 }
 
 void MessageRouter::setAVSGateway(const std::string& avsGateway) {
-    ACSDK_INFO(LX("setAVSGateway").d("avsGateway", avsGateway));
+    ACSDK_INFO(LX_WITH_AGENT_ID("setAVSGateway").d("avsGateway", avsGateway));
     std::unique_lock<std::mutex> lock{m_connectionMutex};
     if (avsGateway != m_avsGateway) {
         m_avsGateway = avsGateway;
@@ -187,38 +214,38 @@ std::string MessageRouter::getAVSGateway() {
 }
 
 void MessageRouter::onWakeConnectionRetry() {
-    ACSDK_INFO(LX("onWakeConnectionRetry"));
+    ACSDK_INFO(LX_WITH_AGENT_ID("onWakeConnectionRetry"));
     std::lock_guard<std::mutex> lock{m_connectionMutex};
     if (m_isEnabled && m_activeTransport) {
-        ACSDK_INFO(LX("onWakeConnectionRetry").p("m_activeTransport", m_activeTransport));
+        ACSDK_INFO(LX_WITH_AGENT_ID("onWakeConnectionRetry").p("m_activeTransport", m_activeTransport));
         m_activeTransport->onWakeConnectionRetry();
     }
 }
 
 void MessageRouter::onWakeVerifyConnectivity() {
-    ACSDK_INFO(LX("onWakeVerifyConnectivity"));
+    ACSDK_INFO(LX_WITH_AGENT_ID("onWakeVerifyConnectivity"));
     std::lock_guard<std::mutex> lock{m_connectionMutex};
     if (m_isEnabled && m_activeTransport) {
-        ACSDK_INFO(LX("onWakeVerifyConnectivity").p("m_activeTransport", m_activeTransport));
+        ACSDK_INFO(LX_WITH_AGENT_ID("onWakeVerifyConnectivity").p("m_activeTransport", m_activeTransport));
         m_activeTransport->onWakeVerifyConnectivity();
     }
 }
 
 void MessageRouter::onConnected(std::shared_ptr<TransportInterface> transport) {
     std::unique_lock<std::mutex> lock{m_connectionMutex};
-    ACSDK_INFO(LX("onConnected").p("transport", transport).p("m_activeTransport", m_activeTransport));
+    ACSDK_INFO(LX_WITH_AGENT_ID("onConnected").p("transport", transport).p("m_activeTransport", m_activeTransport));
 
     /*
      * Transport shutdown might be asynchronous,so the following scenarios are valid,
      * but we shouldn't update the connection status.
      */
     if (!m_isEnabled) {
-        ACSDK_DEBUG0(LX("onConnectedWhenDisabled"));
+        ACSDK_DEBUG0(LX_WITH_AGENT_ID("onConnectedWhenDisabled"));
         return;
     }
 
     if (transport != m_activeTransport) {
-        ACSDK_DEBUG0(LX("onInactiveTransportConnected"));
+        ACSDK_DEBUG0(LX_WITH_AGENT_ID("onInactiveTransportConnected"));
         return;
     }
 
@@ -231,7 +258,7 @@ void MessageRouter::onDisconnected(
     std::shared_ptr<TransportInterface> transport,
     ConnectionStatusObserverInterface::ChangedReason reason) {
     std::lock_guard<std::mutex> lock{m_connectionMutex};
-    ACSDK_INFO(LX("onDisconnected")
+    ACSDK_INFO(LX_WITH_AGENT_ID("onDisconnected")
                    .p("transport", transport)
                    .p("m_activeTransport", m_activeTransport)
                    .d(KEY_SIZEOF_TRANSPORTS, m_transports.size())
@@ -240,7 +267,9 @@ void MessageRouter::onDisconnected(
     for (auto it = m_transports.begin(); it != m_transports.end(); it++) {
         if (*it == transport) {
             m_transports.erase(it);
-            ACSDK_INFO(LX("releaseTransport").p("transport", transport).d(KEY_SIZEOF_TRANSPORTS, m_transports.size()));
+            ACSDK_INFO(LX_WITH_AGENT_ID("releaseTransport")
+                           .p("transport", transport)
+                           .d(KEY_SIZEOF_TRANSPORTS, m_transports.size()));
             safelyReleaseTransport(transport);
             break;
         }
@@ -263,13 +292,14 @@ void MessageRouter::onDisconnected(
                 return;
         }
 
-        ACSDK_ERROR(LX("unhandledConnectionStatus").d("connectionStatus", static_cast<int>(m_connectionStatus)));
+        ACSDK_ERROR(
+            LX_WITH_AGENT_ID("unhandledConnectionStatus").d("connectionStatus", static_cast<int>(m_connectionStatus)));
     }
 }
 
 void MessageRouter::onServerSideDisconnect(std::shared_ptr<TransportInterface> transport) {
     std::unique_lock<std::mutex> lock{m_connectionMutex};
-    ACSDK_INFO(LX("onServerSideDisconnect")
+    ACSDK_INFO(LX_WITH_AGENT_ID("onServerSideDisconnect")
                    .d("m_isEnabled", m_isEnabled)
                    .p("transport", transport)
                    .p("m_activeTransport", m_activeTransport));
@@ -297,11 +327,11 @@ void MessageRouter::setObserver(std::shared_ptr<MessageRouterObserverInterface>
 void MessageRouter::setConnectionStatusLocked(
     const ConnectionStatusObserverInterface::Status status,
     const ConnectionStatusObserverInterface::ChangedReason reason) {
-    ACSDK_INFO(LX("setConnectionStatusLocked").d("status", status).d("reason", reason));
+    ACSDK_INFO(LX_WITH_AGENT_ID("setConnectionStatusLocked").d("status", status).d("reason", reason));
     if (status != m_connectionStatus) {
         m_connectionStatus = status;
         m_connectionReason = reason;
-        ACSDK_DEBUG(LX("connectionStatusChanged").d("reason", reason).d("newStatus", m_connectionStatus));
+        ACSDK_DEBUG(LX_WITH_AGENT_ID("connectionStatusChanged").d("reason", reason).d("newStatus", m_connectionStatus));
         notifyObserverOnConnectionStatusChanged(m_connectionStatus, reason);
     }
 }
@@ -315,10 +345,10 @@ void MessageRouter::notifyObserverOnConnectionStatusChanged(
             ConnectionStatusObserverInterface::ChangedReason::SERVER_SIDE_DISCONNECT == reason) {
             m_serverSideDisconnectNotificationPending = true;
             m_serverSideDisconnectTimer.start(m_serverSideReconnectGracePeriod, [this]() {
-                ACSDK_DEBUG0(LX("serverSideDisconectTimerPredicate"));
+                ACSDK_DEBUG0(LX_WITH_AGENT_ID("serverSideDisconectTimerPredicate"));
                 m_executor.submit([this]() {
                     ACSDK_DEBUG0(
-                        LX("serverSideDisconectTimerHandler")
+                        LX_WITH_AGENT_ID("serverSideDisconectTimerHandler")
                             .d("m_serverSideDisconnectNotificationPending", m_serverSideDisconnectNotificationPending));
                     if (m_serverSideDisconnectNotificationPending) {
                         handleNotifyObserverOnConnectionStatusChanged(
@@ -329,7 +359,7 @@ void MessageRouter::notifyObserverOnConnectionStatusChanged(
             });
         } else {
             if (m_serverSideDisconnectNotificationPending) {
-                ACSDK_DEBUG0(LX("NotificationOfServerSideDisconnectSuppressed"));
+                ACSDK_DEBUG0(LX_WITH_AGENT_ID("NotificationOfServerSideDisconnectSuppressed"));
             }
             m_serverSideDisconnectTimer.stop();
             handleNotifyObserverOnConnectionStatusChanged(status, reason);
@@ -357,7 +387,7 @@ void MessageRouter::notifyObserverOnReceive(const std::string& contextId, const
     auto task = [this, contextId, message]() {
         auto temp = getObserver();
         if (temp) {
-            temp->receive(contextId, message);
+            temp->receive(m_agentId, contextId, message);
         }
     };
     m_executor.submit(task);
@@ -365,30 +395,39 @@ void MessageRouter::notifyObserverOnReceive(const std::string& contextId, const
 
 void MessageRouter::createActiveTransportLocked() {
     auto transport = m_transportFactory->createTransport(
-        m_authDelegate, m_attachmentManager, m_avsGateway, shared_from_this(), shared_from_this(), m_requestQueue);
-    ACSDK_INFO(
-        LX("createActiveTransportLocked").p("transport", transport).d(KEY_SIZEOF_TRANSPORTS, m_transports.size()));
+        m_agentId,
+        m_authDelegate,
+        m_attachmentManager,
+        m_avsGateway,
+        shared_from_this(),
+        shared_from_this(),
+        m_requestQueue);
+    ACSDK_INFO(LX_WITH_AGENT_ID("createActiveTransportLocked")
+                   .p("transport", transport)
+                   .d(KEY_SIZEOF_TRANSPORTS, m_transports.size()));
     if (transport && transport->connect()) {
         m_transports.push_back(transport);
         m_activeTransport = transport;
-        ACSDK_INFO(LX("setAsActiveTransport").p("transport", transport).d(KEY_SIZEOF_TRANSPORTS, m_transports.size()));
+        ACSDK_INFO(LX_WITH_AGENT_ID("setAsActiveTransport")
+                       .p("transport", transport)
+                       .d(KEY_SIZEOF_TRANSPORTS, m_transports.size()));
         if (m_transports.size() > 2) {
-            ACSDK_WARN(LX("tooManyTransports").d(KEY_SIZEOF_TRANSPORTS, m_transports.size()));
+            ACSDK_WARN(LX_WITH_AGENT_ID("tooManyTransports").d(KEY_SIZEOF_TRANSPORTS, m_transports.size()));
         }
     } else {
         safelyResetActiveTransportLocked();
         setConnectionStatusLocked(
             ConnectionStatusObserverInterface::Status::DISCONNECTED,
             ConnectionStatusObserverInterface::ChangedReason::INTERNAL_ERROR);
-        ACSDK_ERROR(
-            LX("createActiveTransportLockedFailed").d("reason", transport ? "internalError" : "createTransportFailed"));
+        ACSDK_ERROR(LX_WITH_AGENT_ID("createActiveTransportLockedFailed")
+                        .d("reason", transport ? "internalError" : "createTransportFailed"));
     }
 }
 
 void MessageRouter::disconnectAllTransportsLocked(
     std::unique_lock<std::mutex>& lock,
     const ConnectionStatusObserverInterface::ChangedReason reason) {
-    ACSDK_INFO(LX("disconnectAllTransportsLocked")
+    ACSDK_INFO(LX_WITH_AGENT_ID("disconnectAllTransportsLocked")
                    .d("reason", reason)
                    .d(KEY_SIZEOF_TRANSPORTS, m_transports.size())
                    .p("m_activeTransport", m_activeTransport));
@@ -403,7 +442,7 @@ void MessageRouter::disconnectAllTransportsLocked(
 
     lock.unlock();
     for (auto transport : movedTransports) {
-        ACSDK_INFO(LX("disconnectAllTransportsLocked").p("transport", transport));
+        ACSDK_INFO(LX_WITH_AGENT_ID("disconnectAllTransportsLocked").p("transport", transport));
         transport->shutdown();
     }
     lock.lock();
@@ -417,10 +456,11 @@ std::shared_ptr<MessageRouterObserverInterface> MessageRouter::getObserver() {
 void MessageRouter::safelyResetActiveTransportLocked() {
     if (m_activeTransport) {
         if (std::find(m_transports.begin(), m_transports.end(), m_activeTransport) == m_transports.end()) {
-            ACSDK_ERROR(LX("safelyResetActiveTransportLockedError").d("reason", "activeTransportNotInTransports)"));
+            ACSDK_ERROR(LX_WITH_AGENT_ID("safelyResetActiveTransportLockedError")
+                            .d("reason", "activeTransportNotInTransports)"));
             safelyReleaseTransport(m_activeTransport);
         }
-        ACSDK_INFO(LX("clearActiveTransport").p("m_activeTransport", m_activeTransport));
+        ACSDK_INFO(LX_WITH_AGENT_ID("clearActiveTransport").p("m_activeTransport", m_activeTransport));
         m_activeTransport.reset();
     }
 }
diff --git a/ACL/test/AVSConnectionManagerTest.cpp b/ACL/test/AVSConnectionManagerTest.cpp
index 897ed35e..5c50c2e4 100644
--- a/ACL/test/AVSConnectionManagerTest.cpp
+++ b/ACL/test/AVSConnectionManagerTest.cpp
@@ -36,7 +36,9 @@ class MockMessageObserver : public MessageObserverInterface {
 public:
     MockMessageObserver() {
     }
-    MOCK_METHOD2(receive, void(const std::string& contextId, const std::string& message));
+    MOCK_METHOD3(
+        receive,
+        void(avsCommon::avs::AgentId::IdType agentId, const std::string& contextId, const std::string& message));
 };
 
 /// This class allows us to test ConnectionStatusObserver interaction
diff --git a/ACL/test/Transport/HTTP2TransportTest.cpp b/ACL/test/Transport/HTTP2TransportTest.cpp
index f8be3dcc..4aa4b3d0 100644
--- a/ACL/test/Transport/HTTP2TransportTest.cpp
+++ b/ACL/test/Transport/HTTP2TransportTest.cpp
@@ -256,6 +256,7 @@ void HTTP2TransportTest::SetUp() {
     HTTP2Transport::Configuration cfg;
     m_synchronizedMessageRequestQueue = std::make_shared<SynchronizedMessageRequestQueue>();
     m_http2Transport = HTTP2Transport::create(
+        avsCommon::avs::AgentId::getAlexaAgentId(),
         m_mockAuthDelegate,
         TEST_AVS_GATEWAY_STRING,
         m_mockHttp2Connection,
@@ -1155,6 +1156,7 @@ TEST_F(HTTP2TransportTest, testTimer_networkInactivityPingRequest) {
     HTTP2Transport::Configuration cfg;
     cfg.inactivityTimeout = testInactivityTimeout;
     m_http2Transport = HTTP2Transport::create(
+        avsCommon::avs::AgentId::getAlexaAgentId(),
         m_mockAuthDelegate,
         TEST_AVS_GATEWAY_STRING,
         m_mockHttp2Connection,
@@ -1203,6 +1205,7 @@ TEST_F(HTTP2TransportTest, testSlow_tearDownPingTimeout) {
     HTTP2Transport::Configuration cfg;
     cfg.inactivityTimeout = testInactivityTimeout;
     m_http2Transport = HTTP2Transport::create(
+        avsCommon::avs::AgentId::getAlexaAgentId(),
         m_mockAuthDelegate,
         TEST_AVS_GATEWAY_STRING,
         m_mockHttp2Connection,
@@ -1248,6 +1251,7 @@ TEST_F(HTTP2TransportTest, testSlow_tearDownPingFailure) {
     HTTP2Transport::Configuration cfg;
     cfg.inactivityTimeout = testInactivityTimeout;
     m_http2Transport = HTTP2Transport::create(
+        avsCommon::avs::AgentId::getAlexaAgentId(),
         m_mockAuthDelegate,
         TEST_AVS_GATEWAY_STRING,
         m_mockHttp2Connection,
diff --git a/ACL/test/Transport/MessageRouterTest.cpp b/ACL/test/Transport/MessageRouterTest.cpp
index 7cd35bb7..15fba6b3 100644
--- a/ACL/test/Transport/MessageRouterTest.cpp
+++ b/ACL/test/Transport/MessageRouterTest.cpp
@@ -299,6 +299,7 @@ TEST_F(MessageRouterTest, test_onReceive) {
     m_router->consumeMessage(CONTEXT_ID, MESSAGE);
     waitOnMessageRouter(SHORT_TIMEOUT_MS);
     ASSERT_TRUE(m_mockMessageRouterObserver->wasNotifiedOfReceive());
+    ASSERT_EQ(ALEXA_AGENT_ID, m_mockMessageRouterObserver->getAgentId());
     ASSERT_EQ(CONTEXT_ID, m_mockMessageRouterObserver->getAttachmentContextId());
     ASSERT_EQ(MESSAGE, m_mockMessageRouterObserver->getLatestMessage());
 }
diff --git a/ACL/test/Transport/MessageRouterTest.h b/ACL/test/Transport/MessageRouterTest.h
index 5bce3396..a7f13249 100644
--- a/ACL/test/Transport/MessageRouterTest.h
+++ b/ACL/test/Transport/MessageRouterTest.h
@@ -21,6 +21,7 @@
 #include <sstream>
 #include <string>
 
+#include "AVSCommon/AVS/AgentId.h"
 #include "AVSCommon/AVS/Attachment/AttachmentManager.h"
 #include "AVSCommon/Utils/Threading/Executor.h"
 #include "AVSCommon/Utils/Memory/Memory.h"
@@ -103,6 +104,16 @@ private:
         std::shared_ptr<SynchronizedMessageRequestQueue> sharedMessageRequestQueue) override {
         return m_mockTransport;
     }
+    std::shared_ptr<TransportInterface> createTransport(
+        avsCommon::avs::AgentId::IdType agentId,
+        std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface> authDelegate,
+        std::shared_ptr<AttachmentManagerInterface> attachmentManager,
+        const std::string& avsGateway,
+        std::shared_ptr<MessageConsumerInterface> messageConsumerInterface,
+        std::shared_ptr<TransportObserverInterface> transportObserverInterface,
+        std::shared_ptr<SynchronizedMessageRequestQueue> sharedMessageRequestQueue) override {
+        return m_mockTransport;
+    }
 
     std::shared_ptr<MockTransport> m_mockTransport;
 };
@@ -161,6 +172,7 @@ public:
     static const int MESSAGE_LENGTH;
     static const std::chrono::milliseconds SHORT_TIMEOUT_MS;
     static const std::string CONTEXT_ID;
+    static const avsCommon::avs::AgentId::IdType ALEXA_AGENT_ID;
 
     std::shared_ptr<MockMessageRouterObserver> m_mockMessageRouterObserver;
     std::shared_ptr<MockAuthDelegate> m_mockAuthDelegate;
@@ -176,6 +188,7 @@ const std::string MessageRouterTest::MESSAGE = "123456789";
 const int MessageRouterTest::MESSAGE_LENGTH = 10;
 const std::chrono::milliseconds MessageRouterTest::SHORT_TIMEOUT_MS = std::chrono::milliseconds(1000);
 const std::string MessageRouterTest::CONTEXT_ID = "contextIdString";
+const avsCommon::avs::AgentId::IdType MessageRouterTest::ALEXA_AGENT_ID = avsCommon::avs::AgentId::getAlexaAgentId();
 
 }  // namespace test
 }  // namespace acl
diff --git a/ACL/test/Transport/MockAuthDelegate.h b/ACL/test/Transport/MockAuthDelegate.h
index 4abdd12c..ef5e23fe 100644
--- a/ACL/test/Transport/MockAuthDelegate.h
+++ b/ACL/test/Transport/MockAuthDelegate.h
@@ -43,7 +43,7 @@ public:
      * Set the token string.
      * @param authToken The string to be returned when @c getAuthToken() is called.
      */
-    void setAuthToken(std::string authToken);
+    void setAuthToken(const std::string& authToken);
 
 private:
     /// Holds the token string to be returned when @c getAuthToken() is called.
@@ -53,7 +53,7 @@ private:
 inline std::string MockAuthDelegate::getAuthToken() {
     return m_authToken;
 }
-inline void MockAuthDelegate::setAuthToken(std::string authToken) {
+inline void MockAuthDelegate::setAuthToken(const std::string& authToken) {
     m_authToken = authToken;
 }
 
diff --git a/ACL/test/Transport/MockMessageRouterObserver.h b/ACL/test/Transport/MockMessageRouterObserver.h
index 8c0bc105..44cf0716 100644
--- a/ACL/test/Transport/MockMessageRouterObserver.h
+++ b/ACL/test/Transport/MockMessageRouterObserver.h
@@ -18,6 +18,8 @@
 
 #include "ACL/Transport/MessageRouterObserverInterface.h"
 
+#include <AVSCommon/AVS/AgentId.h>
+
 #include <gmock/gmock.h>
 
 #include <memory>
@@ -30,6 +32,12 @@ namespace test {
 // Cannot actually mock this class, since it is used exclusively through friend relationship
 class MockMessageRouterObserver : public MessageRouterObserverInterface {
 public:
+    // unused but if no constructor cppcheck fails
+    MockMessageRouterObserver() {
+        m_notifiedOfReceive = false;
+        m_notifiedOfStatusChanged = false;
+    }
+
     void reset() {
         std::lock_guard<std::mutex> lock(m_mutex);
         m_notifiedOfReceive = false;
@@ -77,6 +85,11 @@ public:
         return m_attachmentContextId;
     }
 
+    avsCommon::avs::AgentId::IdType getAgentId() {
+        std::lock_guard<std::mutex> lock(m_mutex);
+        return m_agentId;
+    }
+
 private:
     void onConnectionStatusChanged(
         const avsCommon::sdkInterfaces::ConnectionStatusObserverInterface::Status status,
@@ -96,9 +109,11 @@ private:
         m_cv.notify_all();
     }
 
-    void receive(const std::string& contextId, const std::string& message) override {
+    void receive(avsCommon::avs::AgentId::IdType agentId, const std::string& contextId, const std::string& message)
+        override {
         std::lock_guard<std::mutex> lock(m_mutex);
         m_notifiedOfReceive = true;
+        m_agentId = agentId;
         m_attachmentContextId = contextId;
         m_message = message;
     }
@@ -126,6 +141,9 @@ private:
 
     /// Whether a receove was observed.
     bool m_notifiedOfReceive;
+
+    /// Last observed agentId
+    avsCommon::avs::AgentId::IdType m_agentId;
 };
 
 }  // namespace test
diff --git a/ADSL/include/ADSL/ADSLComponent.h b/ADSL/include/ADSL/ADSLComponent.h
index 61f3d809..a13e0d91 100644
--- a/ADSL/include/ADSL/ADSLComponent.h
+++ b/ADSL/include/ADSL/ADSLComponent.h
@@ -18,6 +18,7 @@
 
 #include <memory>
 
+#include <acsdk/MultiAgentInterface/AgentManagerInterface.h>
 #include <acsdkManufactory/Component.h>
 #include <acsdkManufactory/Import.h>
 #include <acsdkShutdownManagerInterfaces/ShutdownNotifierInterface.h>
@@ -35,7 +36,8 @@ using ADSLComponent = acsdkManufactory::Component<
     std::shared_ptr<avsCommon::sdkInterfaces::DirectiveSequencerInterface>,
     acsdkManufactory::Import<std::shared_ptr<acsdkShutdownManagerInterfaces::ShutdownNotifierInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>>,
-    acsdkManufactory::Import<std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>>>;
+    acsdkManufactory::Import<std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>>,
+    acsdkManufactory::Import<std::shared_ptr<multiAgentInterface::AgentManagerInterface>>>;
 
 /**
  * Creates an manufactory component that exports a shared pointer to @c DirectiveSequenceInterface.
diff --git a/ADSL/include/ADSL/DirectiveProcessor.h b/ADSL/include/ADSL/DirectiveProcessor.h
index 7b97895b..4531329d 100644
--- a/ADSL/include/ADSL/DirectiveProcessor.h
+++ b/ADSL/include/ADSL/DirectiveProcessor.h
@@ -27,6 +27,8 @@
 #include <thread>
 #include <unordered_map>
 
+#include <acsdk/MultiAgentInterface/Observer/AgentEnablementObserverInterface.h>
+#include <AVSCommon/AVS/AgentId.h>
 #include <AVSCommon/AVS/AVSDirective.h>
 #include <AVSCommon/SDKInterfaces/DirectiveHandlerInterface.h>
 #include <AVSCommon/Utils/Threading/ConditionVariableWrapper.h>
@@ -62,7 +64,7 @@ namespace adsl {
  * invoked, the @c AVSDirective is popped from the front of the queue, and processing of queued @c AVSDirective's
  * continues.
  */
-class DirectiveProcessor {
+class DirectiveProcessor : public multiAgentInterface::observer::AgentEnablementObserverInterface {
 public:
     /**
      * Constructor.
@@ -119,6 +121,12 @@ public:
      */
     bool enable();
 
+    /// @name AgentEnablementObserverInterface Functions
+    /// @{
+    void onEnabled(avsCommon::avs::AgentId::IdType id) override;
+    void onDisabled(avsCommon::avs::AgentId::IdType id) override;
+    /// @}
+
 private:
     /**
      * Handle used to identify @c DirectiveProcessor instances referenced by @c DirectiveHandlerResult.
@@ -232,6 +240,14 @@ private:
      */
     void scrubDialogRequestIdLocked(const std::string& dialogRequestId);
 
+    /**
+     * Cancel the processing any @c AVSDirective with the specified agentId.
+     * @note This method must only be called by threads that have acquired @c m_mutex.
+     *
+     * @param agentId The agentId to scrub from processing.
+     */
+    void scrubAgentIdLocked(avsCommon::avs::AgentId::IdType agentId);
+
     /**
      * Move all the directives being handled or queued for handling to @c m_cancelingQueue. Also reset the
      * current @c dialogRequestId.
@@ -343,6 +359,9 @@ private:
 
     /// The @c PowerResource associated with this thread.
     std::shared_ptr<avsCommon::utils::power::PowerResource> m_powerResource;
+
+    /// Set of agents that has been enabled
+    std::set<avsCommon::avs::AgentId::IdType> m_enabledAgents;
 };
 
 }  // namespace adsl
diff --git a/ADSL/include/ADSL/DirectiveSequencer.h b/ADSL/include/ADSL/DirectiveSequencer.h
index 62feda49..a916bc79 100644
--- a/ADSL/include/ADSL/DirectiveSequencer.h
+++ b/ADSL/include/ADSL/DirectiveSequencer.h
@@ -22,6 +22,7 @@
 #include <mutex>
 #include <thread>
 
+#include <acsdk/MultiAgentInterface/AgentManagerInterface.h>
 #include <acsdkShutdownManagerInterfaces/ShutdownNotifierInterface.h>
 #include <AVSCommon/SDKInterfaces/ExceptionEncounteredSenderInterface.h>
 #include <AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h>
@@ -46,12 +47,14 @@ public:
      * ExceptionEncountered messages to AVS for directives that are not handled.
      * @param shutdownNotifier The object with which to register for a notification when it is time to shut down.
      * @param metricRecorder The metric recorder.
+     * @param agentManager The @c AgentManager for getting agent specific information.
      * @return Returns a new DirectiveSequencer, or nullptr if the operation failed.
      */
     static std::shared_ptr<DirectiveSequencerInterface> createDirectiveSequencerInterface(
-        std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
-        std::shared_ptr<acsdkShutdownManagerInterfaces::ShutdownNotifierInterface> shutdownNotifier,
-        std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder);
+        const std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>& exceptionSender,
+        const std::shared_ptr<acsdkShutdownManagerInterfaces::ShutdownNotifierInterface>& shutdownNotifier,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
+        const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager);
 
     /**
      * Create a DirectiveSequencer.
@@ -60,11 +63,13 @@ public:
      * @param exceptionSender An instance of the @c ExceptionEncounteredSenderInterface used to send
      * ExceptionEncountered messages to AVS for directives that are not handled.
      * @param metricRecorder The metric recorder.
+     * @param agentManager The @c AgentManager for getting agent specific information.
      * @return Returns a new DirectiveSequencer, or nullptr if the operation failed.
      */
     static std::unique_ptr<DirectiveSequencerInterface> create(
-        std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
-        std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder = nullptr);
+        const std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>& exceptionSender,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder = nullptr,
+        const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager = nullptr);
 
     bool addDirectiveHandler(std::shared_ptr<avsCommon::sdkInterfaces::DirectiveHandlerInterface> handler) override;
 
@@ -86,10 +91,12 @@ private:
      * @param exceptionSender An instance of the @c ExceptionEncounteredSenderInterface used to send
      * ExceptionEncountered messages to AVS for directives that are not handled.
      * @param metricRecorder The metric recorder.
+     * @param agentManager The @c AgentManager for getting agent specific information.
      */
     DirectiveSequencer(
-        std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
-        std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder);
+        const std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>& exceptionSender,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
+        const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager);
 
     void doShutdown() override;
 
diff --git a/ADSL/include/ADSL/MessageInterpreter.h b/ADSL/include/ADSL/MessageInterpreter.h
index 67713aa3..709b9296 100644
--- a/ADSL/include/ADSL/MessageInterpreter.h
+++ b/ADSL/include/ADSL/MessageInterpreter.h
@@ -18,6 +18,7 @@
 
 #include <memory>
 
+#include <AVSCommon/AVS/AgentId.h>
 #include <AVSCommon/SDKInterfaces/ExceptionEncounteredSenderInterface.h>
 #include <AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h>
 #include <AVSCommon/SDKInterfaces/MessageObserverInterface.h>
@@ -48,7 +49,11 @@ public:
         std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface> attachmentManager,
         std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder = nullptr);
 
-    void receive(const std::string& contextId, const std::string& message) override;
+    /// @name MessageObserverInterface Functions
+    /// @{
+    void receive(avsCommon::avs::AgentId::IdType agentId, const std::string& contextId, const std::string& message)
+        override;
+    /// @}
 
 private:
     /// Object that manages sending exceptions encountered messages to AVS.
diff --git a/ADSL/src/CMakeLists.txt b/ADSL/src/CMakeLists.txt
index 6604e59a..350db3a0 100644
--- a/ADSL/src/CMakeLists.txt
+++ b/ADSL/src/CMakeLists.txt
@@ -12,13 +12,15 @@ add_library(ADSL
 
 target_include_directories(ADSL PUBLIC
         "${ADSL_SOURCE_DIR}/include"
-        "${AVSCommon_INCLUDE_DIRS}")
+        "${AVSCommon_INCLUDE_DIRS}"
+        "${MultiAgentInterface_INCLUDE_DIRS}")
 
 target_link_libraries(ADSL
         ${CMAKE_THREAD_LIBS_INIT}
         AVSCommon
         acsdkManufactory
-        acsdkShutdownManagerInterfaces)
+        acsdkShutdownManagerInterfaces
+        MultiAgentInterface)
 
 # install target
 asdk_install()
\ No newline at end of file
diff --git a/ADSL/src/DirectiveProcessor.cpp b/ADSL/src/DirectiveProcessor.cpp
index 3ca3dd2c..4fa9a0ee 100644
--- a/ADSL/src/DirectiveProcessor.cpp
+++ b/ADSL/src/DirectiveProcessor.cpp
@@ -103,6 +103,17 @@ bool DirectiveProcessor::onDirective(std::shared_ptr<AVSDirective> directive) {
         return true;
     }
 
+    if (m_enabledAgents.end() == m_enabledAgents.find(directive->getAgentId())) {
+        ACSDK_INFO(LX("onDirective")
+                       .d("messageId", directive->getMessageId())
+                       .d("action", "dropped")
+                       .d("reason", "agentIsDisabled")
+                       .d("namespace", directive->getNamespace())
+                       .d("name", directive->getName())
+                       .d("agentId", directive->getAgentId()));
+        return false;
+    }
+
     auto policy = m_directiveRouter->getPolicy(directive);
 
     m_directiveBeingPreHandled = directive;
@@ -159,6 +170,17 @@ bool DirectiveProcessor::enable() {
     return m_isEnabled;
 }
 
+void DirectiveProcessor::onEnabled(avsCommon::avs::AgentId::IdType id) {
+    std::lock_guard<std::mutex> lock{m_mutex};
+    m_enabledAgents.insert(id);
+}
+
+void DirectiveProcessor::onDisabled(avsCommon::avs::AgentId::IdType id) {
+    std::lock_guard<std::mutex> lock{m_mutex};
+    m_enabledAgents.erase(id);
+    scrubAgentIdLocked(id);
+}
+
 DirectiveProcessor::DirectiveHandlerResult::DirectiveHandlerResult(
     DirectiveProcessor::ProcessorHandle processorHandle,
     std::shared_ptr<AVSDirective> directive) :
@@ -502,6 +524,55 @@ void DirectiveProcessor::scrubDialogRequestIdLocked(const std::string& dialogReq
     }
 }
 
+void DirectiveProcessor::scrubAgentIdLocked(avsCommon::avs::AgentId::IdType agentId) {
+    ACSDK_DEBUG(LX("scrubAgentIdLocked").d("agentId", agentId));
+
+    bool changed = false;
+
+    // If a matching directive is in the midst of a preHandleDirective() call (i.e. before the
+    // directive is added to the m_handlingQueue) queue it for canceling instead.
+    if (m_directiveBeingPreHandled) {
+        auto id = m_directiveBeingPreHandled->getAgentId();
+        if (id == agentId) {
+            m_cancelingQueue.push_back(m_directiveBeingPreHandled);
+            m_directiveBeingPreHandled.reset();
+            changed = true;
+        }
+    }
+
+    /*
+     * If a matching directive is in the midst of a handleDirective() call or a blocking directive which
+     * hasn't been completed, reset m_directivesBeinHandle so we won't block processing subsequent directives.
+     * This directive is moved to m_cancelingQueue, below.
+     */
+    auto freed = clearDirectiveBeingHandledLocked(
+        [agentId](const std::shared_ptr<AVSDirective>& directive) { return directive->getAgentId() == agentId; });
+
+    if (!freed.empty()) {
+        m_cancelingQueue.insert(m_cancelingQueue.end(), freed.begin(), freed.end());
+        changed = true;
+    }
+
+    // Filter matching directives from m_handlingQueue and put them in m_cancelingQueue.
+    std::deque<DirectiveAndPolicy> tempDeque;
+    for (const auto& directiveAndPolicy : m_handlingQueue) {
+        auto id = (directiveAndPolicy.first)->getAgentId();
+        if (id == agentId) {
+            m_cancelingQueue.push_back(directiveAndPolicy.first);
+            changed = true;
+        } else {
+            tempDeque.push_back(directiveAndPolicy);
+        }
+    }
+    std::swap(tempDeque, m_handlingQueue);
+
+    // If there were any changes, wake up the processing loop.
+    if (changed) {
+        ACSDK_DEBUG9(LX("notifyingProcessingLoop").d("size:", m_cancelingQueue.size()));
+        m_wakeProcessingLoop.notifyOne();
+    }
+}
+
 void DirectiveProcessor::queueAllDirectivesForCancellationLocked() {
     ACSDK_DEBUG9(LX("queueAllDirectivesForCancellationLocked"));
 
diff --git a/ADSL/src/DirectiveRouter.cpp b/ADSL/src/DirectiveRouter.cpp
index 9cd5f520..9ba53b8b 100644
--- a/ADSL/src/DirectiveRouter.cpp
+++ b/ADSL/src/DirectiveRouter.cpp
@@ -61,6 +61,7 @@ void DirectiveRouter::submitMetric(
     MetricEventBuilder& metricEventBuilder,
     const std::shared_ptr<AVSDirective>& directive) {
     if (directive) {
+        metricEventBuilder.setMetricContext(MetricContext{directive->getAgentId()});
         metricEventBuilder.addDataPoint(
             DataPointStringBuilder{}.setName("HTTP2_STREAM").setValue(directive->getAttachmentContextId()).build());
         metricEventBuilder.addDataPoint(
@@ -120,6 +121,7 @@ bool DirectiveRouter::addDirectiveHandler(std::shared_ptr<DirectiveHandlerInterf
                          .d("action", "added")
                          .d("namespace", item.first.nameSpace)
                          .d("name", item.first.name)
+                         .d("agentId", item.first.getAgentId())
                          .d("handler", handler.get())
                          .d("policy", item.second));
     }
@@ -326,6 +328,7 @@ HandlerAndPolicy DirectiveRouter::getHandlerAndPolicyLocked(const std::shared_pt
     }
 
     // Look for a matching rule.
+    const auto agentId = directive->getAgentId();
     const auto nameSpace = directive->getNamespace();
     const auto name = directive->getName();
     const auto endpointId = directive->getEndpoint().hasValue() ? directive->getEndpoint().value().endpointId : "";
@@ -334,11 +337,17 @@ HandlerAndPolicy DirectiveRouter::getHandlerAndPolicyLocked(const std::shared_pt
         instance.set(directive->getHeader()->getInstance());
     }
 
-    std::vector<DirectiveRoutingRule> matchers = {routingRulePerDirective(endpointId, instance, nameSpace, name),
-                                                  routingRulePerNamespace(endpointId, instance, nameSpace),
-                                                  routingRulePerInstance(endpointId, instance),
-                                                  routingRulePerNamespaceAnyInstance(endpointId, nameSpace),
-                                                  routingRulePerEndpoint(endpointId)};
+    std::vector<DirectiveRoutingRule> matchers = {
+        routingRulePerDirective(agentId, endpointId, instance, nameSpace, name),
+        routingRulePerDirectiveAnyAgent(endpointId, instance, nameSpace, name),
+        routingRulePerNamespace(agentId, endpointId, instance, nameSpace),
+        routingRulePerNamespaceAnyAgent(endpointId, instance, nameSpace),
+        routingRulePerInstance(agentId, endpointId, instance),
+        routingRulePerInstanceAnyAgent(endpointId, instance),
+        routingRulePerNamespaceAnyInstance(agentId, endpointId, nameSpace),
+        routingRulePerNamespaceAnyInstanceAnyAgent(endpointId, nameSpace),
+        routingRulePerEndpoint(agentId, endpointId),
+        routingRulePerEndpointAnyAgent(endpointId)};
 
     for (const auto& matcher : matchers) {
         auto it = m_configuration.find(matcher);
diff --git a/ADSL/src/DirectiveSequencer.cpp b/ADSL/src/DirectiveSequencer.cpp
index 6ce71015..f2cc4928 100644
--- a/ADSL/src/DirectiveSequencer.cpp
+++ b/ADSL/src/DirectiveSequencer.cpp
@@ -17,6 +17,7 @@
 #include <iostream>
 #include <sstream>
 
+#include <AVSCommon/AVS/AgentId.h>
 #include <AVSCommon/AVS/ExceptionErrorType.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
 #include <AVSCommon/Utils/Metrics.h>
@@ -44,9 +45,10 @@ using namespace avsCommon::sdkInterfaces;
 using namespace avsCommon::utils;
 
 std::shared_ptr<DirectiveSequencerInterface> DirectiveSequencer::createDirectiveSequencerInterface(
-    std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
-    std::shared_ptr<acsdkShutdownManagerInterfaces::ShutdownNotifierInterface> shutdownNotifier,
-    std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder) {
+    const std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>& exceptionSender,
+    const std::shared_ptr<acsdkShutdownManagerInterfaces::ShutdownNotifierInterface>& shutdownNotifier,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
+    const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager) {
     ACSDK_DEBUG5(LX(__func__));
 
     if (!exceptionSender || !shutdownNotifier) {
@@ -56,20 +58,23 @@ std::shared_ptr<DirectiveSequencerInterface> DirectiveSequencer::createDirective
         return nullptr;
     }
 
-    auto sequencer = std::shared_ptr<DirectiveSequencer>(new DirectiveSequencer(exceptionSender, metricRecorder));
+    auto sequencer =
+        std::shared_ptr<DirectiveSequencer>(new DirectiveSequencer(exceptionSender, metricRecorder, agentManager));
     shutdownNotifier->addObserver(sequencer);
 
     return sequencer;
 }
 
 std::unique_ptr<DirectiveSequencerInterface> DirectiveSequencer::create(
-    std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
-    std::shared_ptr<metrics::MetricRecorderInterface> metricRecorder) {
+    const std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>& exceptionSender,
+    const std::shared_ptr<metrics::MetricRecorderInterface>& metricRecorder,
+    const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager) {
     if (!exceptionSender) {
         ACSDK_ERROR(LX("createFailed").d("reason", "nullptrExceptionSender"));
         return nullptr;
     }
-    return std::unique_ptr<DirectiveSequencerInterface>(new DirectiveSequencer(exceptionSender, metricRecorder));
+    return std::unique_ptr<DirectiveSequencerInterface>(
+        new DirectiveSequencer(exceptionSender, metricRecorder, agentManager));
 }
 
 bool DirectiveSequencer::addDirectiveHandler(std::shared_ptr<DirectiveHandlerInterface> handler) {
@@ -110,8 +115,9 @@ bool DirectiveSequencer::onDirective(std::shared_ptr<AVSDirective> directive) {
 }
 
 DirectiveSequencer::DirectiveSequencer(
-    std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
-    std::shared_ptr<metrics::MetricRecorderInterface> metricRecorder) :
+    const std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>& exceptionSender,
+    const std::shared_ptr<metrics::MetricRecorderInterface>& metricRecorder,
+    const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager) :
         DirectiveSequencerInterface{"DirectiveSequencer"},
         m_mutex{},
         m_exceptionSender{exceptionSender},
@@ -125,6 +131,12 @@ DirectiveSequencer::DirectiveSequencer(
 
     m_directiveProcessor = std::make_shared<DirectiveProcessor>(&m_directiveRouter);
     m_receivingThread = std::thread(&DirectiveSequencer::receivingLoop, this);
+
+    if (agentManager) {
+        agentManager->addAgentEnablementObserverInterface(avsCommon::avs::AgentId::AGENT_ID_ALL, m_directiveProcessor);
+    } else {
+        m_directiveProcessor->onEnabled(avsCommon::avs::AgentId::getAlexaAgentId());
+    }
 }
 
 void DirectiveSequencer::doShutdown() {
@@ -208,10 +220,13 @@ void DirectiveSequencer::receiveDirectiveLocked(std::unique_lock<std::mutex>& lo
     handled = m_directiveProcessor->onDirective(directive);
 #endif
 
-    if (!handled) {
+    if (!handled && avsCommon::avs::AgentId::getAlexaAgentId() == directive->getAgentId()) {
         ACSDK_INFO(LX("sendingExceptionEncountered").d("messageId", directive->getMessageId()));
         m_exceptionSender->sendExceptionEncountered(
-            directive->getUnparsedDirective(), ExceptionErrorType::UNSUPPORTED_OPERATION, "Unsupported operation");
+            directive->getAgentId(),
+            directive->getUnparsedDirective(),
+            ExceptionErrorType::UNSUPPORTED_OPERATION,
+            "Unsupported operation");
     }
     lock.lock();
 }
diff --git a/ADSL/src/MessageInterpreter.cpp b/ADSL/src/MessageInterpreter.cpp
index 0cfcf613..10a8ba06 100644
--- a/ADSL/src/MessageInterpreter.cpp
+++ b/ADSL/src/MessageInterpreter.cpp
@@ -59,8 +59,11 @@ MessageInterpreter::MessageInterpreter(
         m_metricRecorder{metricRecorder} {
 }
 
-void MessageInterpreter::receive(const std::string& contextId, const std::string& message) {
-    auto createResult = AVSDirective::create(message, m_attachmentManager, contextId);
+void MessageInterpreter::receive(
+    avsCommon::avs::AgentId::IdType agentId,
+    const std::string& contextId,
+    const std::string& message) {
+    auto createResult = AVSDirective::create(agentId, message, m_attachmentManager, contextId);
     std::shared_ptr<AVSDirective> avsDirective{std::move(createResult.first)};
     if (!avsDirective) {
         if (m_exceptionEncounteredSender) {
@@ -68,7 +71,7 @@ void MessageInterpreter::receive(const std::string& contextId, const std::string
                 "Unable to parse Directive - JSON error:" + avsDirectiveParseStatusToString(createResult.second);
             ACSDK_ERROR(LX("receiveFailed").m(errorDescription));
             m_exceptionEncounteredSender->sendExceptionEncountered(
-                message, ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED, errorDescription);
+                agentId, message, ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED, errorDescription);
         } else {
             ACSDK_ERROR(LX("receiveFailed").m("unable to send AVS Exception due to nullptr sender."));
         }
@@ -78,6 +81,7 @@ void MessageInterpreter::receive(const std::string& contextId, const std::string
 
     auto metricEvent =
         MetricEventBuilder{}
+            .setMetricContext(MetricContext{agentId})
             .setActivityName(PARSE_COMPLETE_ACTIVITY_NAME)
             .addDataPoint(DataPointCounterBuilder{}.setName(PARSE_COMPLETE).increment(1).build())
             .addDataPoint(DataPointStringBuilder{}
diff --git a/ADSL/test/CMakeLists.txt b/ADSL/test/CMakeLists.txt
index 8aa02a17..7bf18bed 100644
--- a/ADSL/test/CMakeLists.txt
+++ b/ADSL/test/CMakeLists.txt
@@ -4,5 +4,5 @@ add_subdirectory("common")
 
 set(INCLUDE_PATH "${AVSCommon_SOURCE_DIR}/SDKInterfaces/test")
 
-set(ADSL_TEST_LIBS ADSL ADSLTestCommon ShutdownManagerTestLib)
+set(ADSL_TEST_LIBS ADSL ADSLTestCommon ShutdownManagerTestLib MultiAgentInterfaceTestUtils)
 discover_unit_tests("${INCLUDE_PATH}" "${ADSL_TEST_LIBS}")
diff --git a/ADSL/test/DirectiveProcessorTest.cpp b/ADSL/test/DirectiveProcessorTest.cpp
index 8cd99676..5ddabe21 100644
--- a/ADSL/test/DirectiveProcessorTest.cpp
+++ b/ADSL/test/DirectiveProcessorTest.cpp
@@ -161,6 +161,7 @@ public:
 void DirectiveProcessorTest::SetUp() {
     m_router = std::make_shared<DirectiveRouter>();
     m_processor = std::make_shared<DirectiveProcessor>(m_router.get());
+    m_processor->onEnabled(avsCommon::avs::AgentId::getAlexaAgentId());
     m_attachmentManager = std::make_shared<AttachmentManager>(AttachmentManager::AttachmentType::IN_PROCESS);
 
     auto avsMessageHeader_0_0 =
@@ -382,6 +383,97 @@ TEST_F(DirectiveProcessorTest, test_addDirectiveAfterReEnabled) {
     ASSERT_TRUE(m_processor->onDirective(m_directive_0_0));
 }
 
+/**
+ * Register a long running and @c BLOCKING @c DirectiveHandler for one @c AVSDirective and a short
+ * running @c DirectiveHandler for two more @c AVSDirectives.  Send the long running @c AVSDirective
+ * followed by a short running one.  Wait until the long running @c AVSDirective has entered
+ * handleDirective() and the short running @c AVSDirective has entered preHandleDirective().
+ * then disable the ALEXA agent and send a final @c AVSDirective with the new
+ * @c dialogRequestId() for a different agent.  Expect the first two @c AVSDirectives to be cancelled and expect the
+ * final @c AVSDirective to be processed normally.
+ */
+TEST_F(DirectiveProcessorTest, test_disableAgentCancelsOutstandingDirectives) {
+    auto someOtherAgent = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+    DirectiveHandlerConfiguration longRunningHandlerConfig;
+    longRunningHandlerConfig[NamespaceAndName{NAMESPACE_AND_NAME_0_0}] =
+        BlockingPolicy(BlockingPolicy::MEDIUM_AUDIO, true);
+    auto longRunningHandler =
+        MockDirectiveHandler::create(longRunningHandlerConfig, MockDirectiveHandler::DEFAULT_DONE_TIMEOUT_MS);
+
+    DirectiveHandlerConfiguration handler1Config;
+    auto audioNonBlockingPolicy = BlockingPolicy(BlockingPolicy::MEDIUM_AUDIO, false);
+    handler1Config[NamespaceAndName{NAMESPACE_AND_NAME_0_1}] = audioNonBlockingPolicy;
+    auto handler1 = MockDirectiveHandler::create(handler1Config);
+
+    auto avsMessageHeader_1_0 =
+        std::make_shared<AVSMessageHeader>(NAMESPACE_AND_NAME_1_0, MESSAGE_ID_1_0, DIALOG_REQUEST_ID_1);
+    std::shared_ptr<AVSDirective> directive_1_0 = AVSDirective::create(
+        someOtherAgent,
+        UNPARSED_DIRECTIVE,
+        avsMessageHeader_1_0,
+        PAYLOAD_TEST,
+        m_attachmentManager,
+        TEST_ATTACHMENT_CONTEXT_ID);
+
+    DirectiveHandlerConfiguration handler2Config;
+    handler2Config[NamespaceAndName{NAMESPACE_AND_NAME_1_0, someOtherAgent}] = audioNonBlockingPolicy;
+    auto handler2 = MockDirectiveHandler::create(handler2Config);
+
+    ASSERT_TRUE(m_router->addDirectiveHandler(longRunningHandler));
+    ASSERT_TRUE(m_router->addDirectiveHandler(handler1));
+    ASSERT_TRUE(m_router->addDirectiveHandler(handler2));
+
+    EXPECT_CALL(*(longRunningHandler.get()), handleDirectiveImmediately(_)).Times(0);
+    EXPECT_CALL(*(longRunningHandler.get()), preHandleDirective(_, _)).Times(1);
+    EXPECT_CALL(*(longRunningHandler.get()), handleDirective(_)).Times(1);
+    EXPECT_CALL(*(longRunningHandler.get()), cancelDirective(_)).Times(1);
+
+    EXPECT_CALL(*(handler1.get()), handleDirectiveImmediately(_)).Times(0);
+    EXPECT_CALL(*(handler1.get()), preHandleDirective(m_directive_0_1, _)).Times(1);
+    EXPECT_CALL(*(handler1.get()), handleDirective(MESSAGE_ID_0_1)).Times(0);
+    EXPECT_CALL(*(handler1.get()), cancelDirective(_)).Times(1);
+
+    EXPECT_CALL(*(handler2.get()), handleDirectiveImmediately(_)).Times(0);
+    EXPECT_CALL(*(handler2.get()), preHandleDirective(directive_1_0, _)).Times(1);
+    EXPECT_CALL(*(handler2.get()), handleDirective(MESSAGE_ID_1_0)).Times(1);
+    EXPECT_CALL(*(handler2.get()), cancelDirective(_)).Times(0);
+
+    m_processor->onEnabled(someOtherAgent);
+    m_processor->setDialogRequestId(DIALOG_REQUEST_ID_0);
+    ASSERT_TRUE(m_processor->onDirective(m_directive_0_0));
+    ASSERT_TRUE(m_processor->onDirective(m_directive_0_1));
+    ASSERT_TRUE(longRunningHandler->waitUntilHandling());
+    ASSERT_TRUE(handler1->waitUntilPreHandling());
+    m_processor->onDisabled(avsCommon::avs::AgentId::getAlexaAgentId());
+    m_processor->setDialogRequestId(DIALOG_REQUEST_ID_1);
+    ASSERT_TRUE(m_processor->onDirective(directive_1_0));
+    ASSERT_TRUE(handler2->waitUntilCompleted());
+}
+
+/**
+ * Test if an agent is disabled, that the directive will be dropped.  And test that it can be processed again
+ * when it's enabled.
+ */
+TEST_F(DirectiveProcessorTest, test_addDirectiveAfterAgentDisabled) {
+    DirectiveHandlerConfiguration handlerConfig;
+    handlerConfig[NamespaceAndName{NAMESPACE_AND_NAME_0_0}] = BlockingPolicy(BlockingPolicy::MEDIUM_AUDIO, true);
+    auto handler = MockDirectiveHandler::create(handlerConfig);
+
+    EXPECT_CALL(*(handler.get()), preHandleDirective(m_directive_0_0, _)).Times(1);
+
+    ASSERT_TRUE(m_router->addDirectiveHandler(handler));
+
+    m_processor->setDialogRequestId(DIALOG_REQUEST_ID_0);
+
+    m_processor->onDisabled(avsCommon::avs::AgentId::getAlexaAgentId());
+    ASSERT_FALSE(m_processor->onDirective(m_directive_0_0));
+
+    m_processor->onEnabled(avsCommon::avs::AgentId::getAlexaAgentId());
+    ASSERT_TRUE(m_processor->onDirective(m_directive_0_0));
+
+    ASSERT_TRUE(handler->waitUntilCompleted());
+}
+
 /**
  * Verify that an @c AVSDirective using @c MEDIUMS_AUDIO_AND_VISUAL
  *  is blocking @c MEDIUM_AUDIO but not blocking @c MEDIUMS_NONE.
diff --git a/ADSL/test/DirectiveRouterTest.cpp b/ADSL/test/DirectiveRouterTest.cpp
index b6d8d69e..7bd08c64 100644
--- a/ADSL/test/DirectiveRouterTest.cpp
+++ b/ADSL/test/DirectiveRouterTest.cpp
@@ -442,7 +442,7 @@ TEST_F(DirectiveRouterTest, test_handlerMethodsCanRunConcurrently) {
  */
 TEST_F(DirectiveRouterTest, test_perDirectiveRuleMatching) {
     // Configure handler.
-    auto rule = routingRulePerDirective("endpointId", std::string("instance"), "namespace", "name");
+    auto rule = routingRulePerDirectiveAnyAgent("endpointId", std::string("instance"), "namespace", "name");
     DirectiveHandlerConfiguration handlerConfig;
     handlerConfig[rule] = BlockingPolicy(BlockingPolicy::MEDIUM_AUDIO, true);
     std::shared_ptr<MockDirectiveHandler> handler = MockDirectiveHandler::create(handlerConfig);
@@ -462,7 +462,7 @@ TEST_F(DirectiveRouterTest, test_perDirectiveRuleMatching) {
  */
 TEST_F(DirectiveRouterTest, test_perNamespaceRuleMatching) {
     // Configure handler.
-    auto rule = routingRulePerNamespace("endpointId", std::string("instance"), "namespace");
+    auto rule = routingRulePerNamespaceAnyAgent("endpointId", std::string("instance"), "namespace");
     DirectiveHandlerConfiguration handlerConfig;
     handlerConfig[rule] = BlockingPolicy(BlockingPolicy::MEDIUM_AUDIO, true);
     std::shared_ptr<MockDirectiveHandler> handler = MockDirectiveHandler::create(handlerConfig);
@@ -486,7 +486,7 @@ TEST_F(DirectiveRouterTest, test_perNamespaceRuleMatching) {
  */
 TEST_F(DirectiveRouterTest, test_perInstanceRuleMatching) {
     // Configure handler.
-    auto rule = routingRulePerInstance("endpointId", std::string("instance"));
+    auto rule = routingRulePerInstanceAnyAgent("endpointId", std::string("instance"));
     DirectiveHandlerConfiguration handlerConfig;
     handlerConfig[rule] = BlockingPolicy(BlockingPolicy::MEDIUM_AUDIO, true);
     std::shared_ptr<MockDirectiveHandler> handler = MockDirectiveHandler::create(handlerConfig);
@@ -512,7 +512,7 @@ TEST_F(DirectiveRouterTest, test_perInstanceRuleMatching) {
  */
 TEST_F(DirectiveRouterTest, test_perNamespaceAnyInstanceRuleMatching) {
     // Configure handler.
-    auto rule = routingRulePerNamespaceAnyInstance("endpointId", "nameSpace");
+    auto rule = routingRulePerNamespaceAnyInstanceAnyAgent("endpointId", "nameSpace");
     DirectiveHandlerConfiguration handlerConfig;
     handlerConfig[rule] = BlockingPolicy(BlockingPolicy::MEDIUM_AUDIO, true);
     std::shared_ptr<MockDirectiveHandler> handler = MockDirectiveHandler::create(handlerConfig);
@@ -538,7 +538,7 @@ TEST_F(DirectiveRouterTest, test_perNamespaceAnyInstanceRuleMatching) {
  */
 TEST_F(DirectiveRouterTest, test_perEndpointMatching) {
     // Configure handler.
-    auto rule = routingRulePerEndpoint("endpoint");
+    auto rule = routingRulePerEndpointAnyAgent("endpoint");
     DirectiveHandlerConfiguration handlerConfig;
     handlerConfig[rule] = BlockingPolicy(BlockingPolicy::MEDIUM_AUDIO, true);
     std::shared_ptr<MockDirectiveHandler> handler = MockDirectiveHandler::create(handlerConfig);
@@ -566,7 +566,7 @@ TEST_F(DirectiveRouterTest, test_perEndpointMatching) {
  */
 TEST_F(DirectiveRouterTest, test_addDirectiveHandlerWithInvalidRoutingRuleShouldFail) {
     // Configure handler with endpoint wildcard.
-    auto rule = routingRulePerEndpoint(WILDCARD);
+    auto rule = routingRulePerEndpointAnyAgent(WILDCARD);
     DirectiveHandlerConfiguration handlerConfig;
     handlerConfig[rule] = BlockingPolicy(BlockingPolicy::MEDIUM_AUDIO, true);
     std::shared_ptr<MockDirectiveHandler> handler = MockDirectiveHandler::create(handlerConfig);
diff --git a/ADSL/test/DirectiveSequencerTest.cpp b/ADSL/test/DirectiveSequencerTest.cpp
index b1f04faa..693f42a0 100644
--- a/ADSL/test/DirectiveSequencerTest.cpp
+++ b/ADSL/test/DirectiveSequencerTest.cpp
@@ -22,10 +22,13 @@
 #include <gtest/gtest.h>
 #include <gmock/gmock.h>
 
+#include <acsdk/MultiAgentInterface/MockAgentManager.h>
 #include <acsdkShutdownManagerInterfaces/MockShutdownNotifier.h>
+#include <AVSCommon/AVS/AgentId.h>
 #include <AVSCommon/AVS/Attachment/AttachmentManager.h>
 #include <AVSCommon/AVS/NamespaceAndName.h>
 #include <AVSCommon/SDKInterfaces/MockDirectiveHandlerResult.h>
+#include <AVSCommon/SDKInterfaces/MockExceptionEncounteredSender.h>
 
 #include "ADSL/DirectiveSequencer.h"
 #include "MockDirectiveHandler.h"
@@ -41,6 +44,8 @@ using namespace avsCommon;
 using namespace avsCommon::avs;
 using namespace avsCommon::avs::attachment;
 using namespace avsCommon::sdkInterfaces;
+using namespace avsCommon::sdkInterfaces::test;
+using namespace alexaClientSDK::multiAgentInterface;
 
 /// Long amount of time for handling a directive to allow other things to happen (we should not reach this).
 static const std::chrono::milliseconds LONG_HANDLING_TIME_MS(30000);
@@ -110,12 +115,20 @@ static const std::string DIALOG_REQUEST_ID_2("DialogRequestId_2");
 
 static const std::string TEST_ATTACHMENT_CONTEXT_ID("TEST_ATTACHMENT_CONTEXT_ID");
 
-/**
- * Mock ExceptionEncounteredSenderInterface implementation.
- */
-class MockExceptionEncounteredSender : public avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface {
+class SpecializedMockAgentManager : public MockAgentManager {
 public:
-    MOCK_METHOD3(sendExceptionEncountered, void(const std::string&, ExceptionErrorType, const std::string&));
+    void addAgentEnablementObserverInterface(
+        AgentId::IdType id,
+        const std::shared_ptr<observer::AgentEnablementObserverInterface>& observer) override {
+        m_observer = observer;
+    }
+
+    std::shared_ptr<observer::AgentEnablementObserverInterface> getObserver() {
+        return m_observer.lock();
+    }
+
+private:
+    std::weak_ptr<observer::AgentEnablementObserverInterface> m_observer;
 };
 
 /// DirectiveSequencerTest
@@ -154,20 +167,25 @@ public:
 
     /// AttachmentManager with which to create directives.
     std::shared_ptr<AttachmentManager> m_attachmentManager;
+
+    /// Mock AgentManager.
+    std::shared_ptr<SpecializedMockAgentManager> m_agentManager;
 };
 
 void DirectiveSequencerTest::SetUp() {
     DirectiveHandlerConfiguration config;
     config[NamespaceAndName{NAMESPACE_TEST, NAME_DONE}] = BlockingPolicy(BlockingPolicy::MEDIUM_AUDIO, true);
     m_doneHandler = MockDirectiveHandler::create(config, LONG_HANDLING_TIME_MS);
+    m_agentManager = std::make_shared<SpecializedMockAgentManager>();
     m_attachmentManager = std::make_shared<AttachmentManager>(AttachmentManager::AttachmentType::IN_PROCESS);
     m_exceptionEncounteredSender = std::make_shared<NiceMock<MockExceptionEncounteredSender>>();
     m_shutdownNotifier = std::make_shared<StrictMock<MockShutdownNotifier>>();
     EXPECT_CALL(*(m_shutdownNotifier.get()), addObserver(_));
     m_sequencer = DirectiveSequencer::createDirectiveSequencerInterface(
-        m_exceptionEncounteredSender, m_shutdownNotifier, nullptr);
+        m_exceptionEncounteredSender, m_shutdownNotifier, nullptr, m_agentManager);
     ASSERT_TRUE(m_sequencer);
     ASSERT_TRUE(m_sequencer->addDirectiveHandler(m_doneHandler));
+    m_agentManager->getObserver()->onEnabled(avsCommon::avs::AgentId::getAlexaAgentId());
 }
 
 void DirectiveSequencerTest::TearDown() {
@@ -205,7 +223,8 @@ TEST_F(DirectiveSequencerTest, test_createNullptrExceptionSender) {
  */
 TEST_F(DirectiveSequencerTest, test_createDirectiveSequencerInterfaceNullptrExceptionSender) {
     ASSERT_TRUE(m_sequencer);
-    auto sequencer = DirectiveSequencer::createDirectiveSequencerInterface(nullptr, m_shutdownNotifier, nullptr);
+    auto sequencer =
+        DirectiveSequencer::createDirectiveSequencerInterface(nullptr, m_shutdownNotifier, nullptr, nullptr);
     ASSERT_FALSE(sequencer);
 }
 
@@ -216,7 +235,7 @@ TEST_F(DirectiveSequencerTest, test_createDirectiveSequencerInterfaceNullptrExce
 TEST_F(DirectiveSequencerTest, test_createDirectiveSequencerInterfaceNullptrShutdownNotifier) {
     ASSERT_TRUE(m_sequencer);
     auto sequencer =
-        DirectiveSequencer::createDirectiveSequencerInterface(m_exceptionEncounteredSender, nullptr, nullptr);
+        DirectiveSequencer::createDirectiveSequencerInterface(m_exceptionEncounteredSender, nullptr, nullptr, nullptr);
     ASSERT_FALSE(sequencer);
 }
 
@@ -236,14 +255,28 @@ TEST_F(DirectiveSequencerTest, test_nullptrDirective) {
 
 /**
  * Exercise sending a @c AVSDirective for which no handler has been registered.  Expect that
- * m_exceptionEncounteredSender will receive a request to send the ExceptionEncountered message.
+ * m_exceptionEncounteredSender will receive a request to send the ExceptionEncountered message for ALEXA agent only.
  */
 TEST_F(DirectiveSequencerTest, test_unhandledDirective) {
     auto avsMessageHeader = std::make_shared<AVSMessageHeader>(NAMESPACE_SPEAKER, NAME_SET_VOLUME, MESSAGE_ID_0);
-    std::shared_ptr<AVSDirective> directive = AVSDirective::create(
+    std::shared_ptr<AVSDirective> directiveForAlexa = AVSDirective::create(
         UNPARSED_DIRECTIVE, avsMessageHeader, PAYLOAD_TEST, m_attachmentManager, TEST_ATTACHMENT_CONTEXT_ID);
-    EXPECT_CALL(*(m_exceptionEncounteredSender.get()), sendExceptionEncountered(_, _, _)).Times(1);
-    m_sequencer->onDirective(directive);
+    EXPECT_CALL(
+        *(m_exceptionEncounteredSender.get()),
+        sendExceptionEncountered(avsCommon::avs::AgentId::getAlexaAgentId(), _, _, _))
+        .Times(1);
+    m_sequencer->onDirective(directiveForAlexa);
+
+    const auto someOtherAgent = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+    std::shared_ptr<AVSDirective> directiveForSomeOtherAgent = AVSDirective::create(
+        someOtherAgent,
+        UNPARSED_DIRECTIVE,
+        avsMessageHeader,
+        PAYLOAD_TEST,
+        m_attachmentManager,
+        TEST_ATTACHMENT_CONTEXT_ID);
+    EXPECT_CALL(*(m_exceptionEncounteredSender.get()), sendExceptionEncountered(someOtherAgent, _, _, _)).Times(0);
+    m_sequencer->onDirective(directiveForSomeOtherAgent);
 }
 
 /**
@@ -287,6 +320,108 @@ TEST_F(DirectiveSequencerTest, test_handleImmediatelyHandler) {
     ASSERT_TRUE(handler->waitUntilHandling());
 }
 
+/**
+ * Test directive hander for different agents (i.e. ALEXA, some other agent, and all agents) and test if the handler
+ * will be called when the corresponding directive comes in.
+ */
+TEST_F(DirectiveSequencerTest, test_handlerForMultiAgents) {
+    const auto someOtherAgent1 = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+    const auto someOtherAgent2 = someOtherAgent1 + 1;
+
+    m_agentManager->getObserver()->onEnabled(someOtherAgent1);
+    m_agentManager->getObserver()->onEnabled(someOtherAgent2);
+
+    auto avsMessageHeader0 = std::make_shared<AVSMessageHeader>(NAMESPACE_TEST, NAME_HANDLE_IMMEDIATELY, MESSAGE_ID_0);
+    std::shared_ptr<AVSDirective> directiveForAlexa = AVSDirective::create(
+        avsCommon::avs::AgentId::getAlexaAgentId(),
+        UNPARSED_DIRECTIVE,
+        avsMessageHeader0,
+        PAYLOAD_TEST,
+        m_attachmentManager,
+        TEST_ATTACHMENT_CONTEXT_ID);
+
+    auto avsMessageHeader1 =
+        std::make_shared<AVSMessageHeader>(NAMESPACE_SPEAKER, NAME_HANDLE_IMMEDIATELY, MESSAGE_ID_1);
+    std::shared_ptr<AVSDirective> directiveForSomeOtherAgent1 = AVSDirective::create(
+        someOtherAgent1,
+        UNPARSED_DIRECTIVE,
+        avsMessageHeader1,
+        PAYLOAD_TEST,
+        m_attachmentManager,
+        TEST_ATTACHMENT_CONTEXT_ID);
+
+    auto avsMessageHeader2 =
+        std::make_shared<AVSMessageHeader>(NAMESPACE_AUDIO_PLAYER, NAME_HANDLE_IMMEDIATELY, MESSAGE_ID_2);
+    std::shared_ptr<AVSDirective> directiveForSomeOtherAgent2 = AVSDirective::create(
+        someOtherAgent2,
+        UNPARSED_DIRECTIVE,
+        avsMessageHeader2,
+        PAYLOAD_TEST,
+        m_attachmentManager,
+        TEST_ATTACHMENT_CONTEXT_ID);
+
+    DirectiveHandlerConfiguration configForAlexa;
+    configForAlexa[NamespaceAndName{
+        NAMESPACE_TEST, NAME_HANDLE_IMMEDIATELY, avsCommon::avs::AgentId::getAlexaAgentId()}] =
+        BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false);
+    auto handlerAlexa = MockDirectiveHandler::create(configForAlexa);
+    ASSERT_TRUE(m_sequencer->addDirectiveHandler(handlerAlexa));
+
+    DirectiveHandlerConfiguration configForSomeOtherAgent;
+    configForSomeOtherAgent[NamespaceAndName{NAMESPACE_SPEAKER, NAME_HANDLE_IMMEDIATELY, someOtherAgent1}] =
+        BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false);
+    auto handlerForSomeOtherAgent = MockDirectiveHandler::create(configForSomeOtherAgent);
+    ASSERT_TRUE(m_sequencer->addDirectiveHandler(handlerForSomeOtherAgent));
+
+    DirectiveHandlerConfiguration configForAllAgents;
+    configForAllAgents[NamespaceAndName{NAMESPACE_AUDIO_PLAYER, NAME_HANDLE_IMMEDIATELY, AgentId::AGENT_ID_ALL}] =
+        BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false);
+    auto handlerAllAgents = MockDirectiveHandler::create(configForAllAgents);
+    ASSERT_TRUE(m_sequencer->addDirectiveHandler(handlerAllAgents));
+
+    EXPECT_CALL(*(handlerAlexa.get()), preHandleDirective(_, _)).Times(1);
+    EXPECT_CALL(*(handlerAlexa.get()), handleDirective(_)).Times(1);
+    EXPECT_CALL(*(handlerForSomeOtherAgent.get()), preHandleDirective(_, _)).Times(1);
+    EXPECT_CALL(*(handlerForSomeOtherAgent.get()), handleDirective(_)).Times(1);
+    EXPECT_CALL(*(handlerAllAgents.get()), preHandleDirective(_, _)).Times(1);
+    EXPECT_CALL(*(handlerAllAgents.get()), handleDirective(_)).Times(1);
+    m_sequencer->onDirective(directiveForAlexa);
+    ASSERT_TRUE(handlerAlexa->waitUntilHandling());
+
+    m_sequencer->onDirective(directiveForSomeOtherAgent1);
+    ASSERT_TRUE(handlerForSomeOtherAgent->waitUntilHandling());
+
+    m_sequencer->onDirective(directiveForSomeOtherAgent2);
+    ASSERT_TRUE(handlerAllAgents->waitUntilHandling());
+}
+
+/**
+ * Test directive hander for different agents (i.e. ALEXA, some other agent, and all agents) and test if the handler
+ * will not be called when the corresponding directive comes in while the agent is disabled.
+ */
+TEST_F(DirectiveSequencerTest, test_handlerForMultiAgentsWithDisabledAgent) {
+    const auto someOtherAgent1 = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+
+    auto avsMessageHeader1 =
+        std::make_shared<AVSMessageHeader>(NAMESPACE_SPEAKER, NAME_HANDLE_IMMEDIATELY, MESSAGE_ID_1);
+    std::shared_ptr<AVSDirective> directiveForSomeOtherAgent1 = AVSDirective::create(
+        someOtherAgent1,
+        UNPARSED_DIRECTIVE,
+        avsMessageHeader1,
+        PAYLOAD_TEST,
+        m_attachmentManager,
+        TEST_ATTACHMENT_CONTEXT_ID);
+
+    DirectiveHandlerConfiguration configForSomeOtherAgent;
+    configForSomeOtherAgent[NamespaceAndName{NAMESPACE_SPEAKER, NAME_HANDLE_IMMEDIATELY, someOtherAgent1}] =
+        BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false);
+    auto handlerForSomeOtherAgent = MockDirectiveHandler::create(configForSomeOtherAgent);
+    ASSERT_TRUE(m_sequencer->addDirectiveHandler(handlerForSomeOtherAgent));
+
+    m_sequencer->onDirective(directiveForSomeOtherAgent1);
+    ASSERT_FALSE(handlerForSomeOtherAgent->waitUntilHandling(std::chrono::milliseconds(100)));
+}
+
 /**
  * Set handlers (NON_BLOCKING) for two namespace,name pairs.  Then remove one and change the other.  Send directives
  * for each of the NamespaceAndName values.  Expect that the directive with no mapping is not seen by a handler and
diff --git a/ADSL/test/MessageInterpreterTest.cpp b/ADSL/test/MessageInterpreterTest.cpp
index 43316f08..97a47f01 100644
--- a/ADSL/test/MessageInterpreterTest.cpp
+++ b/ADSL/test/MessageInterpreterTest.cpp
@@ -209,9 +209,9 @@ protected:
  * and passed to directive sequencer. ExceptionEncounteredEvent should be sent to AVS.
  */
 TEST_F(MessageIntepreterTest, test_messageIsInValidJSON) {
-    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _)).Times(1);
+    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _, _)).Times(1);
     EXPECT_CALL(*m_mockDirectiveSequencer, onDirective(_)).Times(0);
-    m_messageInterpreter->receive(TEST_ATTACHMENT_CONTEXT_ID, INVALID_JSON);
+    m_messageInterpreter->receive(avsCommon::avs::AgentId::getAlexaAgentId(), TEST_ATTACHMENT_CONTEXT_ID, INVALID_JSON);
 }
 
 /**
@@ -219,9 +219,10 @@ TEST_F(MessageIntepreterTest, test_messageIsInValidJSON) {
  * and passed to directive sequencer. ExceptionEncounteredEvent should be sent to AVS.
  */
 TEST_F(MessageIntepreterTest, test_messageHasInvalidDirectiveKey) {
-    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _)).Times(1);
+    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _, _)).Times(1);
     EXPECT_CALL(*m_mockDirectiveSequencer, onDirective(_)).Times(0);
-    m_messageInterpreter->receive(TEST_ATTACHMENT_CONTEXT_ID, DIRECTIVE_INVALID_DIRECTIVE_KEY);
+    m_messageInterpreter->receive(
+        avsCommon::avs::AgentId::getAlexaAgentId(), TEST_ATTACHMENT_CONTEXT_ID, DIRECTIVE_INVALID_DIRECTIVE_KEY);
 }
 
 /**
@@ -229,9 +230,10 @@ TEST_F(MessageIntepreterTest, test_messageHasInvalidDirectiveKey) {
  * and passed to directive sequencer. ExceptionEncounteredEvent should be sent to AVS.
  */
 TEST_F(MessageIntepreterTest, test_messageHasInvalidHeaderKey) {
-    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _)).Times(1);
+    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _, _)).Times(1);
     EXPECT_CALL(*m_mockDirectiveSequencer, onDirective(_)).Times(0);
-    m_messageInterpreter->receive(TEST_ATTACHMENT_CONTEXT_ID, DIRECTIVE_INVALID_HEADER_KEY);
+    m_messageInterpreter->receive(
+        avsCommon::avs::AgentId::getAlexaAgentId(), TEST_ATTACHMENT_CONTEXT_ID, DIRECTIVE_INVALID_HEADER_KEY);
 }
 
 /**
@@ -239,9 +241,10 @@ TEST_F(MessageIntepreterTest, test_messageHasInvalidHeaderKey) {
  * and passed to directive sequencer. ExceptionEncounteredEvent should be sent to AVS.
  */
 TEST_F(MessageIntepreterTest, test_messageHasInvalidNamespaceKey) {
-    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _)).Times(1);
+    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _, _)).Times(1);
     EXPECT_CALL(*m_mockDirectiveSequencer, onDirective(_)).Times(0);
-    m_messageInterpreter->receive(TEST_ATTACHMENT_CONTEXT_ID, DIRECTIVE_INVALID_NAMESPACE_KEY);
+    m_messageInterpreter->receive(
+        avsCommon::avs::AgentId::getAlexaAgentId(), TEST_ATTACHMENT_CONTEXT_ID, DIRECTIVE_INVALID_NAMESPACE_KEY);
 }
 
 /**
@@ -249,9 +252,10 @@ TEST_F(MessageIntepreterTest, test_messageHasInvalidNamespaceKey) {
  * and passed to directive sequencer. ExceptionEncounteredEvent should be sent to AVS.
  */
 TEST_F(MessageIntepreterTest, test_messageHasInvalidNameKey) {
-    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _)).Times(1);
+    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _, _)).Times(1);
     EXPECT_CALL(*m_mockDirectiveSequencer, onDirective(_)).Times(0);
-    m_messageInterpreter->receive(TEST_ATTACHMENT_CONTEXT_ID, DIRECTIVE_INVALID_NAME_KEY);
+    m_messageInterpreter->receive(
+        avsCommon::avs::AgentId::getAlexaAgentId(), TEST_ATTACHMENT_CONTEXT_ID, DIRECTIVE_INVALID_NAME_KEY);
 }
 
 /**
@@ -259,9 +263,10 @@ TEST_F(MessageIntepreterTest, test_messageHasInvalidNameKey) {
  * and passed to directive sequencer. ExceptionEncounteredEvent should be sent to AVS.
  */
 TEST_F(MessageIntepreterTest, test_messageHasInvalidMessageIdKey) {
-    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _)).Times(1);
+    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _, _)).Times(1);
     EXPECT_CALL(*m_mockDirectiveSequencer, onDirective(_)).Times(0);
-    m_messageInterpreter->receive(TEST_ATTACHMENT_CONTEXT_ID, DIRECTIVE_INVALID_MESSAGEID_KEY);
+    m_messageInterpreter->receive(
+        avsCommon::avs::AgentId::getAlexaAgentId(), TEST_ATTACHMENT_CONTEXT_ID, DIRECTIVE_INVALID_MESSAGEID_KEY);
 }
 
 /**
@@ -269,7 +274,7 @@ TEST_F(MessageIntepreterTest, test_messageHasInvalidMessageIdKey) {
  * AVSDirective should be created and passed to the directive sequencer.
  */
 TEST_F(MessageIntepreterTest, test_messageHasNoDialogRequestIdKey) {
-    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _)).Times(0);
+    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _, _)).Times(0);
     EXPECT_CALL(*m_mockDirectiveSequencer, onDirective(_))
         .Times(1)
         .WillOnce(Invoke([](std::shared_ptr<AVSDirective> avsDirective) -> bool {
@@ -279,7 +284,8 @@ TEST_F(MessageIntepreterTest, test_messageHasNoDialogRequestIdKey) {
             EXPECT_TRUE(avsDirective->getDialogRequestId().empty());
             return true;
         }));
-    m_messageInterpreter->receive(TEST_ATTACHMENT_CONTEXT_ID, DIRECTIVE_NO_DIALOG_REQUEST_ID_KEY);
+    m_messageInterpreter->receive(
+        avsCommon::avs::AgentId::getAlexaAgentId(), TEST_ATTACHMENT_CONTEXT_ID, DIRECTIVE_NO_DIALOG_REQUEST_ID_KEY);
 }
 
 /**
@@ -287,9 +293,10 @@ TEST_F(MessageIntepreterTest, test_messageHasNoDialogRequestIdKey) {
  * and passed to directive sequencer. ExceptionEncounteredEvent should be sent to AVS.
  */
 TEST_F(MessageIntepreterTest, test_messageHasNoPayloadKey) {
-    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _)).Times(1);
+    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _, _)).Times(1);
     EXPECT_CALL(*m_mockDirectiveSequencer, onDirective(_)).Times(0);
-    m_messageInterpreter->receive(TEST_ATTACHMENT_CONTEXT_ID, DIRECTIVE_NO_PAYLOAD);
+    m_messageInterpreter->receive(
+        avsCommon::avs::AgentId::getAlexaAgentId(), TEST_ATTACHMENT_CONTEXT_ID, DIRECTIVE_NO_PAYLOAD);
 }
 
 /**
@@ -297,9 +304,10 @@ TEST_F(MessageIntepreterTest, test_messageHasNoPayloadKey) {
  * and passed to directive sequencer. ExceptionEncounteredEvent should be sent to AVS.
  */
 TEST_F(MessageIntepreterTest, test_messageHasInvalidPayloadKey) {
-    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _)).Times(1);
+    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _, _)).Times(1);
     EXPECT_CALL(*m_mockDirectiveSequencer, onDirective(_)).Times(0);
-    m_messageInterpreter->receive(TEST_ATTACHMENT_CONTEXT_ID, DIRECTIVE_INVALID_PAYLOAD_KEY);
+    m_messageInterpreter->receive(
+        avsCommon::avs::AgentId::getAlexaAgentId(), TEST_ATTACHMENT_CONTEXT_ID, DIRECTIVE_INVALID_PAYLOAD_KEY);
 }
 
 /**
@@ -307,7 +315,7 @@ TEST_F(MessageIntepreterTest, test_messageHasInvalidPayloadKey) {
  * and passed to the directive sequencer.
  */
 TEST_F(MessageIntepreterTest, test_messageIsValidDirective) {
-    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _)).Times(0);
+    EXPECT_CALL(*m_mockExceptionEncounteredSender, sendExceptionEncountered(_, _, _, _)).Times(0);
     EXPECT_CALL(*m_mockDirectiveSequencer, onDirective(_))
         .Times(1)
         .WillOnce(Invoke([](std::shared_ptr<AVSDirective> avsDirective) -> bool {
@@ -317,7 +325,8 @@ TEST_F(MessageIntepreterTest, test_messageIsValidDirective) {
             EXPECT_EQ(avsDirective->getDialogRequestId(), DIALOG_REQUEST_ID_TEST);
             return true;
         }));
-    m_messageInterpreter->receive(TEST_ATTACHMENT_CONTEXT_ID, SPEAK_DIRECTIVE);
+    m_messageInterpreter->receive(
+        avsCommon::avs::AgentId::getAlexaAgentId(), TEST_ATTACHMENT_CONTEXT_ID, SPEAK_DIRECTIVE);
 }
 
 }  // namespace test
diff --git a/AFML/src/AudioActivityTracker.cpp b/AFML/src/AudioActivityTracker.cpp
index b0ef2fd6..abb90ec8 100644
--- a/AFML/src/AudioActivityTracker.cpp
+++ b/AFML/src/AudioActivityTracker.cpp
@@ -53,7 +53,8 @@ static const std::string TAG("AudioActivityTracker");
 #define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
 
 /// The state information @c NamespaceAndName to send to the @c ContextManager for AudioActivityTracker.
-static const NamespaceAndName CONTEXT_MANAGER_STATE{"AudioActivityTracker", "ActivityState"};
+static const NamespaceAndName CONTEXT_MANAGER_STATE{
+    "AudioActivityTracker", "ActivityState", AgentId::AGENT_ID_ALL};
 
 /// The idleTime key used in the AudioActivityTracker context.
 static const char IDLE_TIME_KEY[] = "idleTimeInMilliseconds";
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/AVSDirective.h b/AVSCommon/AVS/include/AVSCommon/AVS/AVSDirective.h
index 12e21b03..4828d3a5 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/AVSDirective.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/AVSDirective.h
@@ -21,6 +21,7 @@
 #include <string>
 #include <utility>
 
+#include <AVSCommon/AVS/AgentId.h>
 #include "Attachment/AttachmentManagerInterface.h"
 #include "AVSMessage.h"
 
@@ -62,9 +63,24 @@ public:
         ERROR_MISSING_PAYLOAD_KEY
     };
 
+    /**
+     * Creates an AVSDirective for the Alexa Agent.
+     *
+     * @param unparsedDirective The unparsed AVS Directive JSON string.
+     * @param attachmentManager The attachment manager.
+     * @param attachmentContextId The contextId required to get attachments from the AttachmentManager.
+     * @return A pair of an AVSDirective pointer and a parse status.  If the AVSDirective is nullptr, the status will
+     * express the parse error.
+     */
+    static std::pair<std::unique_ptr<AVSDirective>, ParseStatus> create(
+        const std::string& unparsedDirective,
+        const std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface>& attachmentManager,
+        const std::string& attachmentContextId);
+
     /**
      * Creates an AVSDirective.
      *
+     * @param agentId The AgentId associated with an AVS message.
      * @param unparsedDirective The unparsed AVS Directive JSON string.
      * @param attachmentManager The attachment manager.
      * @param attachmentContextId The contextId required to get attachments from the AttachmentManager.
@@ -72,13 +88,34 @@ public:
      * express the parse error.
      */
     static std::pair<std::unique_ptr<AVSDirective>, ParseStatus> create(
+        avsCommon::avs::AgentId::IdType agentId,
         const std::string& unparsedDirective,
-        std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface> attachmentManager,
+        const std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface>& attachmentManager,
         const std::string& attachmentContextId);
 
+    /**
+     * Creates an AVSDirective for the Alexa agent.
+     *
+     * @param unparsedDirective The unparsed AVS Directive JSON string.
+     * @param avsMessageHeader The header fields of the Directive.
+     * @param payload The payload of the Directive.
+     * @param attachmentManager The attachment manager.
+     * @param attachmentContextId The contextId required to get attachments from the AttachmentManager.
+     * @param endpoint Optional parameter used to identify the target endpoint for the given directive.
+     * @return The created AVSDirective object or @c nullptr if creation failed.
+     */
+    static std::unique_ptr<AVSDirective> create(
+        const std::string& unparsedDirective,
+        const std::shared_ptr<AVSMessageHeader>& avsMessageHeader,
+        const std::string& payload,
+        const std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface>& attachmentManager,
+        const std::string& attachmentContextId,
+        const utils::Optional<AVSMessageEndpoint>& endpoint = utils::Optional<AVSMessageEndpoint>());
+
     /**
      * Creates an AVSDirective.
      *
+     * @param agentId The AgentId associated with an AVS message.
      * @param unparsedDirective The unparsed AVS Directive JSON string.
      * @param avsMessageHeader The header fields of the Directive.
      * @param payload The payload of the Directive.
@@ -88,10 +125,11 @@ public:
      * @return The created AVSDirective object or @c nullptr if creation failed.
      */
     static std::unique_ptr<AVSDirective> create(
+        avsCommon::avs::AgentId::IdType agentId,
         const std::string& unparsedDirective,
-        std::shared_ptr<AVSMessageHeader> avsMessageHeader,
+        const std::shared_ptr<AVSMessageHeader>& avsMessageHeader,
         const std::string& payload,
-        std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface> attachmentManager,
+        const std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface>& attachmentManager,
         const std::string& attachmentContextId,
         const utils::Optional<AVSMessageEndpoint>& endpoint = utils::Optional<AVSMessageEndpoint>());
 
@@ -120,6 +158,7 @@ private:
     /**
      * Constructor.
      *
+     * @param agentId The AgentId associated with an AVS message.
      * @param unparsedDirective The unparsed directive JSON string from AVS.
      * @param avsMessageHeader The object representation of an AVS message header.
      * @param payload The payload of an AVS message.
@@ -128,6 +167,7 @@ private:
      * @param endpoint Optional parameter used to identify the target endpoint for the given directive.
      */
     AVSDirective(
+        avsCommon::avs::AgentId::IdType agentId,
         const std::string& unparsedDirective,
         std::shared_ptr<AVSMessageHeader> avsMessageHeader,
         const std::string& payload,
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h b/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h
index a15c9454..d0c5c681 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h
@@ -20,6 +20,7 @@
 #include <string>
 #include <vector>
 
+#include <AVSCommon/AVS/EndpointResources.h>
 #include <AVSCommon/SDKInterfaces/Endpoints/EndpointIdentifier.h>
 #include <AVSCommon/Utils/Optional.h>
 
@@ -123,6 +124,9 @@ struct AVSDiscoveryEndpointAttributes {
     /// A non-empty string identifying the endpoint manufacturer name.
     std::string manufacturerName;
 
+    /// An EndpointResources object containing friendly names, manufacturer name and description.
+    EndpointResources endpointResources;
+
     /// The display categories the device belongs to. This field should contain at least one category. See categories
     /// in this document: https://developer.amazon.com/docs/alexa/device-apis/alexa-discovery.html#display-categories
     /// @note: This value should only include ALEXA_VOICE_ENABLED for the default endpoint.
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/AVSMessage.h b/AVSCommon/AVS/include/AVSCommon/AVS/AVSMessage.h
index bcf4810e..78329a3b 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/AVSMessage.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/AVSMessage.h
@@ -21,6 +21,7 @@
 
 #include <AVSCommon/Utils/Optional.h>
 
+#include <AVSCommon/AVS/AgentId.h>
 #include "AVSCommon/AVS/AVSMessageEndpoint.h"
 #include "AVSCommon/AVS/AVSMessageHeader.h"
 
@@ -35,7 +36,7 @@ namespace avs {
 class AVSMessage {
 public:
     /**
-     * Constructor.
+     * Constructor of AVSMessage for Alexa agent.
      *
      * @param avsMessageHeader An object that contains the necessary header fields of an AVS message.
      *                         NOTE: This parameter MUST NOT be null.
@@ -47,6 +48,21 @@ public:
         std::string payload,
         const utils::Optional<AVSMessageEndpoint>& endpoint = utils::Optional<AVSMessageEndpoint>());
 
+    /**
+     * Constructor of AVSMessage.
+     *
+     * @param agentId The AgentId associated with an AVS message.
+     * @param avsMessageHeader An object that contains the necessary header fields of an AVS message.
+     *                         NOTE: This parameter MUST NOT be null.
+     * @param payload The payload associated with an AVS message. This is expected to be in the JSON format.
+     * @param endpoint The attributes for the target endpoint if available.
+     */
+    AVSMessage(
+        avsCommon::avs::AgentId::IdType agentId,
+        std::shared_ptr<AVSMessageHeader> avsMessageHeader,
+        std::string payload,
+        const utils::Optional<AVSMessageEndpoint>& endpoint = utils::Optional<AVSMessageEndpoint>());
+
     /**
      * Destructor.
      */
@@ -136,6 +152,13 @@ public:
      */
     utils::Optional<AVSMessageEndpoint> getEndpoint() const;
 
+    /**
+     * Return the @c AgentId in this message.
+     *
+     * @return An AgentId of this @c AVSMessage.
+     */
+    avsCommon::avs::AgentId::IdType getAgentId() const;
+
 private:
     /// The fields that represent the common items in the header of an AVS message.
     const std::shared_ptr<AVSMessageHeader> m_header;
@@ -145,6 +168,9 @@ private:
 
     /// The endpoint attributes of this message.
     const utils::Optional<AVSMessageEndpoint> m_endpoint;
+
+    /// The AgentId of this message.
+    const avsCommon::avs::AgentId::IdType m_agentId;
 };
 
 }  // namespace avs
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/AgentId.h b/AVSCommon/AVS/include/AVSCommon/AVS/AgentId.h
new file mode 100644
index 00000000..58d7bb0e
--- /dev/null
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/AgentId.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_AGENTID_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_AGENTID_H_
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+/**
+ * This class serves to express agent-neutral constants as well as provide a type for dynamic agent disambiguation.
+ * The Alexa Agent ID is expected to be set during application initialization before other components require its usage.
+ */
+class AgentId {
+public:
+    /// Type alias for the agent id.
+    using IdType = unsigned int;
+
+    /// A pre-defined value to express that no agent is associated with a given device-side concern.
+    static constexpr IdType AGENT_ID_NONE = 0;
+
+    /// A pre-defined value to express that a given device-side concern is relevant to all available agents.
+    static constexpr IdType AGENT_ID_ALL = 1;
+
+    /**
+     * Sets the agent id to be associated with the Alexa agent. This method is not thread-safe, and must be called
+     * before any other component is expected to query for the value from the @c getAlexaAgentId method. Once set,
+     * subsequent calls will not change the value of the Alexa agent id. Any non-negative integer may be used outside
+     * of the pre-defined values within this file. Calls to this function with such pre-defined values will be
+     * ignored.
+     *
+     * @param id The agent id which should be associated with the Alexa agent.
+     */
+    static void setAlexaAgentId(IdType id);
+
+    /**
+     * Retrieves the value of the agent id associated with the Alexa agent. This method is not thread-safe, and is
+     * expected to be called strictly after the id has been set during initialization. Behaviour for calls made
+     * before or during initialization is undefined.
+     *
+     * @return The agent id associated with the Alexa agent.
+     */
+    static IdType getAlexaAgentId();
+};
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_AGENTID_H_
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/AgentInitiator.h b/AVSCommon/AVS/include/AVSCommon/AVS/AgentInitiator.h
new file mode 100644
index 00000000..bde71215
--- /dev/null
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/AgentInitiator.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_AGENTINITIATOR_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_AGENTINITIATOR_H_
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+#include <string>
+
+/**
+ * Enumerates the different initiators supported by AVS which may be used to invoke an agent.
+ */
+enum class AgentInitiator {
+    /// The agent invocation was initiated by a press-and-hold action.
+    PRESS_AND_HOLD,
+    /// The agent invocation was initiated by a tap-to-talk action.
+    TAP,
+    /// The agent invocation was initiated by a wakeword action.
+    WAKEWORD
+};
+
+/**
+ * Convert an @c AgentInitiator value to an AVS-compliant string.
+ *
+ * @param initiator The initiator value to convert to a string.
+ * @return The @c std::string conversion of the @c Initiator value.
+ */
+inline std::string initiatorToString(AgentInitiator initiator) {
+    switch (initiator) {
+        case AgentInitiator::PRESS_AND_HOLD:
+            return "PRESS_AND_HOLD";
+        case AgentInitiator::TAP:
+            return "TAP";
+        case AgentInitiator::WAKEWORD:
+            return "WAKEWORD";
+    }
+    return "Unknown Initiator";
+}
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_AGENTINITIATOR_H_
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/CapabilityAgent.h b/AVSCommon/AVS/include/AVSCommon/AVS/CapabilityAgent.h
index 3c20b242..12f55ad4 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/CapabilityAgent.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/CapabilityAgent.h
@@ -185,7 +185,7 @@ protected:
     void removeDirective(const std::string& messageId);
 
     /**
-     * Send ExceptionEncountered and report a failure to handle the @c AVSDirective.
+     * Send ExceptionEncountered and report a failure to handle the @c AVSDirective for the Alexa Agent.
      *
      * @param info The @c AVSDirective that encountered the error and ancillary information.
      * @param message The error message to include in the ExceptionEncountered message.
@@ -196,6 +196,20 @@ protected:
         const std::string& message,
         avsCommon::avs::ExceptionErrorType type = avsCommon::avs::ExceptionErrorType::INTERNAL_ERROR);
 
+    /**
+     * Send ExceptionEncountered and report a failure to handle the @c AVSDirective.
+     *
+     * @param agentId The @c AgentId of where the exception should be sent.
+     * @param info The @c AVSDirective that encountered the error and ancillary information.
+     * @param message The error message to include in the ExceptionEncountered message.
+     * @param type The type of Exception that was encountered.
+     */
+    void sendExceptionEncounteredAndReportFailed(
+        avsCommon::avs::AgentId::IdType agentId,
+        std::shared_ptr<DirectiveInfo> info,
+        const std::string& message,
+        avsCommon::avs::ExceptionErrorType type);
+
     /**
      * Builds a JSON event string which includes the header, the @c payload and an optional @c context.
      * The header includes the namespace, name, message Id and an optional @c dialogRequestId.
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/CapabilityTag.h b/AVSCommon/AVS/include/AVSCommon/AVS/CapabilityTag.h
index b4713bc7..2ddbe5df 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/CapabilityTag.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/CapabilityTag.h
@@ -19,6 +19,7 @@
 #include <ostream>
 #include <string>
 
+#include <AVSCommon/AVS/AgentId.h>
 #include <AVSCommon/Utils/Optional.h>
 
 namespace alexaClientSDK {
@@ -29,9 +30,10 @@ namespace avs {
  * Structure containing values for namespace, name, endpointId and optionally instance which are intended for
  * identifying AVS Messages (Directives, Events, State, and Exceptions).
  */
-struct CapabilityTag {
+class CapabilityTag {
+public:
     /**
-     * Constructor.
+     * Constructor of CapabilityTag for Alexa agent.
      *
      * @param namespace The namespace value for this message.
      * @param name The name for this message.
@@ -45,6 +47,23 @@ struct CapabilityTag {
         const std::string& endpointId,
         const utils::Optional<std::string>& instanceId = utils::Optional<std::string>());
 
+    /**
+     * Constructor for CapabilityTag.
+     *
+     * @param namespace The namespace value for this message.
+     * @param name The name for this message.
+     * @param agentId The @c AgentId for this @c CapabilityTag.
+     * @param endpointId The endpoint id used to identify the target / source endpoint.
+     * @param instanceId Optional value for specifying an specific capability instance. This field should be left
+     * empty if the capability does not support multiple instances.
+     */
+    CapabilityTag(
+        const std::string& nameSpace,
+        const std::string& name,
+        AgentId::IdType agentId,
+        const std::string& endpointId,
+        const utils::Optional<std::string>& instanceId = utils::Optional<std::string>());
+
     /**
      * Copy constructor.
      *
@@ -52,6 +71,13 @@ struct CapabilityTag {
      */
     CapabilityTag(const CapabilityTag& other) = default;
 
+    /**
+     * Get the Agent Id of CapabilityTag.
+     *
+     * @return The AgentId of the @c CapabilityTag.
+     */
+    avsCommon::avs::AgentId::IdType getAgentId() const;
+
     /// The namespace value of this message.
     const std::string nameSpace;
 
@@ -77,6 +103,10 @@ struct CapabilityTag {
     bool operator==(const CapabilityTag& rhs) const;
     bool operator!=(const CapabilityTag& rhs) const;
     /// @}
+
+private:
+    /// The AgentId of this capability.
+    utils::Optional<avsCommon::avs::AgentId::IdType> optionalAgentId;
 };
 
 /**
@@ -87,8 +117,8 @@ struct CapabilityTag {
  * @return The @c ostream that was passed in and written to.
  */
 inline std::ostream& operator<<(std::ostream& stream, const CapabilityTag& identifier) {
-    stream << "{endpointId:" << identifier.endpointId << ",namespace:" << identifier.nameSpace
-           << ",name:" << identifier.name;
+    stream << "{endpointId:" << identifier.endpointId << ",agentId:" << identifier.getAgentId()
+           << ",namespace:" << identifier.nameSpace << ",name:" << identifier.name;
     if (identifier.instance.hasValue()) {
         stream << ",instance:" << identifier.instance.value();
     }
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h b/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h
index f0927add..8fb05ce0 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h
@@ -21,8 +21,11 @@
 #include <unordered_set>
 #include <vector>
 
+#include <acsdk/MultiAgentInterface/AgentManagerInterface.h>
+#include <acsdk/MultiAgentInterface/Connection/AgentConnectionObserverInterface.h>
 #include <acsdkInteractionModelInterfaces/InteractionModelNotifierInterface.h>
 #include <acsdkInteractionModelInterfaces/InteractionModelRequestProcessingObserverInterface.h>
+#include <AVSCommon/AVS/AgentId.h>
 #include <AVSCommon/SDKInterfaces/AudioInputProcessorObserverInterface.h>
 #include <AVSCommon/SDKInterfaces/AVSConnectionManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/ConnectionStatusObserverInterface.h>
@@ -45,6 +48,7 @@ class DialogUXStateAggregator
         : public sdkInterfaces::AudioInputProcessorObserverInterface
         , public sdkInterfaces::SpeechSynthesizerObserverInterface
         , public sdkInterfaces::ConnectionStatusObserverInterface
+        , public multiAgentInterface::connection::AgentConnectionObserverInterface
         , public acsdkInteractionModelInterfaces::InteractionModelRequestProcessingObserverInterface {
 public:
     /**
@@ -79,7 +83,8 @@ public:
         const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
         const std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface>& connectionManager,
         const std::shared_ptr<acsdkInteractionModelInterfaces::InteractionModelNotifierInterface>&
-            interactionModelNotifier);
+            interactionModelNotifier,
+        const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager = nullptr);
 
     /**
      * Constructor.
@@ -124,22 +129,20 @@ public:
 
     /// @name AudioInputProcessorObserverInterface Functions
     /// @{
-    void onStateChanged(sdkInterfaces::AudioInputProcessorObserverInterface::State state) override;
+    void onStateChanged(
+        avsCommon::avs::AgentId::IdType agentId,
+        sdkInterfaces::AudioInputProcessorObserverInterface::State state) override;
     /// @}
 
     /// @name SpeechSynthesizerObserverInterface Functions
     /// @{
-    void onStateChanged(
-        sdkInterfaces::SpeechSynthesizerObserverInterface::SpeechSynthesizerState state,
-        const avsCommon::utils::mediaPlayer::MediaPlayerInterface::SourceId mediaSourceId,
-        const avsCommon::utils::Optional<avsCommon::utils::mediaPlayer::MediaPlayerState>& mediaPlayerState,
-        const std::vector<avsCommon::utils::audioAnalyzer::AudioAnalyzerState>& audioAnalyzerState) override;
+    void onStateChanged(SpeechSynthesizerState state, const Context& context) override;
     /// @}
 
     /// @name InteractionModelRequestProcessingObserverInterface Functions
     /// @{
-    void onRequestProcessingStarted() override;
-    void onRequestProcessingCompleted() override;
+    void onRequestProcessingStarted(avsCommon::avs::AgentId::IdType agentId) override;
+    void onRequestProcessingCompleted(avsCommon::avs::AgentId::IdType agentId) override;
     /// @}
 
     /// @name ConnectionStatusObserverInterface Functions
@@ -151,7 +154,15 @@ public:
     void onConnectionStatusChanged(const Status status, const std::vector<EngineConnectionStatus>& engineStatuses)
         override;
     /// @}
+    void setContinueWithInvalidTransition(bool continueWithInvalidTransition);
 
+    /// @name AgentConnectionObserverInterface Functions
+    /// @{
+    void onAgentAvailabilityStateChanged(
+        avsCommon::avs::AgentId::IdType agentId,
+        AvailabilityState status,
+        const std::string& reason) override;
+    /// @}
 private:
     /**
      * Notifies all observers of the current state. This should only be used within the internal executor.
@@ -215,6 +226,9 @@ private:
     /// The current overall UX state of the AVS system.
     sdkInterfaces::DialogUXStateObserverInterface::DialogUXState m_currentState;
 
+    /// The current agent id handling the request.
+    avsCommon::avs::AgentId::IdType m_currentAgentId;
+
     /// The timeout to be used for transitioning away from the THINKING state in case no messages are received.
     const std::chrono::milliseconds m_timeoutForThinkingToIdle;
 
@@ -255,6 +269,9 @@ private:
     /// Contains the current state of the @c AudioInputProcessor as reported by @c AudioInputProcessorObserverInterface
     std::atomic<alexaClientSDK::avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface::State>
         m_audioInputProcessorState;
+
+    /// 
+    std::atomic<bool> m_continueWithInvalidTransition;
 };
 
 }  // namespace avs
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/DirectiveRoutingRule.h b/AVSCommon/AVS/include/AVSCommon/AVS/DirectiveRoutingRule.h
index 432ac934..b7ff7405 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/DirectiveRoutingRule.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/DirectiveRoutingRule.h
@@ -18,6 +18,8 @@
 
 #include "AVSCommon/AVS/CapabilityTag.h"
 
+#include <AVSCommon/AVS/AgentId.h>
+
 namespace alexaClientSDK {
 namespace avsCommon {
 namespace avs {
@@ -28,66 +30,137 @@ namespace directiveRoutingRule {
  *
  * The following rules will be accepted.
  *
- *   - Per directive: {EndpointId, Instance, Namespace, Name}
- *   - Per namespace: {EndpointId, Instance, Namespace, *}
- *   - Per instance: {EndpointId, Instance, *, *}
- *   - Per namespace for any instance: {EndpointId, *, Namespace, *}
- *   - Per endpoint: {EndpointId, *, *, *}
+ *   - Per directive for a given agent: {EndpointId, Instance, AgentId, Namespace, Name}
+ *   - Per directive of any agent: {EndpointId, Instance, AGENT_ID_ALL, Namespace, Name}
+ *   - Per namespace of a given agent: {EndpointId, Instance, AgentId, Namespace, *}
+ *   - Per namespace of any agent: {EndpointId, Instance, AGENT_ID_ALL, Namespace, *}
+ *   - Per instance of a given agent: {EndpointId, Instance, AgentId, *, *}
+ *   - Per instance of any agent: {EndpointId, Instance, AGENT_ID_ALL, *, *}
+ *   - Per namespace for any instance and a given agent: {EndpointId, *, AgentId, Namespace, *}
+ *   - Per namespace for any instance and any agent: {EndpointId, *, AGENT_ID_ALL, Namespace, *}
+ *   - Per endpoint of a given agent: {EndpointId, *, AgentId, *, *}
+ *   - Per endpoint of any agent: {EndpointId, *, AGENT_ID_ALL, *, *}
  *
  * Note that we used '*' to represent wildcards.
  */
 using DirectiveRoutingRule = CapabilityTag;
 
 /**
- * Function used to create a directive routing rule that matches one specific directive.
+ * Function used to create a directive routing rule that matches one specific directive for a particular agent.
  *
+ * @param agentId The directive agentId identifier.
  * @param endpointId The directive target endpoint identifier.
  * @param instance The directive instance if available.
  * @param nameSpace The directive namespace.
  * @param name The directive name.
  */
 DirectiveRoutingRule routingRulePerDirective(
+    avsCommon::avs::AgentId::IdType agentId,
     const std::string& endpointId,
     const utils::Optional<std::string>& instance,
     const std::string& nameSpace,
     const std::string& name);
 
 /**
- * Function used to create a directive routing rule that matches one specific directive.
+ * Function used to create a directive routing rule that matches one specific directive for any agent.
  *
  * @param endpointId The directive target endpoint identifier.
  * @param instance The directive instance if available.
  * @param nameSpace The directive namespace.
+ * @param name The directive name.
+ */
+DirectiveRoutingRule routingRulePerDirectiveAnyAgent(
+    const std::string& endpointId,
+    const utils::Optional<std::string>& instance,
+    const std::string& nameSpace,
+    const std::string& name);
+
+/**
+ * Function used to create a directive routing rule that matches one specific directive for a particular agent.
+ *
+ * @param agentId The directive agentId identifier.
+ * @param endpointId The directive target endpoint identifier.
+ * @param instance The directive instance if available.
+ * @param nameSpace The directive namespace.
  */
 DirectiveRoutingRule routingRulePerNamespace(
+    avsCommon::avs::AgentId::IdType agentId,
+    const std::string& endpointId,
+    const utils::Optional<std::string>& instance,
+    const std::string& nameSpace);
+
+/**
+ * Function used to create a directive routing rule that matches one specific directive for any agent.
+ *
+ * @param endpointId The directive target endpoint identifier.
+ * @param instance The directive instance if available.
+ * @param nameSpace The directive namespace.
+ */
+DirectiveRoutingRule routingRulePerNamespaceAnyAgent(
     const std::string& endpointId,
     const utils::Optional<std::string>& instance,
     const std::string& nameSpace);
 
 /**
- * Function used to create a directive routing rule that matches one specific directive.
+ * Function used to create a directive routing rule that matches one specific directive for a particular agent.
  *
+ * @param agentId The directive agentId identifier.
  * @param endpointId The directive target endpoint identifier.
  * @param instance The directive instance if available.
  */
 DirectiveRoutingRule routingRulePerInstance(
+    avsCommon::avs::AgentId::IdType agentId,
     const std::string& endpointId,
     const utils::Optional<std::string>& instance);
 
 /**
- * Function used to create a directive routing rule that matches a specific namespace independently from their instance.
+ * Function used to create a directive routing rule that matches one specific directive for any agent.
  *
  * @param endpointId The directive target endpoint identifier.
+ * @param instance The directive instance if available.
+ */
+DirectiveRoutingRule routingRulePerInstanceAnyAgent(
+    const std::string& endpointId,
+    const utils::Optional<std::string>& instance);
+
+/**
+ * Function used to create a directive routing rule that matches a specific namespace independently from their instance
+ * for a particular agent.
+ *
+ * @param agentId The directive agentId identifier.
+ * @param endpointId The directive target endpoint identifier.
  * @param nameSpace The directive namespace.
  */
-DirectiveRoutingRule routingRulePerNamespaceAnyInstance(const std::string& endpointId, const std::string& nameSpace);
+DirectiveRoutingRule routingRulePerNamespaceAnyInstance(
+    avsCommon::avs::AgentId::IdType agentId,
+    const std::string& endpointId,
+    const std::string& nameSpace);
+
+/**
+ * Function used to create a directive routing rule that matches a specific namespace independently from their instance
+ * for any agent.
+ *
+ * @param endpointId The directive target endpoint identifier.
+ * @param nameSpace The directive namespace.
+ */
+DirectiveRoutingRule routingRulePerNamespaceAnyInstanceAnyAgent(
+    const std::string& endpointId,
+    const std::string& nameSpace);
+
+/**
+ * Function used to create a directive routing rule that matches one specific directive for a particular agent.
+ *
+ * @param agentId The directive agentId identifier.
+ * @param endpointId The directive target endpoint identifier.
+ */
+DirectiveRoutingRule routingRulePerEndpoint(avsCommon::avs::AgentId::IdType agentId, const std::string& endpointId);
 
 /**
- * Function used to create a directive routing rule that matches one specific directive.
+ * Function used to create a directive routing rule that matches one specific directive for any agent.
  *
  * @param endpointId The directive target endpoint identifier.
  */
-DirectiveRoutingRule routingRulePerEndpoint(const std::string& endpointId);
+DirectiveRoutingRule routingRulePerEndpointAnyAgent(const std::string& endpointId);
 
 /**
  * Function used to validate that a directive routing rule is valid.
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h b/AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h
new file mode 100644
index 00000000..a81ec512
--- /dev/null
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h
@@ -0,0 +1,188 @@
+/*
+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ENDPOINTRESOURCES_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ENDPOINTRESOURCES_H_
+
+#include <string>
+#include <vector>
+
+#include <AVSCommon/AVS/Locale.h>
+#include <AVSCommon/Utils/Optional.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+class EndpointResources {
+public:
+    /**
+     * The constructor.
+     */
+    EndpointResources();
+
+    /**
+     * Function to add friendly name using asset id.
+     * 
+     * @param assetId The asset id of the friendly name.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addFriendlyNameWithAssetId(const std::string& assetId);
+
+    /**
+     * Function to add friendly name using text value and its locale.
+     *
+     * @note When using this method it is recommended to provide the friendly names
+     * in all the Alexa supported languages. See the class-level link to find the currently
+     * supported languages.
+     *
+     * @note Providing an unsupported locale will result in Discovery failure.
+     *
+     * @param text The text of the friendly name. This value can contain up to 128 valid characters.
+     * @param locale The non-empty locale of the friendly name. 
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addFriendlyNameWithText(
+            const std::string& text,
+            const avsCommon::avs::Locale& locale);
+
+    /**
+     * Function to add manufacturer name using asset id.
+     *
+     * @param assetId The asset id of the manufacturer name using @c string.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addManufacturerNameWithAssetId(const std::string& assetId);
+
+    /**
+     * Function to add manufacturer name using text value and its locale.
+     *
+     * @note When using this method it is recommended to provide the manufacturer name
+     * in all the Alexa supported languages. See the class-level link to find the currently
+     * supported languages.
+     *
+     * @note Providing an unsupported locale will result in Discovery failure.
+     *
+     * @param text The text of the manufacturer name. This value can contain up to 128 valid characters.
+     * @param locale The non-empty locale of the manufacturer name.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addManufacturerNameWithText(
+            const std::string& text,
+            const avsCommon::avs::Locale& locale);
+
+    /**
+     * Function to add description using asset id.
+     *
+     * @param assetId The asset id of the description using @c string.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addDescriptionWithAssetId(const std::string& assetId);
+
+    /**
+     * Function to add description using text value and its locale.
+     *
+     * @note When using this method it is recommended to provide the description
+     * in all the Alexa supported languages. See the class-level link to find the currently
+     * supported languages.
+     *
+     * @note Providing an unsupported locale will result in Discovery failure.
+     *
+     * @param text The text of the description. This value can contain up to 128 valid characters.
+     * @param locale The non-empty locale of the description.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addDescriptionWithText(
+            const std::string& text,
+            const avsCommon::avs::Locale& locale);
+
+    /**
+     * Function to check if the @c EndpointResources is valid.
+     *
+     * @return Return @c true if valid, otherwise @c false.
+     */
+     bool isValid() const;
+
+    /**
+     * Builds a new EndpointResources with the configured properties.
+     *
+     * Build will fail if any attribute is invalid or if a mandatory attribute is missing.
+     *
+     * @return A json string representing the EndpointResources; otherwise, an empty string.
+     */
+     std::string build() const;
+
+private:
+    /**
+     * Struct defining a Label, used to describe a resource.
+     * @see https://developer.amazon.com/docs/device-apis/resources-and-assets.html#capability-resources
+     */
+    struct Label {
+        /// The enum representing the Label type.
+        enum class LabelType {
+            /// Asset type.
+            ASSET,
+
+            /// Text type.
+            TEXT
+        };
+
+        /// The type of the Label. 
+        LabelType type;
+
+        /// The value to contain the text or the asset id of the friendly name, manufacturer name or description.
+        std::string value;
+
+        /// The locale of the text, and empty object for asset.
+        avsCommon::utils::Optional<avsCommon::avs::Locale> locale;
+
+        /**
+         *  @name Comparison operator.
+         *
+         *  Compare the current Label against a second object.
+         *  Defined for std::find.
+         *
+         *  @param rhs The object to compare against this.
+         *  @return @c true if the comparison holds; @c false otherwise.
+         */
+        /// @{
+        bool operator==(const Label& rhs) const;
+        /// @}
+
+        /**
+         * Helper function to convert a Label to a json string.
+         *
+         * @return A json string of Label.
+         */
+        std::string toJson() const;
+    };
+
+    /// Flag to indicate if there was any error noted.
+    bool m_isValid = false;
+
+    /// Vector holding @c Label for the friendly names.
+    std::vector<Label> m_friendlyNames;
+
+    /// @c Label that holds the manufacturer name.
+    Label m_manufacturerName;
+
+    /// @c Label that holds the description.
+    Label m_description;
+};
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif //ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ENDPOINTRESOURCES_H_
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/ExceptionEncounteredSender.h b/AVSCommon/AVS/include/AVSCommon/AVS/ExceptionEncounteredSender.h
index 38f3f130..7edae174 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/ExceptionEncounteredSender.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/ExceptionEncounteredSender.h
@@ -52,18 +52,18 @@ public:
     static std::unique_ptr<ExceptionEncounteredSender> create(
         std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
 
-    /**
-     * This function asks the @c ExceptionEncounteredSender to send a ExceptionEncountered event to AVS when
-     * the client is unable to execute a directive.
-     *
-     * @param unparsedDirective The directive which the client was unable to execute, must be sent to AVS
-     * @param error The @c ExceptionErrorType to be sent to AVS
-     * @param errorDescription The error details to be sent for logging and troubleshooting.
-     */
+    /// @name ExceptionEncounteredSenderInterface Functions
+    /// @{
+    void sendExceptionEncountered(
+        const std::string& unparsedDirective,
+        avs::ExceptionErrorType error,
+        const std::string& errorDescription) override;
     void sendExceptionEncountered(
+        avsCommon::avs::AgentId::IdType agentId,
         const std::string& unparsedDirective,
         avs::ExceptionErrorType error,
         const std::string& errorDescription) override;
+    /// @}
 
 private:
     /**
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/Locale.h b/AVSCommon/AVS/include/AVSCommon/AVS/Locale.h
new file mode 100644
index 00000000..5f7cece6
--- /dev/null
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/Locale.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_LOCALE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_LOCALE_H_
+
+#include <string>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+    /**
+     * Alias for the locale. The locale should follow <a href="https://tools.ietf.org/html/bcp47">BCP 47 format</a> and
+     * it's composed of a language tag and a region tag, e.g.: en-CA.
+     */
+    using Locale = std::string;
+
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_LOCALE_H_
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/MessageRequest.h b/AVSCommon/AVS/include/AVSCommon/AVS/MessageRequest.h
index 871dab5d..d93000d6 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/MessageRequest.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/MessageRequest.h
@@ -24,6 +24,7 @@
 #include <unordered_set>
 #include <vector>
 
+#include <AVSCommon/AVS/AgentId.h>
 #include "AVSCommon/AVS/Attachment/AttachmentReader.h"
 #include <AVSCommon/SDKInterfaces/MessageRequestObserverInterface.h>
 
@@ -70,7 +71,7 @@ public:
         std::function<bool(const std::shared_ptr<EditableMessageRequest>& req, const std::string& resolveKey)>;
 
     /**
-     * Constructor.
+     * Constructor for a message request to Alexa.
      *
      * @param jsonContent The message to be sent to AVS.
      * @param uriPathExtension An optional uri path extension which will be appended to the base url of the AVS.
@@ -87,7 +88,26 @@ public:
         const std::string& streamMetricName = "");
 
     /**
-     * Constructor.
+     * Constructor for a message request.
+     *
+     * @param agentId is the agent that is associated with the message.
+     * @param jsonContent The message to be sent to AVS.
+     * @param uriPathExtension An optional uri path extension which will be appended to the base url of the AVS.
+     * endpoint.  If not specified, the default AVS path extension should be used by the sender implementation.
+     * @param threshold. An optional threshold to ACL to send the metric specified by streamMetricName. If this isn't
+     * specified no metric will be recorded.
+     * @param streamMetricName. An optional metric name for ACL to submit when the threshold is met. If this isn't
+     * specified no metric will be recorded.
+     */
+    MessageRequest(
+        avsCommon::avs::AgentId::IdType agentId,
+        const std::string& jsonContent,
+        const std::string& uriPathExtension = "",
+        const unsigned int threshold = 0,
+        const std::string& streamMetricName = "");
+
+    /**
+     * Constructor for a message request to ALEXA.
      *
      * @param jsonContent The message to be sent to AVS.
      * @param threshold. A required threshold to ACL to send the metric specified by streamMetricName.
@@ -96,8 +116,50 @@ public:
     MessageRequest(const std::string& jsonContent, const unsigned int threshold, const std::string& streamMetricName);
 
     /**
-     * Constructor.
+     * Constructor for a message request.
+     *
+     * @param agentId is the agent that is associated with the message.
+     * @param jsonContent The message to be sent to AVS.
+     * @param threshold. A required threshold to ACL to send the metric specified by streamMetricName.
+     * @param streamMetricName. A required metric name for ACL to submit when the threshold is met.
+     */
+    MessageRequest(
+        avsCommon::avs::AgentId::IdType agentId,
+        const std::string& jsonContent,
+        const unsigned int threshold,
+        const std::string& streamMetricName);
+
+    /**
+     * Constructor for a message request to ALEXA.
+     *
+     * @param jsonContent The message to be sent to AVS.
+     * @param isSerialized True if sending this message must be serialized with sending other serialized messages.
+     * @param uriPathExtension An optional uri path extension which will be appended to the base url of the AVS.
+     * @param headers key/value pairs of extra HTTP headers to use with this request.
+     * endpoint.  If not specified, the default AVS path extension should be used by the sender implementation.
+     * @param resolver Function to resolve message. Null if message doesn't need resolving. Resolving function aims to
+     * support the use case that one message request will be sent to multiple places with some fields having different
+     * values for different destinations. In such use cases, @c MessageRequest works as a container with all required
+     * info to build different versions of requests. The resolving function contains the logic to build the target
+     * message request based on the info in the original request, and provided resolveKey.
+     * @param threshold. An optional threshold to ACL to send the metric specified by streamMetricName. If this isn't
+     * specified no metric will be recorded.
+     * @param streamMetricName. An optional metric name for ACL to submit when the threshold is met. If this isn't
+     * specified no metric will be recorded.
+     */
+    MessageRequest(
+        const std::string& jsonContent,
+        bool isSerialized,
+        const std::string& uriPathExtension = "",
+        std::vector<std::pair<std::string, std::string>> headers = {},
+        MessageRequestResolveFunction resolver = nullptr,
+        const unsigned int threshold = 0,
+        const std::string& streamMetricName = "");
+
+    /**
+     * Constructor for a message request.
      *
+     * @param agentId is the agent that is associated with the message.
      * @param jsonContent The message to be sent to AVS.
      * @param isSerialized True if sending this message must be serialized with sending other serialized messages.
      * @param uriPathExtension An optional uri path extension which will be appended to the base url of the AVS.
@@ -114,6 +176,7 @@ public:
      * specified no metric will be recorded.
      */
     MessageRequest(
+        avsCommon::avs::AgentId::IdType agentId,
         const std::string& jsonContent,
         bool isSerialized,
         const std::string& uriPathExtension = "",
@@ -248,6 +311,13 @@ public:
      */
     std::string getStreamMetricName() const;
 
+    /**
+     * Getter method for the agentId of the @c MessageRequest.
+     *
+     * @return the AgentId of the message
+     */
+    avsCommon::avs::AgentId::IdType getAgentId() const;
+
 protected:
     /// Mutex to guard access of m_observers.
     std::mutex m_observerMutex;
@@ -278,6 +348,9 @@ protected:
 
     /// The threshold for the number of bytes for when we should record the stream metric.
     unsigned int m_streamBytesThreshold;
+
+    /// The AgentId of the @c MessageRequest.
+    const avsCommon::avs::AgentId::IdType m_agentId;
 };
 
 }  // namespace avs
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/NamespaceAndName.h b/AVSCommon/AVS/include/AVSCommon/AVS/NamespaceAndName.h
index b145a7d3..5d471109 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/NamespaceAndName.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/NamespaceAndName.h
@@ -20,6 +20,8 @@
 
 #include "AVSCommon/AVS/CapabilityTag.h"
 
+#include <AVSCommon/AVS/AgentId.h>
+
 namespace alexaClientSDK {
 namespace avsCommon {
 namespace avs {
@@ -37,13 +39,25 @@ public:
     NamespaceAndName();
 
     /**
-     * Constructor to initialize wih specific values.
+     * Constructor to initialize wih specific values for Alexa as the agent.
      *
      * @param nameSpaceIn The @c namespace value for this instance.
      * @param nameIn The @c name value for this instance.
      */
     NamespaceAndName(const std::string& nameSpaceIn, const std::string& nameIn);
 
+    /**
+     * Constructor to initialize wih specific values.
+     *
+     * @param nameSpaceIn The @c namespace value for this instance.
+     * @param nameIn The @c name value for this instance.
+     * @param agentId The @c AgentId of this instance.
+     */
+    NamespaceAndName(
+        const std::string& nameSpaceIn,
+        const std::string& nameIn,
+        avsCommon::avs::AgentId::IdType agentId);
+
     /**
      * Constructor used to covert @c CapabilityMessageIdentifier into a @c NamespaceAndName object.
      *
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/WaitableMessageRequest.h b/AVSCommon/AVS/include/AVSCommon/AVS/WaitableMessageRequest.h
index f54d2883..a4bf1d7f 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/WaitableMessageRequest.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/WaitableMessageRequest.h
@@ -32,12 +32,20 @@ namespace avs {
 class WaitableMessageRequest : public avsCommon::avs::MessageRequest {
 public:
     /**
-     * Constructor.
+     * Constructor for waitable message for the Alexa agent.
      *
      * @param jsonContent The JSON content of the event.
      */
     WaitableMessageRequest(const std::string& jsonContent);
 
+    /**
+     * Constructor for waitable message with a specified agent.
+     *
+     * @param agentId The AgentId of the event.
+     * @param jsonContent The JSON content of the event.
+     */
+    WaitableMessageRequest(AgentId::IdType agentId, const std::string& jsonContent);
+
     /// @name MessageRequest Functions
     /// @{
     void sendCompleted(avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status sendMessageStatus) override;
diff --git a/AVSCommon/AVS/src/AVSDirective.cpp b/AVSCommon/AVS/src/AVSDirective.cpp
index d9e8c652..c5153637 100644
--- a/AVSCommon/AVS/src/AVSDirective.cpp
+++ b/AVSCommon/AVS/src/AVSDirective.cpp
@@ -14,6 +14,7 @@
  */
 
 #include "AVSCommon/AVS/AVSDirective.h"
+#include "AVSCommon/AVS/AgentId.h"
 #include <AVSCommon/Utils/JSON/JSONUtils.h>
 #include "AVSCommon/Utils/Logger/Logger.h"
 
@@ -238,7 +239,16 @@ static utils::Optional<AVSMessageEndpoint> parseEndpoint(const Document& documen
 
 std::pair<std::unique_ptr<AVSDirective>, AVSDirective::ParseStatus> AVSDirective::create(
     const std::string& unparsedDirective,
-    std::shared_ptr<AttachmentManagerInterface> attachmentManager,
+    const std::shared_ptr<AttachmentManagerInterface>& attachmentManager,
+    const std::string& attachmentContextId) {
+    return AVSDirective::create(
+        avsCommon::avs::AgentId::getAlexaAgentId(), unparsedDirective, attachmentManager, attachmentContextId);
+}
+
+std::pair<std::unique_ptr<AVSDirective>, AVSDirective::ParseStatus> AVSDirective::create(
+    avsCommon::avs::AgentId::IdType agentId,
+    const std::string& unparsedDirective,
+    const std::shared_ptr<AttachmentManagerInterface>& attachmentManager,
     const std::string& attachmentContextId) {
     std::pair<std::unique_ptr<AVSDirective>, ParseStatus> result;
     result.second = ParseStatus::SUCCESS;
@@ -264,17 +274,35 @@ std::pair<std::unique_ptr<AVSDirective>, AVSDirective::ParseStatus> AVSDirective
 
     auto endpoint = parseEndpoint(document);
 
-    result.first = std::unique_ptr<AVSDirective>(
-        new AVSDirective(unparsedDirective, header, payload, attachmentManager, attachmentContextId, endpoint));
+    result.first = std::unique_ptr<AVSDirective>(new AVSDirective(
+        agentId, unparsedDirective, header, payload, attachmentManager, attachmentContextId, endpoint));
 
     return result;
 }
 
 std::unique_ptr<AVSDirective> AVSDirective::create(
     const std::string& unparsedDirective,
-    const std::shared_ptr<AVSMessageHeader> avsMessageHeader,
+    const std::shared_ptr<AVSMessageHeader>& avsMessageHeader,
+    const std::string& payload,
+    const std::shared_ptr<AttachmentManagerInterface>& attachmentManager,
+    const std::string& attachmentContextId,
+    const utils::Optional<AVSMessageEndpoint>& endpoint) {
+    return AVSDirective::create(
+        avsCommon::avs::AgentId::getAlexaAgentId(),
+        unparsedDirective,
+        avsMessageHeader,
+        payload,
+        attachmentManager,
+        attachmentContextId,
+        endpoint);
+}
+
+std::unique_ptr<AVSDirective> AVSDirective::create(
+    avsCommon::avs::AgentId::IdType agentId,
+    const std::string& unparsedDirective,
+    const std::shared_ptr<AVSMessageHeader>& avsMessageHeader,
     const std::string& payload,
-    const std::shared_ptr<AttachmentManagerInterface> attachmentManager,
+    const std::shared_ptr<AttachmentManagerInterface>& attachmentManager,
     const std::string& attachmentContextId,
     const utils::Optional<AVSMessageEndpoint>& endpoint) {
     if (!avsMessageHeader) {
@@ -286,7 +314,7 @@ std::unique_ptr<AVSDirective> AVSDirective::create(
         return nullptr;
     }
     return std::unique_ptr<AVSDirective>(new AVSDirective(
-        unparsedDirective, avsMessageHeader, payload, attachmentManager, attachmentContextId, endpoint));
+        agentId, unparsedDirective, avsMessageHeader, payload, attachmentManager, attachmentContextId, endpoint));
 }
 
 std::unique_ptr<AttachmentReader> AVSDirective::getAttachmentReader(
@@ -301,13 +329,14 @@ std::unique_ptr<AttachmentReader> AVSDirective::getAttachmentReader(
 }
 
 AVSDirective::AVSDirective(
+    avsCommon::avs::AgentId::IdType agentId,
     const std::string& unparsedDirective,
     std::shared_ptr<AVSMessageHeader> avsMessageHeader,
     const std::string& payload,
     std::shared_ptr<AttachmentManagerInterface> attachmentManager,
     const std::string& attachmentContextId,
     const utils::Optional<AVSMessageEndpoint>& endpoint) :
-        AVSMessage{avsMessageHeader, payload, endpoint},
+        AVSMessage{agentId, avsMessageHeader, payload, endpoint},
         m_unparsedDirective{unparsedDirective},
         m_attachmentManager{attachmentManager},
         m_attachmentContextId{attachmentContextId} {
diff --git a/AVSCommon/AVS/src/AVSMessage.cpp b/AVSCommon/AVS/src/AVSMessage.cpp
index 9dfbb911..63fa1739 100644
--- a/AVSCommon/AVS/src/AVSMessage.cpp
+++ b/AVSCommon/AVS/src/AVSMessage.cpp
@@ -14,6 +14,7 @@
  */
 
 #include "AVSCommon/AVS/AVSMessage.h"
+#include <AVSCommon/AVS/AgentId.h>
 
 namespace alexaClientSDK {
 namespace avsCommon {
@@ -25,7 +26,19 @@ AVSMessage::AVSMessage(
     const utils::Optional<AVSMessageEndpoint>& endpoint) :
         m_header{avsMessageHeader},
         m_payload{std::move(payload)},
-        m_endpoint{endpoint} {
+        m_endpoint{endpoint},
+        m_agentId{avsCommon::avs::AgentId::getAlexaAgentId()} {
+}
+
+AVSMessage::AVSMessage(
+    avsCommon::avs::AgentId::IdType agentId,
+    std::shared_ptr<AVSMessageHeader> avsMessageHeader,
+    std::string payload,
+    const utils::Optional<AVSMessageEndpoint>& endpoint) :
+        m_header{avsMessageHeader},
+        m_payload{std::move(payload)},
+        m_endpoint{endpoint},
+        m_agentId{agentId} {
 }
 
 std::string AVSMessage::getNamespace() const {
@@ -76,6 +89,10 @@ utils::Optional<AVSMessageEndpoint> AVSMessage::getEndpoint() const {
     return m_endpoint;
 }
 
+avsCommon::avs::AgentId::IdType AVSMessage::getAgentId() const {
+    return m_agentId;
+}
+
 }  // namespace avs
 }  // namespace avsCommon
 }  // namespace alexaClientSDK
diff --git a/AVSCommon/AVS/src/AgentId.cpp b/AVSCommon/AVS/src/AgentId.cpp
new file mode 100644
index 00000000..50665766
--- /dev/null
+++ b/AVSCommon/AVS/src/AgentId.cpp
@@ -0,0 +1,73 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <AVSCommon/AVS/AgentId.h>
+
+#include "AVSCommon/Utils/Logger/Logger.h"
+
+#include <string>
+
+/// String to identify log entries originating from this file.
+#define TAG "AgentId"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param event The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+/// static class members.
+constexpr AgentId::IdType AgentId::AGENT_ID_NONE;
+constexpr AgentId::IdType AgentId::AGENT_ID_ALL;
+
+/// Our static representation of the Alexa agent id. It is expected to be set before being used by the application.
+static AgentId::IdType g_alexaAgentId = AgentId::AGENT_ID_NONE;
+
+void AgentId::setAlexaAgentId(AgentId::IdType id) {
+    // Ensure that this value is only set once by the application.
+    if (g_alexaAgentId != AgentId::AGENT_ID_NONE) {
+        ACSDK_ERROR(LX("setAlexaAgentIdFailed").m("Value has already been set."));
+        return;
+    }
+
+    // Ensure the parameter does not conflict with a pre-defined symbol.
+    if (AGENT_ID_NONE == id) {
+        ACSDK_ERROR(LX("setAlexaAgentIdFailed")
+                        .m("Parameter conflicts with 'AGENT_ID_NONE' (" + std::to_string(AGENT_ID_NONE) + "')'"));
+        return;
+    }
+
+    // Ensure the parameter does not conflict with a pre-defined symbol.
+    if (AGENT_ID_ALL == id) {
+        ACSDK_ERROR(LX("setAlexaAgentIdFailed")
+                        .m("Parameter conflicts with 'AGENT_ID_ALL' (" + std::to_string(AGENT_ID_ALL) + "')'"));
+        return;
+    }
+
+    g_alexaAgentId = id;
+}
+
+AgentId::IdType AgentId::getAlexaAgentId() {
+    return g_alexaAgentId;
+}
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/AVSCommon/AVS/src/CapabilityAgent.cpp b/AVSCommon/AVS/src/CapabilityAgent.cpp
index bb5b329a..91c88b41 100644
--- a/AVSCommon/AVS/src/CapabilityAgent.cpp
+++ b/AVSCommon/AVS/src/CapabilityAgent.cpp
@@ -141,6 +141,29 @@ void CapabilityAgent::sendExceptionEncounteredAndReportFailed(
     }
 }
 
+void CapabilityAgent::sendExceptionEncounteredAndReportFailed(
+    avsCommon::avs::AgentId::IdType agentId,
+    std::shared_ptr<DirectiveInfo> info,
+    const std::string& message,
+    avsCommon::avs::ExceptionErrorType type) {
+    if (info) {
+        if (info->directive) {
+            m_exceptionEncounteredSender->sendExceptionEncountered(
+                agentId, info->directive->getUnparsedDirective(), type, message);
+            removeDirective(info->directive->getMessageId());
+        } else {
+            ACSDK_ERROR(LX("sendExceptionEncounteredAndReportFailed").d("reason", "infoHasNoDirective"));
+        }
+        if (info->result) {
+            info->result->setFailed(message);
+        } else {
+            ACSDK_ERROR(LX("sendExceptionEncounteredAndReportFailed").d("reason", "infoHasNoResult"));
+        }
+    } else {
+        ACSDK_ERROR(LX("sendExceptionEncounteredAndReportFailed").d("reason", "infoNotFound"));
+    }
+}
+
 void CapabilityAgent::onDeregistered() {
     // default no op
 }
diff --git a/AVSCommon/AVS/src/CapabilityTag.cpp b/AVSCommon/AVS/src/CapabilityTag.cpp
index 23603bba..0a15f861 100644
--- a/AVSCommon/AVS/src/CapabilityTag.cpp
+++ b/AVSCommon/AVS/src/CapabilityTag.cpp
@@ -15,6 +15,7 @@
 
 #include <tuple>
 
+#include "AVSCommon/AVS/AgentId.h"
 #include "AVSCommon/AVS/CapabilityTag.h"
 #include "AVSCommon/Utils/functional/hash.h"
 
@@ -33,20 +34,45 @@ CapabilityTag::CapabilityTag(
         instance{instanceIdIn} {
 }
 
+CapabilityTag::CapabilityTag(
+    const std::string& nameSpaceIn,
+    const std::string& nameIn,
+    AgentId::IdType agentId,
+    const std::string& endpointIdIn,
+    const utils::Optional<std::string>& instanceIdIn) :
+        nameSpace{nameSpaceIn},
+        name{nameIn},
+        endpointId{endpointIdIn},
+        instance{instanceIdIn},
+        optionalAgentId{agentId} {
+}
+
 bool CapabilityTag::operator<(const CapabilityTag& rhs) const {
-    return std::tie(nameSpace, name, endpointId, instance) <
-           std::tie(rhs.nameSpace, rhs.name, rhs.endpointId, rhs.instance);
+    auto agentId = getAgentId();
+    auto rhsAgentId = rhs.getAgentId();
+    return std::tie(nameSpace, name, agentId, endpointId, instance) <
+           std::tie(rhs.nameSpace, rhs.name, rhsAgentId, rhs.endpointId, rhs.instance);
 }
 
 bool CapabilityTag::operator==(const CapabilityTag& rhs) const {
-    return std::tie(nameSpace, name, endpointId, instance) ==
-           std::tie(rhs.nameSpace, rhs.name, rhs.endpointId, rhs.instance);
+    auto agentId = getAgentId();
+    auto rhsAgentId = rhs.getAgentId();
+    return std::tie(nameSpace, name, agentId, endpointId, instance) ==
+           std::tie(rhs.nameSpace, rhs.name, rhsAgentId, rhs.endpointId, rhs.instance);
 }
 
 bool CapabilityTag::operator!=(const CapabilityTag& rhs) const {
     return !(*this == rhs);
 }
 
+avsCommon::avs::AgentId::IdType CapabilityTag::getAgentId() const {
+    if (optionalAgentId.hasValue()) {
+        return optionalAgentId.value();
+    }
+
+    return avsCommon::avs::AgentId::getAlexaAgentId();
+}
+
 }  // namespace avs
 }  // namespace avsCommon
 }  // namespace alexaClientSDK
@@ -58,6 +84,7 @@ size_t hash<alexaClientSDK::avsCommon::avs::CapabilityTag>::operator()(
     std::size_t seed = 0;
     alexaClientSDK::avsCommon::utils::functional::hashCombine(seed, in.nameSpace);
     alexaClientSDK::avsCommon::utils::functional::hashCombine(seed, in.name);
+    alexaClientSDK::avsCommon::utils::functional::hashCombine(seed, in.getAgentId());
     alexaClientSDK::avsCommon::utils::functional::hashCombine(seed, in.endpointId);
     alexaClientSDK::avsCommon::utils::functional::hashCombine(seed, in.instance.valueOr(""));
     return seed;
diff --git a/AVSCommon/AVS/src/DialogUXStateAggregator.cpp b/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
index f581277b..be015121 100644
--- a/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
+++ b/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
@@ -50,15 +50,20 @@ constexpr std::chrono::seconds DialogUXStateAggregator::LONG_TIMEOUT_FOR_LISTENI
 
 /**
  * Submits a metric of given event name
+ * @param agentId the agent id associated with the metric
  * @param metricRecorder The @c MetricRecorderInterface which records Metric events
  * @param eventName The name of the metric event
  */
-static void submitMetric(const std::shared_ptr<MetricRecorderInterface>& metricRecorder, const std::string& eventName) {
+static void submitMetric(
+    const avsCommon::avs::AgentId::IdType agentId,
+    const std::shared_ptr<MetricRecorderInterface>& metricRecorder,
+    const std::string& eventName) {
     if (!metricRecorder) {
         return;
     }
 
     auto metricEvent = MetricEventBuilder{}
+                           .setMetricContext(MetricContext{agentId})
                            .setActivityName(CUSTOM_METRIC_PREFIX + eventName)
                            .addDataPoint(DataPointCounterBuilder{}.setName(eventName).increment(1).build())
                            .build();
@@ -73,8 +78,8 @@ static void submitMetric(const std::shared_ptr<MetricRecorderInterface>& metricR
 std::shared_ptr<DialogUXStateAggregator> DialogUXStateAggregator::createDialogUXStateAggregator(
     const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
     const std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface>& connectionManager,
-    const std::shared_ptr<acsdkInteractionModelInterfaces::InteractionModelNotifierInterface>&
-        interactionModelNotifier) {
+    const std::shared_ptr<acsdkInteractionModelInterfaces::InteractionModelNotifierInterface>& interactionModelNotifier,
+    const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager) {
     ACSDK_DEBUG5(LX("createDialogUXStateAggregator"));
     if (!connectionManager || !interactionModelNotifier) {
         ACSDK_ERROR(LX("createDialogUXStateAggregatorFailed")
@@ -85,7 +90,17 @@ std::shared_ptr<DialogUXStateAggregator> DialogUXStateAggregator::createDialogUX
 
     auto dialogUXStateAggregator = std::make_shared<DialogUXStateAggregator>(metricRecorder);
 
-    connectionManager->addConnectionStatusObserver(dialogUXStateAggregator);
+    // If AgentManager is initialized, add DUXSA as an observer to AgentManager for agent connection status updates
+    // If not, add DUXSA as an observer to ConnectionManager
+    if (agentManager) {
+        auto agentIdList = agentManager->getAllAgentIds();
+        for (const auto& agentId : agentIdList) {
+            agentManager->addAgentConnectionObserverInterface(agentId, dialogUXStateAggregator);
+        }
+    } else {
+        connectionManager->addConnectionStatusObserver(dialogUXStateAggregator);
+    }
+
     interactionModelNotifier->addObserver(dialogUXStateAggregator);
 
     return dialogUXStateAggregator;
@@ -98,17 +113,23 @@ DialogUXStateAggregator::DialogUXStateAggregator(
     std::chrono::milliseconds shortTimeoutForThinkingToIdle) :
         m_metricRecorder{metricRecorder},
         m_currentState{DialogUXStateObserverInterface::DialogUXState::IDLE},
+        m_currentAgentId{avsCommon::avs::AgentId::getAlexaAgentId()},
         m_timeoutForThinkingToIdle{timeoutForThinkingToIdle},
         m_shortTimeoutForThinkingToIdle{shortTimeoutForThinkingToIdle},
         m_timeoutForListeningToIdle{timeoutForListeningToIdle},
         m_speechSynthesizerState{SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED},
-        m_audioInputProcessorState{AudioInputProcessorObserverInterface::State::IDLE} {
+        m_audioInputProcessorState{AudioInputProcessorObserverInterface::State::IDLE},
+        m_continueWithInvalidTransition{false} {
     ACSDK_DEBUG8(LX("timeout values in milliseconds")
                      .d("m_timeoutForThinkingToIdle", m_timeoutForThinkingToIdle.count())
                      .d("m_shortTimeoutForThinkingToIdle", m_shortTimeoutForThinkingToIdle.count())
                      .d("m_timeoutForListeningToIdle", m_timeoutForListeningToIdle.count()));
 }
 
+void DialogUXStateAggregator::setContinueWithInvalidTransition(bool continueWithInvalidTransition) {
+    m_continueWithInvalidTransition = continueWithInvalidTransition;
+}
+
 void DialogUXStateAggregator::addObserver(std::shared_ptr<DialogUXStateObserverInterface> observer) {
     if (!observer) {
         ACSDK_ERROR(LX("addObserverFailed").d("reason", "nullObserver"));
@@ -116,7 +137,7 @@ void DialogUXStateAggregator::addObserver(std::shared_ptr<DialogUXStateObserverI
     }
     m_executor.submit([this, observer]() {
         m_observers.insert(observer);
-        observer->onDialogUXStateChanged(m_currentState);
+        observer->onDialogUXStateChanged(m_currentAgentId, m_currentState);
     });
 }
 
@@ -128,11 +149,15 @@ void DialogUXStateAggregator::removeObserver(std::shared_ptr<DialogUXStateObserv
     m_executor.submit([this, observer]() { m_observers.erase(observer); }).wait();
 }
 
-void DialogUXStateAggregator::onStateChanged(AudioInputProcessorObserverInterface::State state) {
-    ACSDK_DEBUG0(LX("onStateChanged").d("AudioInputProcessorState", state));
+void DialogUXStateAggregator::onStateChanged(
+    avsCommon::avs::AgentId::IdType agentId,
+    AudioInputProcessorObserverInterface::State state) {
+    ACSDK_DEBUG0(LX("onStateChanged").d("agentId", agentId).d("AudioInputProcessorState", state));
+    m_currentAgentId = agentId;
     m_audioInputProcessorState = state;
-    m_executor.submit([this, state]() {
-        ACSDK_DEBUG0(LX("onStateChangedLambda").d("AudioInputProcessorState", state));
+    m_executor.submit([this, agentId, state]() {
+        (void)agentId;
+        ACSDK_DEBUG0(LX("onStateChangedLambda").d("agentId", agentId).d("AudioInputProcessorState", state));
         switch (state) {
             case AudioInputProcessorObserverInterface::State::IDLE:
                 executeTryEnterIdleState();
@@ -161,15 +186,13 @@ void DialogUXStateAggregator::onStateChanged(AudioInputProcessorObserverInterfac
     });
 }
 
-void DialogUXStateAggregator::onStateChanged(
-    SpeechSynthesizerObserverInterface::SpeechSynthesizerState state,
-    const avsCommon::utils::mediaPlayer::MediaPlayerInterface::SourceId mediaSourceId,
-    const avsCommon::utils::Optional<avsCommon::utils::mediaPlayer::MediaPlayerState>& mediaPlayerState,
-    const std::vector<avsCommon::utils::audioAnalyzer::AudioAnalyzerState>& audioAnalyzerState) {
-    ACSDK_DEBUG0(LX("onStateChanged").d("SpeechSynthesizerState", state));
+void DialogUXStateAggregator::onStateChanged(SpeechSynthesizerState state, const Context& context) {
+    ACSDK_DEBUG0(LX("onStateChanged").d("agentId", context.agentId).d("SpeechSynthesizerState", state));
     m_speechSynthesizerState = state;
-    m_executor.submit([this, state]() {
-        ACSDK_DEBUG0(LX("onStateChangedLambda").d("SpeechSynthesizerState", state));
+    m_currentAgentId = context.agentId;
+    m_executor.submit([this, context, state]() {
+        (void)context;
+        ACSDK_DEBUG0(LX("onStateChangedLambda").d("agentId", context.agentId).d("SpeechSynthesizerState", state));
         switch (state) {
             case SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING:
                 onActivityStarted();
@@ -242,10 +265,34 @@ void DialogUXStateAggregator::onConnectionStatusChanged(
     });
 }
 
-void DialogUXStateAggregator::onRequestProcessingStarted() {
-    ACSDK_DEBUG0(LX("onRequestProcessingStarted"));
+void DialogUXStateAggregator::onAgentAvailabilityStateChanged(
+    avsCommon::avs::AgentId::IdType agentId,
+    AvailabilityState status,
+    const std::string& reason) {
+    ACSDK_DEBUG(LX("onAgentAvailabilityStatusChanged")
+                    .d("agentId", agentId)
+                    .d("availabilityState", static_cast<int>(status))
+                    .d("reason", reason));
+    // Switch to idle state if current agent becomes unavailable
+    if ((agentId == m_currentAgentId) && (AvailabilityState::UNAVAILABLE == status)) {
+        m_executor.submit([this]() { executeSetState(DialogUXStateObserverInterface::DialogUXState::IDLE); });
+    }
+}
+
+void DialogUXStateAggregator::onRequestProcessingStarted(avsCommon::avs::AgentId::IdType agentId) {
+    ACSDK_DEBUG0(LX("onRequestProcessingStarted").d("agentId", agentId));
+    if (agentId != m_currentAgentId) {
+        ACSDK_ERROR(LX("onRequestProcessingStarted")
+                        .m("Unexpected event. Agent id mismatch")
+                        .d("currentAgentId", m_currentAgentId)
+                        .d("rpsAgentId", agentId));
+        return;
+    }
+
     m_executor.submit([this]() {
-        ACSDK_DEBUG0(LX("onRequestProcessingStartedLambda").d("currentState", m_currentState));
+        ACSDK_DEBUG0(LX("onRequestProcessingStartedLambda")
+                         .d("currentState", m_currentState)
+                         .d("currentAgentId", m_currentAgentId));
         // Stop the listening timer
         m_listeningTimeoutTimer.stop();
         switch (m_currentState) {
@@ -267,13 +314,22 @@ void DialogUXStateAggregator::onRequestProcessingStarted() {
             default:
                 ACSDK_ERROR(LX("onRequestProcessingStartedLambda")
                                 .d("reason", "invalidState")
+                                .d("currentAgentId", m_currentAgentId)
                                 .d("currentState", m_currentState));
         }
     });
 }
 
-void DialogUXStateAggregator::onRequestProcessingCompleted() {
-    ACSDK_DEBUG(LX("onRequestProcessingCompleted"));
+void DialogUXStateAggregator::onRequestProcessingCompleted(avsCommon::avs::AgentId::IdType agentId) {
+    ACSDK_DEBUG(LX("onRequestProcessingCompleted").d("agentId", agentId));
+    if (agentId != m_currentAgentId) {
+        ACSDK_ERROR(LX("onRequestProcessingCompleted")
+                        .m("Unexpected event. Agent id mismatch")
+                        .d("currentAgentId", m_currentAgentId)
+                        .d("rpcAgentId", agentId));
+        return;
+    }
+
     m_executor.submit([this]() {
         if (DialogUXStateObserverInterface::DialogUXState::LISTENING == m_currentState) {
             /// It is possible that the cloud sends RPC without sending RPS. In those situations, if we are in
@@ -288,7 +344,7 @@ void DialogUXStateAggregator::onRequestProcessingCompleted() {
 void DialogUXStateAggregator::notifyObserversOfState() {
     for (auto observer : m_observers) {
         if (observer) {
-            observer->onDialogUXStateChanged(m_currentState);
+            observer->onDialogUXStateChanged(m_currentAgentId, m_currentState);
         }
     }
 }
@@ -301,7 +357,7 @@ void DialogUXStateAggregator::transitionFromThinkingTimedOut() {
             ACSDK_DEBUG(LX("transitionFromThinkingTimedOut"));
             executeSetState(DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-            submitMetric(m_metricRecorder, THINKING_TIMEOUT_EXPIRES);
+            submitMetric(m_currentAgentId, m_metricRecorder, THINKING_TIMEOUT_EXPIRES);
         }
     });
 }
@@ -314,7 +370,7 @@ void DialogUXStateAggregator::transitionFromListeningTimedOut() {
             ACSDK_DEBUG(LX("transitionFromListeningTimedOut"));
             executeSetState(DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-            submitMetric(m_metricRecorder, LISTENING_TIMEOUT_EXPIRES);
+            submitMetric(m_currentAgentId, m_metricRecorder, LISTENING_TIMEOUT_EXPIRES);
         }
     });
 }
@@ -343,15 +399,22 @@ bool DialogUXStateAggregator::executeSetState(sdkInterfaces::DialogUXStateObserv
                      .d("to", newState)
                      .d("validTransition", validTransition ? "true" : "false"));
 
-    if (validTransition) {
-        m_listeningTimeoutTimer.stop();
-        m_thinkingTimeoutTimer.stop();
-        m_multiturnSpeakingToListeningTimer.stop();
-        m_currentState = newState;
-        notifyObserversOfState();
+    if (!validTransition) {
+        if (!m_continueWithInvalidTransition) {
+            return false;
+        } else {
+            ACSDK_DEBUG0(LX(__func__)
+                .m("validTransition is false but continue"));
+        }
     }
 
-    return validTransition;
+    m_listeningTimeoutTimer.stop();
+    m_thinkingTimeoutTimer.stop();
+    m_multiturnSpeakingToListeningTimer.stop();
+    m_currentState = newState;
+    notifyObserversOfState();
+
+    return true;
 }
 
 void DialogUXStateAggregator::executeTryEnterIdleState() {
diff --git a/AVSCommon/AVS/src/DirectiveRoutingRule.cpp b/AVSCommon/AVS/src/DirectiveRoutingRule.cpp
index 0b104c8a..7f9f06c5 100644
--- a/AVSCommon/AVS/src/DirectiveRoutingRule.cpp
+++ b/AVSCommon/AVS/src/DirectiveRoutingRule.cpp
@@ -35,32 +35,69 @@ static const std::string TAG("DirectiveRoutingRule");
 static const std::string WILDCARD = "*";
 
 DirectiveRoutingRule routingRulePerDirective(
+    avsCommon::avs::AgentId::IdType agentId,
     const std::string& endpointId,
     const utils::Optional<std::string>& instance,
     const std::string& nameSpace,
     const std::string& name) {
-    return DirectiveRoutingRule(nameSpace, name, endpointId, instance);
+    return DirectiveRoutingRule(nameSpace, name, agentId, endpointId, instance);
+}
+
+DirectiveRoutingRule routingRulePerDirectiveAnyAgent(
+    const std::string& endpointId,
+    const utils::Optional<std::string>& instance,
+    const std::string& nameSpace,
+    const std::string& name) {
+    return DirectiveRoutingRule(nameSpace, name, avsCommon::avs::AgentId::AGENT_ID_ALL, endpointId, instance);
 }
 
 DirectiveRoutingRule routingRulePerNamespace(
+    avsCommon::avs::AgentId::IdType agentId,
     const std::string& endpointId,
     const utils::Optional<std::string>& instance,
     const std::string& nameSpace) {
-    return DirectiveRoutingRule(nameSpace, WILDCARD, endpointId, instance);
+    return DirectiveRoutingRule(nameSpace, WILDCARD, agentId, endpointId, instance);
+}
+
+DirectiveRoutingRule routingRulePerNamespaceAnyAgent(
+    const std::string& endpointId,
+    const utils::Optional<std::string>& instance,
+    const std::string& nameSpace) {
+    return DirectiveRoutingRule(nameSpace, WILDCARD, avsCommon::avs::AgentId::AGENT_ID_ALL, endpointId, instance);
 }
 
 DirectiveRoutingRule routingRulePerInstance(
+    avsCommon::avs::AgentId::IdType agentId,
     const std::string& endpointId,
     const utils::Optional<std::string>& instance) {
-    return DirectiveRoutingRule(WILDCARD, WILDCARD, endpointId, instance);
+    return DirectiveRoutingRule(WILDCARD, WILDCARD, agentId, endpointId, instance);
+}
+
+DirectiveRoutingRule routingRulePerInstanceAnyAgent(
+    const std::string& endpointId,
+    const utils::Optional<std::string>& instance) {
+    return DirectiveRoutingRule(WILDCARD, WILDCARD, avsCommon::avs::AgentId::AGENT_ID_ALL, endpointId, instance);
+}
+
+DirectiveRoutingRule routingRulePerNamespaceAnyInstance(
+    avsCommon::avs::AgentId::IdType agentId,
+    const std::string& endpointId,
+    const std::string& nameSpace) {
+    return DirectiveRoutingRule(nameSpace, WILDCARD, agentId, endpointId, WILDCARD);
+}
+
+DirectiveRoutingRule routingRulePerNamespaceAnyInstanceAnyAgent(
+    const std::string& endpointId,
+    const std::string& nameSpace) {
+    return DirectiveRoutingRule(nameSpace, WILDCARD, avsCommon::avs::AgentId::AGENT_ID_ALL, endpointId, WILDCARD);
 }
 
-DirectiveRoutingRule routingRulePerNamespaceAnyInstance(const std::string& endpointId, const std::string& nameSpace) {
-    return DirectiveRoutingRule(nameSpace, WILDCARD, endpointId, WILDCARD);
+DirectiveRoutingRule routingRulePerEndpoint(avsCommon::avs::AgentId::IdType agentId, const std::string& endpointId) {
+    return DirectiveRoutingRule(WILDCARD, WILDCARD, agentId, endpointId, WILDCARD);
 }
 
-DirectiveRoutingRule routingRulePerEndpoint(const std::string& endpointId) {
-    return DirectiveRoutingRule(WILDCARD, WILDCARD, endpointId, WILDCARD);
+DirectiveRoutingRule routingRulePerEndpointAnyAgent(const std::string& endpointId) {
+    return DirectiveRoutingRule(WILDCARD, WILDCARD, avsCommon::avs::AgentId::AGENT_ID_ALL, endpointId, WILDCARD);
 }
 
 bool isDirectiveRoutingRuleValid(const DirectiveRoutingRule& rule) {
diff --git a/AVSCommon/AVS/src/EndpointResources.cpp b/AVSCommon/AVS/src/EndpointResources.cpp
new file mode 100644
index 00000000..f946b416
--- /dev/null
+++ b/AVSCommon/AVS/src/EndpointResources.cpp
@@ -0,0 +1,221 @@
+/*
+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <algorithm>
+
+#include <AVSCommon/AVS/EndpointResources.h>
+#include <AVSCommon/Utils/JSON/JSONGenerator.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+using namespace avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("EndpointResources");
+
+/**
+* Create a LogEntry using this file's TAG and the specified event string.
+*
+* @param The event string for this @c LogEntry.
+*/
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/// Maximum length of the friendly name
+static constexpr size_t MAX_FRIENDLY_NAME_LENGTH = 128;
+/// Maximum length of the manufacturer name
+static constexpr size_t MAX_MANUFACTURER_NAME_LENGTH = 128;
+/// Maximum length of the description
+static constexpr size_t MAX_DESCRIPTION_LENGTH = 128;
+
+EndpointResources::EndpointResources() : m_isValid{true} {
+}
+
+bool EndpointResources::Label::operator==(const EndpointResources::Label& rhs) const {
+    return value == rhs.value && locale.valueOr("") == rhs.locale.valueOr("");
+}
+
+EndpointResources& EndpointResources::addFriendlyNameWithAssetId(const std::string& assetId) {
+    if (assetId.length() == 0) {
+        ACSDK_ERROR(LX("addFriendlyNameWithAssetIdFailed").d("reason", "invalidAssetId"));
+        m_isValid = false;
+        return *this;
+    }
+
+    if (std::find(
+            m_friendlyNames.begin(),
+            m_friendlyNames.end(),
+            EndpointResources::Label(
+                    {Label::LabelType::ASSET, assetId, utils::Optional<avsCommon::avs::Locale>()})) != m_friendlyNames.end()) {
+        ACSDK_ERROR(LX("addFriendlyNameWithAssetIdFailed").d("reason", "duplicateAssetId").sensitive("assetId", assetId));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_friendlyNames.push_back({Label::LabelType::ASSET, assetId, utils::Optional<avsCommon::avs::Locale>()});
+
+    return *this;
+};
+
+EndpointResources& EndpointResources::addFriendlyNameWithText(
+        const std::string& text,
+        const avsCommon::avs::Locale& locale) {
+
+        if (text.length() == 0 || text.length() > MAX_FRIENDLY_NAME_LENGTH) {
+            ACSDK_ERROR(LX("addFriendlyNameWithTextFailed").d("reason", "invalidText"));
+            m_isValid = false;
+        }
+        if (locale.empty()) {
+            ACSDK_ERROR(LX("addFriendlyNameWithTextFailed").d("reason", "invalidLocale"));
+            m_isValid = false;
+        }
+        if (std::find(
+                m_friendlyNames.begin(),
+                m_friendlyNames.end(),
+                Label({Label::LabelType::TEXT, text, Optional<avsCommon::avs::Locale>(locale)})) !=
+                m_friendlyNames.end()) {
+            ACSDK_ERROR(LX("addFriendlyNameWithTextFailed")
+                                .d("reason", "duplicateText")
+                                .sensitive("text", text)
+                                .sensitive("locale", locale));
+            m_isValid = false;
+        }
+
+        m_friendlyNames.push_back({Label::LabelType::TEXT, text, Optional<avsCommon::avs::Locale>(locale)});
+
+    return *this;
+};
+
+EndpointResources& EndpointResources::addManufacturerNameWithAssetId(const std::string& assetId) {
+    if (assetId.length() == 0){
+        ACSDK_ERROR(LX("addManufacturerNameWithAssetIdFailed").d("reason", "invalidAssetId"));
+        m_isValid = false;
+        return *this;
+    }
+    if (m_manufacturerName.value.length() != 0){
+        ACSDK_ERROR(LX("addManufacturerNameWithAssetIdFailed").d("reason", "manufacturerNameAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_manufacturerName = {Label::LabelType::ASSET, assetId, Optional<avsCommon::avs::Locale>()};
+
+    return *this;
+};
+
+EndpointResources& EndpointResources::addManufacturerNameWithText(
+        const std::string& text,
+        const avsCommon::avs::Locale& locale) {
+
+    if (text.length() == 0 || text.length() > MAX_MANUFACTURER_NAME_LENGTH) {
+        ACSDK_ERROR(LX("addManufacturerNameWithTextFailed").d("reason", "invalidText"));
+        m_isValid = false;
+    }
+    if (locale.empty()) {
+        ACSDK_ERROR(LX("addManufacturerNameWithTextFailed").d("reason", "invalidLocale"));
+        m_isValid = false;
+    }
+    if (m_manufacturerName.value.length() != 0){
+        ACSDK_ERROR(LX("addManufacturerNameWithAssetIdFailed").d("reason", "manufacturerNameAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_manufacturerName = {Label::LabelType::TEXT, text, Optional<avsCommon::avs::Locale>(locale)};
+    return *this;
+};
+
+
+EndpointResources& EndpointResources::addDescriptionWithAssetId(const std::string& assetId) {
+    if (assetId.length() == 0){
+        ACSDK_ERROR(LX("addDescriptionWithAssetIdFailed").d("reason", "invalidAssetId"));
+        m_isValid = false;
+        return *this;
+    }
+    if (m_description.value.length() != 0){
+        ACSDK_ERROR(LX("addDescriptionWithAssetIdFailed").d("reason", "descriptionAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_description = {Label::LabelType::ASSET, assetId, Optional<avsCommon::avs::Locale>()};
+    return *this;
+};
+
+EndpointResources& EndpointResources::addDescriptionWithText(
+        const std::string& text,
+        const avsCommon::avs::Locale& locale) {
+
+    if (text.length() == 0 || text.length() > MAX_DESCRIPTION_LENGTH) {
+        ACSDK_ERROR(LX("addDescriptionWithTextFailed").d("reason", "invalidText"));
+        m_isValid = false;
+    }
+    if (locale.empty()) {
+        ACSDK_ERROR(LX("addDescriptionWithTextFailed").d("reason", "invalidLocale"));
+        m_isValid = false;
+    }
+    if (m_description.value.length() != 0){
+        ACSDK_ERROR(LX("addDescriptionWithAssetIdFailed").d("reason", "descriptionAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_description = {Label::LabelType::TEXT, text, Optional<avsCommon::avs::Locale>(locale)};
+    return *this;
+};
+
+bool EndpointResources::isValid() const {
+    return m_isValid && m_friendlyNames.size() > 0 && m_description.value.length() > 0
+                     && m_manufacturerName.value.length() > 0;
+};
+
+std::string EndpointResources::build() const {
+    if (!isValid()) {
+        ACSDK_ERROR(LX("buildFailed").d("reason", "invalidEndpointResources"));
+        return "";
+    }
+    json::JsonGenerator jsonGenerator;
+    std::vector<std::string> friendlyNames;
+    for (auto &friendlyName : m_friendlyNames){
+        friendlyNames.push_back(friendlyName.toJson());
+    }
+    jsonGenerator.addMembersArray("friendlyNames", friendlyNames);
+    jsonGenerator.addRawJsonMember("manufacturerName", m_manufacturerName.toJson());
+    jsonGenerator.addRawJsonMember("description", m_description.toJson());
+    return jsonGenerator.toString();
+};
+
+std::string EndpointResources::Label::toJson() const {
+    json::JsonGenerator scopeGenerator;
+    if (type == Label::LabelType::TEXT) {
+        scopeGenerator.addMember("@type", "text");
+        scopeGenerator.startObject("value");
+        scopeGenerator.addMember("text", value);
+        scopeGenerator.addMember("locale", locale.value());
+    } else if (type == Label::LabelType::ASSET) {
+        scopeGenerator.addMember("@type", "asset");
+        scopeGenerator.startObject("value");
+        scopeGenerator.addMember("assetId", value);
+    } else{
+        return "{}";
+    }
+    return scopeGenerator.toString();
+};
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/AVS/src/ExceptionEncounteredSender.cpp b/AVSCommon/AVS/src/ExceptionEncounteredSender.cpp
index 0806bdaf..f7795154 100644
--- a/AVSCommon/AVS/src/ExceptionEncounteredSender.cpp
+++ b/AVSCommon/AVS/src/ExceptionEncounteredSender.cpp
@@ -16,6 +16,7 @@
 #include <rapidjson/document.h>
 #include <rapidjson/stringbuffer.h>
 #include <rapidjson/writer.h>
+#include <AVSCommon/AVS/AgentId.h>
 #include <AVSCommon/AVS/AVSContext.h>
 #include <AVSCommon/AVS/MessageRequest.h>
 #include <AVSCommon/AVS/EventBuilder.h>
@@ -75,6 +76,14 @@ std::unique_ptr<ExceptionEncounteredSender> ExceptionEncounteredSender::create(
 }
 
 void ExceptionEncounteredSender::sendExceptionEncountered(
+    const std::string& unparsedDirective,
+    avs::ExceptionErrorType error,
+    const std::string& errorDescription) {
+    sendExceptionEncountered(avsCommon::avs::AgentId::getAlexaAgentId(), unparsedDirective, error, errorDescription);
+}
+
+void ExceptionEncounteredSender::sendExceptionEncountered(
+    avsCommon::avs::AgentId::IdType agentId,
     const std::string& unparsedDirective,
     avs::ExceptionErrorType error,
     const std::string& errorDescription) {
@@ -117,7 +126,7 @@ void ExceptionEncounteredSender::sendExceptionEncountered(
         ACSDK_ERROR(LX("sendExceptionEncounteredFailed").d("reason", "JsonEventEmpty"));
         return;
     }
-    std::shared_ptr<MessageRequest> request = std::make_shared<MessageRequest>(msgIdAndJsonEvent.second);
+    std::shared_ptr<MessageRequest> request = std::make_shared<MessageRequest>(agentId, msgIdAndJsonEvent.second);
     m_messageSender->sendMessage(request);
 }
 
diff --git a/AVSCommon/AVS/src/MessageRequest.cpp b/AVSCommon/AVS/src/MessageRequest.cpp
index f1e89005..fb9d140b 100644
--- a/AVSCommon/AVS/src/MessageRequest.cpp
+++ b/AVSCommon/AVS/src/MessageRequest.cpp
@@ -13,6 +13,7 @@
  * permissions and limitations under the License.
  */
 
+#include "AVSCommon/AVS/AgentId.h"
 #include "AVSCommon/AVS/MessageRequest.h"
 #include "AVSCommon/AVS/EditableMessageRequest.h"
 #include "AVSCommon/Utils/Logger/Logger.h"
@@ -42,9 +43,35 @@ MessageRequest::MessageRequest(
         m_isSerialized{true},
         m_uriPathExtension{uriPathExtension},
         m_streamMetricName{streamMetricName},
-        m_streamBytesThreshold{threshold} {
+        m_streamBytesThreshold{threshold},
+        m_agentId{avsCommon::avs::AgentId::getAlexaAgentId()} {
 }
 MessageRequest::MessageRequest(
+    avsCommon::avs::AgentId::IdType agentId,
+    const std::string& jsonContent,
+    const std::string& uriPathExtension,
+    const unsigned int threshold,
+    const std::string& streamMetricName) :
+        m_jsonContent{jsonContent},
+        m_isSerialized{true},
+        m_uriPathExtension{uriPathExtension},
+        m_streamMetricName{streamMetricName},
+        m_streamBytesThreshold{threshold},
+        m_agentId{agentId} {
+}
+MessageRequest::MessageRequest(
+    const std::string& jsonContent,
+    const unsigned int threshold,
+    const std::string& streamMetricName) :
+        m_jsonContent{jsonContent},
+        m_isSerialized{true},
+        m_uriPathExtension{""},
+        m_streamMetricName{streamMetricName},
+        m_streamBytesThreshold{threshold},
+        m_agentId{avsCommon::avs::AgentId::getAlexaAgentId()} {
+}
+MessageRequest::MessageRequest(
+    avsCommon::avs::AgentId::IdType agentId,
     const std::string& jsonContent,
     const unsigned int threshold,
     const std::string& streamMetricName) :
@@ -52,9 +79,28 @@ MessageRequest::MessageRequest(
         m_isSerialized{true},
         m_uriPathExtension{""},
         m_streamMetricName{streamMetricName},
-        m_streamBytesThreshold{threshold} {
+        m_streamBytesThreshold{threshold},
+        m_agentId{agentId} {
+}
+MessageRequest::MessageRequest(
+    const std::string& jsonContent,
+    bool isSerialized,
+    const std::string& uriPathExtension,
+    std::vector<std::pair<std::string, std::string>> headers,
+    MessageRequestResolveFunction resolver,
+    const unsigned int threshold,
+    const std::string& streamMetricName) :
+        m_jsonContent{jsonContent},
+        m_isSerialized{isSerialized},
+        m_uriPathExtension{uriPathExtension},
+        m_headers(std::move(headers)),
+        m_resolver{resolver},
+        m_streamMetricName{streamMetricName},
+        m_streamBytesThreshold{threshold},
+        m_agentId{avsCommon::avs::AgentId::getAlexaAgentId()} {
 }
 MessageRequest::MessageRequest(
+    avsCommon::avs::AgentId::IdType agentId,
     const std::string& jsonContent,
     bool isSerialized,
     const std::string& uriPathExtension,
@@ -68,7 +114,8 @@ MessageRequest::MessageRequest(
         m_headers(std::move(headers)),
         m_resolver{resolver},
         m_streamMetricName{streamMetricName},
-        m_streamBytesThreshold{threshold} {
+        m_streamBytesThreshold{threshold},
+        m_agentId{agentId} {
 }
 
 MessageRequest::MessageRequest(const MessageRequest& messageRequest) :
@@ -79,7 +126,8 @@ MessageRequest::MessageRequest(const MessageRequest& messageRequest) :
         m_headers{messageRequest.m_headers},
         m_resolver{messageRequest.m_resolver},
         m_streamMetricName{messageRequest.m_streamMetricName},
-        m_streamBytesThreshold{messageRequest.m_streamBytesThreshold} {
+        m_streamBytesThreshold{messageRequest.m_streamBytesThreshold},
+        m_agentId{messageRequest.m_agentId} {
 }
 
 MessageRequest::~MessageRequest() {
@@ -119,6 +167,10 @@ unsigned int MessageRequest::getStreamBytesThreshold() const {
     return m_streamBytesThreshold;
 }
 
+avsCommon::avs::AgentId::IdType MessageRequest::getAgentId() const {
+    return m_agentId;
+}
+
 std::shared_ptr<MessageRequest::NamedReader> MessageRequest::getAttachmentReader(size_t index) const {
     if (m_readers.size() <= index) {
         ACSDK_ERROR(LX("getAttachmentReaderFailed").d("reason", "index out of bound").d("index", index));
diff --git a/AVSCommon/AVS/src/NamespaceAndName.cpp b/AVSCommon/AVS/src/NamespaceAndName.cpp
index 66f74c4d..c849897a 100644
--- a/AVSCommon/AVS/src/NamespaceAndName.cpp
+++ b/AVSCommon/AVS/src/NamespaceAndName.cpp
@@ -26,6 +26,13 @@ NamespaceAndName::NamespaceAndName(const std::string& nameSpaceIn, const std::st
         CapabilityTag{nameSpaceIn, nameIn, ""} {
 }
 
+NamespaceAndName::NamespaceAndName(
+    const std::string& nameSpaceIn,
+    const std::string& nameIn,
+    avsCommon::avs::AgentId::IdType agentId) :
+        CapabilityTag{nameSpaceIn, nameIn, agentId, ""} {
+}
+
 NamespaceAndName::NamespaceAndName() : CapabilityTag{"", "", ""} {
 }
 
diff --git a/AVSCommon/AVS/src/WaitableMessageRequest.cpp b/AVSCommon/AVS/src/WaitableMessageRequest.cpp
index 73ab9ab4..5115e2a8 100644
--- a/AVSCommon/AVS/src/WaitableMessageRequest.cpp
+++ b/AVSCommon/AVS/src/WaitableMessageRequest.cpp
@@ -43,6 +43,13 @@ WaitableMessageRequest::WaitableMessageRequest(const std::string& jsonContent) :
         m_isRequestShuttingDown{false} {
 }
 
+WaitableMessageRequest::WaitableMessageRequest(AgentId::IdType agentId, const std::string& jsonContent) :
+        MessageRequest{agentId, jsonContent},
+        m_sendMessageStatus{MessageRequestObserverInterface::Status::TIMEDOUT},
+        m_responseReceived{false},
+        m_isRequestShuttingDown{false} {
+}
+
 void WaitableMessageRequest::sendCompleted(
     alexaClientSDK::avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status sendMessageStatus) {
     MessageRequest::sendCompleted(sendMessageStatus);
diff --git a/AVSCommon/AVS/test/CMakeLists.txt b/AVSCommon/AVS/test/CMakeLists.txt
index e5f5f557..a798fb88 100644
--- a/AVSCommon/AVS/test/CMakeLists.txt
+++ b/AVSCommon/AVS/test/CMakeLists.txt
@@ -3,7 +3,7 @@ set(INCLUDE_PATH
     "${AVSCommon_INCLUDE_DIRS}"
     "${AVSCommon_SOURCE_DIR}/AVS/test"
     "${MetricRecorder_INCLUDE_DIRS}")
-discover_unit_tests("${INCLUDE_PATH}" "AVSCommon;AttachmentCommonTestLib;SDKInterfacesTests")
+discover_unit_tests("${INCLUDE_PATH}" "AVSCommon;acsdkDUXSA;AttachmentCommonTestLib;SDKInterfacesTests")
 
 if (BUILD_TESTING)
     add_library(AVSCommonTestLib INTERFACE)
diff --git a/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp b/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp
index 267c2ba5..959aa12f 100644
--- a/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp
+++ b/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp
@@ -25,6 +25,7 @@ namespace test {
 
 using namespace avsCommon::avs;
 using namespace avsCommon::sdkInterfaces;
+using namespace multiAgentInterface::connection;
 using namespace std;
 
 /// Long time out for observers to wait for the state change callback (we should not reach this).
@@ -42,23 +43,32 @@ static const auto TRANSITION_TIMEOUT = std::chrono::milliseconds(300);
 /// Dummy value for a media player source id
 static const avsCommon::utils::mediaPlayer::MediaPlayerInterface::SourceId TEST_SOURCE_ID = -1;
 
+static const std::string TEST_REASON = "TEST_REASON";
+
 /// A test observer that mocks out the DialogUXStateObserverInterface##onDialogUXStateChanged() call.
 class TestObserver : public DialogUXStateObserverInterface {
 public:
     /**
      * Constructor.
      */
-    TestObserver() : m_state{DialogUXStateObserverInterface::DialogUXState::IDLE}, m_changeOccurred{false} {
+    TestObserver() :
+            m_state{DialogUXStateObserverInterface::DialogUXState::IDLE},
+            m_changeOccurred{false},
+            m_agentId{avsCommon::avs::AgentId::getAlexaAgentId()} {
     }
 
     /**
      * Implementation of the DialogUXStateObserverInterface##onDialogUXStateChanged() callback.
      *
+     * @param agentId The agent id for the state change.
      * @param newState The new UX state of the observer.
      */
-    void onDialogUXStateChanged(DialogUXStateObserverInterface::DialogUXState newState) override {
+    void onDialogUXStateChanged(
+        avsCommon::avs::AgentId::IdType agentId,
+        DialogUXStateObserverInterface::DialogUXState newState) override {
         std::unique_lock<std::mutex> lock{m_mutex};
         m_state = newState;
+        m_agentId = agentId;
         m_changeOccurred = true;
         m_UXChanged.notify_one();
     }
@@ -85,6 +95,15 @@ public:
         return m_state;
     }
 
+    /**
+     * Gets the agent id stored by the observer
+     *
+     * @return Returns the agent id tracked by the observer
+     */
+    avsCommon::avs::AgentId::IdType getAgentId() {
+        return m_agentId;
+    }
+
 private:
     /// The UX state of the observer.
     DialogUXStateObserverInterface::DialogUXState m_state;
@@ -97,6 +116,9 @@ private:
 
     /// A boolean flag so that we can re-use the observer even after a callback has occurred.
     bool m_changeOccurred;
+
+    /// The current agent id tracked by the observer.
+    avsCommon::avs::AgentId::IdType m_agentId;
 };
 
 /// Manages testing state changes
@@ -190,7 +212,8 @@ TEST_F(DialogUXAggregatorTest, test_removeObserver) {
     assertStateChange(m_anotherTestObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
     m_aggregator->removeObserver(m_anotherTestObserver);
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
     assertNoStateChange(m_anotherTestObserver);
 }
@@ -199,7 +222,8 @@ TEST_F(DialogUXAggregatorTest, test_removeObserver) {
 TEST_F(DialogUXAggregatorTest, test_aipIdleLeadsToIdleState) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::IDLE);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::IDLE);
     assertNoStateChange(m_testObserver);
 }
 
@@ -207,7 +231,8 @@ TEST_F(DialogUXAggregatorTest, test_aipIdleLeadsToIdleState) {
 TEST_F(DialogUXAggregatorTest, test_aipRecognizeLeadsToListeningState) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 }
 
@@ -215,10 +240,12 @@ TEST_F(DialogUXAggregatorTest, test_aipRecognizeLeadsToListeningState) {
 TEST_F(DialogUXAggregatorTest, test_aipIdleLeadsToIdle) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::IDLE);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::IDLE);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 }
 
@@ -226,7 +253,8 @@ TEST_F(DialogUXAggregatorTest, test_aipIdleLeadsToIdle) {
 TEST_F(DialogUXAggregatorTest, test_aipExpectingSpeechLeadsToListeningState) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::EXPECTING_SPEECH);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::EXPECTING_SPEECH);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::EXPECTING);
 }
 
@@ -234,7 +262,7 @@ TEST_F(DialogUXAggregatorTest, test_aipExpectingSpeechLeadsToListeningState) {
 TEST_F(DialogUXAggregatorTest, test_requestProcessingStartedLeadsToThinkingState) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onRequestProcessingStarted();
+    m_aggregator->onRequestProcessingStarted(avsCommon::avs::AgentId::getAlexaAgentId());
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 }
 
@@ -247,8 +275,10 @@ TEST_F(DialogUXAggregatorTest, test_listeningGoesToIdleAfterTimeout) {
 
     assertStateChange(m_anotherTestObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    anotherAggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
-    anotherAggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    anotherAggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    anotherAggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::BUSY);
     assertStateChange(m_anotherTestObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
     assertStateChange(m_anotherTestObserver, DialogUXStateObserverInterface::DialogUXState::IDLE, TRANSITION_TIMEOUT);
@@ -262,10 +292,11 @@ TEST_F(DialogUXAggregatorTest, test_thinkingGoesToIdleAfterTimeout) {
     anotherAggregator->addObserver(m_anotherTestObserver);
     assertStateChange(m_anotherTestObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    anotherAggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    anotherAggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_anotherTestObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
-    anotherAggregator->onRequestProcessingStarted();
+    anotherAggregator->onRequestProcessingStarted(avsCommon::avs::AgentId::getAlexaAgentId());
     assertStateChange(m_anotherTestObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
     assertStateChange(m_anotherTestObserver, DialogUXStateObserverInterface::DialogUXState::IDLE, TRANSITION_TIMEOUT);
@@ -275,13 +306,14 @@ TEST_F(DialogUXAggregatorTest, test_thinkingGoesToIdleAfterTimeout) {
 TEST_F(DialogUXAggregatorTest, test_thinkingThenReceiveGoesToIdleAfterLongTimeout) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
-    m_aggregator->onRequestProcessingStarted();
+    m_aggregator->onRequestProcessingStarted(avsCommon::avs::AgentId::getAlexaAgentId());
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->onRequestProcessingCompleted();
+    m_aggregator->onRequestProcessingCompleted(avsCommon::avs::AgentId::getAlexaAgentId());
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE, TRANSITION_TIMEOUT);
 }
 
@@ -292,19 +324,18 @@ TEST_F(DialogUXAggregatorTest, test_thinkingThenReceiveGoesToIdleAfterLongTimeou
 TEST_F(DialogUXAggregatorTest, test_listeningThenRequestProcessingCompletedThenSpeakGoesToSpeakButNotIdle) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
-    m_aggregator->onRequestProcessingStarted();
+    m_aggregator->onRequestProcessingStarted(avsCommon::avs::AgentId::getAlexaAgentId());
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->onRequestProcessingCompleted();
+    m_aggregator->onRequestProcessingCompleted(avsCommon::avs::AgentId::getAlexaAgentId());
 
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING,
-        TEST_SOURCE_ID,
-        m_testMediaPlayerState,
-        m_testAudioAnalyzerState);
+        {TEST_SOURCE_ID, m_testMediaPlayerState, m_testAudioAnalyzerState, avsCommon::avs::AgentId::getAlexaAgentId()});
 
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::SPEAKING);
 
@@ -315,26 +346,24 @@ TEST_F(DialogUXAggregatorTest, test_listeningThenRequestProcessingCompletedThenS
 TEST_F(DialogUXAggregatorTest, test_speakingAndRecognizingFinishedGoesToIdle) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
-    m_aggregator->onRequestProcessingStarted();
+    m_aggregator->onRequestProcessingStarted(avsCommon::avs::AgentId::getAlexaAgentId());
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->onRequestProcessingCompleted();
+    m_aggregator->onRequestProcessingCompleted(avsCommon::avs::AgentId::getAlexaAgentId());
 
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING,
-        TEST_SOURCE_ID,
-        m_testMediaPlayerState,
-        m_testAudioAnalyzerState);
+        {TEST_SOURCE_ID, m_testMediaPlayerState, m_testAudioAnalyzerState, avsCommon::avs::AgentId::getAlexaAgentId()});
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::SPEAKING);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::IDLE);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::IDLE);
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED,
-        TEST_SOURCE_ID,
-        m_testMediaPlayerState,
-        m_testAudioAnalyzerState);
+        {TEST_SOURCE_ID, m_testMediaPlayerState, m_testAudioAnalyzerState, avsCommon::avs::AgentId::getAlexaAgentId()});
 
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 }
@@ -344,37 +373,31 @@ TEST_F(DialogUXAggregatorTest, test_nonIdleObservantsPreventsIdle) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
     // AIP is active, SS is not. Expected: non idle
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED,
-        TEST_SOURCE_ID,
-        m_testMediaPlayerState,
-        m_testAudioAnalyzerState);
+        {TEST_SOURCE_ID, m_testMediaPlayerState, m_testAudioAnalyzerState, avsCommon::avs::AgentId::getAlexaAgentId()});
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
     // Both AIP and SS are inactive. Expected: idle
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::IDLE);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::IDLE);
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED,
-        TEST_SOURCE_ID,
-        m_testMediaPlayerState,
-        m_testAudioAnalyzerState);
+        {TEST_SOURCE_ID, m_testMediaPlayerState, m_testAudioAnalyzerState, avsCommon::avs::AgentId::getAlexaAgentId()});
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
     // AIP is inactive, SS is active. Expected: non-idle
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING,
-        TEST_SOURCE_ID,
-        m_testMediaPlayerState,
-        m_testAudioAnalyzerState);
+        {TEST_SOURCE_ID, m_testMediaPlayerState, m_testAudioAnalyzerState, avsCommon::avs::AgentId::getAlexaAgentId()});
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::SPEAKING);
 
     // AIP is inactive, SS is inactive: Expected: idle
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED,
-        TEST_SOURCE_ID,
-        m_testMediaPlayerState,
-        m_testAudioAnalyzerState);
+        {TEST_SOURCE_ID, m_testMediaPlayerState, m_testAudioAnalyzerState, avsCommon::avs::AgentId::getAlexaAgentId()});
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 }
 
@@ -382,26 +405,23 @@ TEST_F(DialogUXAggregatorTest, test_nonIdleObservantsPreventsIdle) {
 TEST_F(DialogUXAggregatorTest, test_speakingFinishedDoesNotGoesToIdleImmediately) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
-    m_aggregator->onRequestProcessingStarted();
+    m_aggregator->onRequestProcessingStarted(avsCommon::avs::AgentId::getAlexaAgentId());
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->onRequestProcessingCompleted();
+    m_aggregator->onRequestProcessingCompleted(avsCommon::avs::AgentId::getAlexaAgentId());
 
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING,
-        TEST_SOURCE_ID,
-        m_testMediaPlayerState,
-        m_testAudioAnalyzerState);
+        {TEST_SOURCE_ID, m_testMediaPlayerState, m_testAudioAnalyzerState, avsCommon::avs::AgentId::getAlexaAgentId()});
 
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::SPEAKING);
 
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED,
-        TEST_SOURCE_ID,
-        m_testMediaPlayerState,
-        m_testAudioAnalyzerState);
+        {TEST_SOURCE_ID, m_testMediaPlayerState, m_testAudioAnalyzerState, avsCommon::avs::AgentId::getAlexaAgentId()});
 
     assertNoStateChange(m_testObserver);
 }
@@ -410,19 +430,17 @@ TEST_F(DialogUXAggregatorTest, test_speakingFinishedDoesNotGoesToIdleImmediately
 TEST_F(DialogUXAggregatorTest, test_simpleReceiveDoesNothing) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onRequestProcessingStarted();
+    m_aggregator->onRequestProcessingStarted(avsCommon::avs::AgentId::getAlexaAgentId());
 
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING,
-        TEST_SOURCE_ID,
-        m_testMediaPlayerState,
-        m_testAudioAnalyzerState);
+        {TEST_SOURCE_ID, m_testMediaPlayerState, m_testAudioAnalyzerState, avsCommon::avs::AgentId::getAlexaAgentId()});
 
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::SPEAKING);
 
-    m_aggregator->onRequestProcessingCompleted();
+    m_aggregator->onRequestProcessingCompleted(avsCommon::avs::AgentId::getAlexaAgentId());
 
     assertNoStateChange(m_testObserver);
 }
@@ -432,18 +450,17 @@ TEST_F(DialogUXAggregatorTest, test_simpleReceiveDoesNothing) {
 TEST_F(DialogUXAggregatorTest, test_thinkingThenReceiveRemainsInThinkingIfSpeechSynthesizerReportsGainingFocus) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
-    m_aggregator->onRequestProcessingStarted();
+    m_aggregator->onRequestProcessingStarted(avsCommon::avs::AgentId::getAlexaAgentId());
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->onRequestProcessingCompleted();
+    m_aggregator->onRequestProcessingCompleted(avsCommon::avs::AgentId::getAlexaAgentId());
 
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::GAINING_FOCUS,
-        TEST_SOURCE_ID,
-        m_testMediaPlayerState,
-        m_testAudioAnalyzerState);
+        {TEST_SOURCE_ID, m_testMediaPlayerState, m_testAudioAnalyzerState, avsCommon::avs::AgentId::getAlexaAgentId()});
 
     // Make sure after SpeechSynthesizer reports GAINING_FOCUS, that it would stay in THINKING state
     assertNoStateChange(m_testObserver, TRANSITION_TIMEOUT);
@@ -452,38 +469,37 @@ TEST_F(DialogUXAggregatorTest, test_thinkingThenReceiveRemainsInThinkingIfSpeech
 /// Tests that only certain states are allowed to transition into THINKING from an RPS.
 TEST_F(DialogUXAggregatorTest, test_validStatesForRPSToThinking) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
-    m_aggregator->onRequestProcessingStarted();
+    m_aggregator->onRequestProcessingStarted(avsCommon::avs::AgentId::getAlexaAgentId());
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->onRequestProcessingCompleted();
+    m_aggregator->onRequestProcessingCompleted(avsCommon::avs::AgentId::getAlexaAgentId());
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
-    m_aggregator->onRequestProcessingStarted();
+    m_aggregator->onRequestProcessingStarted(avsCommon::avs::AgentId::getAlexaAgentId());
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->onRequestProcessingCompleted();
+    m_aggregator->onRequestProcessingCompleted(avsCommon::avs::AgentId::getAlexaAgentId());
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING,
-        TEST_SOURCE_ID,
-        m_testMediaPlayerState,
-        m_testAudioAnalyzerState);
+        {TEST_SOURCE_ID, m_testMediaPlayerState, m_testAudioAnalyzerState, avsCommon::avs::AgentId::getAlexaAgentId()});
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::SPEAKING);
-    m_aggregator->onRequestProcessingStarted();
+    m_aggregator->onRequestProcessingStarted(avsCommon::avs::AgentId::getAlexaAgentId());
     assertNoStateChange(m_testObserver);
 
     // Reset to IDLE
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::IDLE);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::IDLE);
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED,
-        TEST_SOURCE_ID,
-        m_testMediaPlayerState,
-        m_testAudioAnalyzerState);
+        {TEST_SOURCE_ID, m_testMediaPlayerState, m_testAudioAnalyzerState, avsCommon::avs::AgentId::getAlexaAgentId()});
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::EXPECTING_SPEECH);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::EXPECTING_SPEECH);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::EXPECTING);
-    m_aggregator->onRequestProcessingStarted();
+    m_aggregator->onRequestProcessingStarted(avsCommon::avs::AgentId::getAlexaAgentId());
     assertNoStateChange(m_testObserver);
 }
 
@@ -491,11 +507,12 @@ TEST_F(DialogUXAggregatorTest, test_validStatesForRPSToThinking) {
 TEST_F(DialogUXAggregatorTest, test_receiveThenRPCTransitionsOutOfThinking) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
-    m_aggregator->onRequestProcessingStarted();
-    m_aggregator->onRequestProcessingCompleted();
+    m_aggregator->onRequestProcessingStarted(avsCommon::avs::AgentId::getAlexaAgentId());
+    m_aggregator->onRequestProcessingCompleted(avsCommon::avs::AgentId::getAlexaAgentId());
 
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
@@ -507,13 +524,15 @@ TEST_F(DialogUXAggregatorTest, test_receiveThenRPCTransitionsOutOfThinking) {
 TEST_F(DialogUXAggregatorTest, test_receiveAIPBusyAfterRPS) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
-    m_aggregator->onRequestProcessingStarted();
+    m_aggregator->onRequestProcessingStarted(avsCommon::avs::AgentId::getAlexaAgentId());
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::BUSY);
     assertNoStateChange(m_testObserver);
 }
 
@@ -522,20 +541,23 @@ TEST_F(DialogUXAggregatorTest, test_receiveAIPBusyAfterRPS) {
 TEST_F(DialogUXAggregatorTest, test_receiveRPCwithoutRPS) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::BUSY);
     assertNoStateChange(m_testObserver);
 
-    m_aggregator->onRequestProcessingCompleted();
+    m_aggregator->onRequestProcessingCompleted(avsCommon::avs::AgentId::getAlexaAgentId());
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 }
 
 /// Test that the state is set to idle when there is NOT an active connection
 TEST_F(DialogUXAggregatorTest, test_setToIdleIfNoConnectionAvailable) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
     DialogUXStateAggregator::EngineConnectionStatus pending{ENGINE_TYPE_ALEXA_VOICE_SERVICES,
@@ -555,7 +577,8 @@ TEST_F(DialogUXAggregatorTest, test_setToIdleIfNoConnectionAvailable) {
 /// Test that don't change the state is if THERE IS an active connection
 TEST_F(DialogUXAggregatorTest, test_doNotSetToIdleIfConnectionIsAvailable) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
     DialogUXStateAggregator::EngineConnectionStatus connected{ENGINE_TYPE_ALEXA_VOICE_SERVICES,
@@ -579,7 +602,8 @@ TEST_F(DialogUXAggregatorTest, test_doNotSetToIdleIfConnectionIsAvailable) {
 /// Test that don't change the state is if THERE IS an active connection for a different engine typ
 TEST_F(DialogUXAggregatorTest, test_doNotSetToIdleIfConnectionIsAvailableForDifferentEngine) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
     DialogUXStateAggregator::EngineConnectionStatus connected{OTHER_ENGINE_TYPE,
@@ -600,6 +624,99 @@ TEST_F(DialogUXAggregatorTest, test_doNotSetToIdleIfConnectionIsAvailableForDiff
     assertNoStateChange(m_testObserver);
 }
 
+/// Test that if we are LISTENING and RequestProcessingCompleted is received with an unexpected agent id, do nothing.
+TEST_F(DialogUXAggregatorTest, test_receiveRPCwithIncorrectAgentId) {
+    avsCommon::avs::AgentId::IdType anotherAgentId = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
+
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
+
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::BUSY);
+    assertNoStateChange(m_testObserver);
+
+    m_aggregator->onRequestProcessingCompleted(anotherAgentId);
+    assertNoStateChange(m_testObserver);
+}
+
+/// Test that if we are LISTENING and RequestProcessingStarted is received with an unexpected agent id, do nothing.
+TEST_F(DialogUXAggregatorTest, test_receiveRPSwithIncorrectAgentId) {
+    avsCommon::avs::AgentId::IdType anotherAgentId = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
+
+    m_aggregator->onRequestProcessingStarted(anotherAgentId);
+    assertNoStateChange(m_testObserver);
+}
+
+/// Test that we receive the current agent id notification for DialogUXState updates.
+TEST_F(DialogUXAggregatorTest, test_receiveCorrectAgentIdForDialogUXStateUpdates) {
+    avsCommon::avs::AgentId::IdType firstAgentId = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+    avsCommon::avs::AgentId::IdType secondAgentId = avsCommon::avs::AgentId::getAlexaAgentId() + 2;
+    avsCommon::avs::AgentId::IdType thirdAgentId = avsCommon::avs::AgentId::getAlexaAgentId() + 3;
+
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
+
+    // Verify agentId notification for AIP onStateChanged
+    m_aggregator->onStateChanged(firstAgentId, AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
+    ASSERT_EQ(firstAgentId, m_testObserver->getAgentId());
+
+    // Verify agentId notification for InteractionModel onRequestProcessingStarted
+    m_aggregator->onRequestProcessingStarted(firstAgentId);
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
+    ASSERT_EQ(firstAgentId, m_testObserver->getAgentId());
+
+    // Verify agentId notification for InteractionModel onRequestProcessingCompleted
+    m_aggregator->onRequestProcessingCompleted(firstAgentId);
+    ASSERT_EQ(firstAgentId, m_testObserver->getAgentId());
+
+    // Verify agentId notification for SpeechSynthesizer onStateChanged
+    m_aggregator->onStateChanged(
+        SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING,
+        {TEST_SOURCE_ID, m_testMediaPlayerState, m_testAudioAnalyzerState, secondAgentId});
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::SPEAKING);
+    ASSERT_EQ(secondAgentId, m_testObserver->getAgentId());
+
+    // Return DialogUXStateAggregator to IDLE state
+    m_aggregator->onStateChanged(secondAgentId, AudioInputProcessorObserverInterface::State::IDLE);
+    m_aggregator->onStateChanged(
+        SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED,
+        {TEST_SOURCE_ID, m_testMediaPlayerState, m_testAudioAnalyzerState, secondAgentId});
+
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
+    ASSERT_EQ(secondAgentId, m_testObserver->getAgentId());
+
+    // Verify agentId notification for onAgentAvailabilityStateChanged
+    m_aggregator->onStateChanged(thirdAgentId, AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
+
+    m_aggregator->onAgentAvailabilityStateChanged(
+        thirdAgentId, AgentConnectionObserverInterface::AvailabilityState::UNAVAILABLE, TEST_REASON);
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
+    ASSERT_EQ(thirdAgentId, m_testObserver->getAgentId());
+}
+
+/// Test that if we are LISTENING and onAgentAvailabilityStateChanged is received with an unexpected agent id,
+/// do nothing.
+TEST_F(DialogUXAggregatorTest, test_receiveOnAgentAvailabilityStateChangedwithIncorrectAgentId) {
+    avsCommon::avs::AgentId::IdType anotherAgentId = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
+    m_aggregator->onStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(), AudioInputProcessorObserverInterface::State::RECOGNIZING);
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
+
+    m_aggregator->onAgentAvailabilityStateChanged(
+        anotherAgentId, AgentConnectionObserverInterface::AvailabilityState::UNAVAILABLE, TEST_REASON);
+    assertNoStateChange(m_testObserver);
+}
+
 }  // namespace test
 }  // namespace avsCommon
 }  // namespace alexaClientSDK
diff --git a/AVSCommon/AVS/test/EditableMessageRequestTest.cpp b/AVSCommon/AVS/test/EditableMessageRequestTest.cpp
index c7250a34..c1fbc135 100644
--- a/AVSCommon/AVS/test/EditableMessageRequestTest.cpp
+++ b/AVSCommon/AVS/test/EditableMessageRequestTest.cpp
@@ -44,7 +44,7 @@ class EditableMessageRequestTest : public ::testing::Test {};
 
 TEST_F(EditableMessageRequestTest, test_setJsonContent) {
     std::string jsonContent = "{\"name\": \"value\"}";
-    MessageRequest sourceRequest("{}", true, "", {});
+    MessageRequest sourceRequest("{}", true);
     EditableMessageRequest messageRequest = sourceRequest;
 
     EXPECT_NE(jsonContent, messageRequest.getJsonContent());
@@ -56,7 +56,7 @@ TEST_F(EditableMessageRequestTest, test_setAttachmentReaders) {
     std::shared_ptr<attachment::AttachmentReader> reader = std::make_shared<MockAttachmentReader>();
     std::vector<std::shared_ptr<MessageRequest::NamedReader>> attachmentReaders{
         std::make_shared<MessageRequest::NamedReader>("Test", reader)};
-    MessageRequest sourceRequest("{}", true, "", {});
+    MessageRequest sourceRequest("{}", true);
     EditableMessageRequest messageRequest = sourceRequest;
 
     EXPECT_EQ(0, messageRequest.attachmentReadersCount());
@@ -73,7 +73,7 @@ TEST_F(EditableMessageRequestTest, test_setAttachmentReadersFails) {
     auto validNamedReader = std::make_shared<MessageRequest::NamedReader>("Test", reader);
     std::vector<std::shared_ptr<MessageRequest::NamedReader>> attachmentReaders{
         validNamedReader, nullptr, std::make_shared<MessageRequest::NamedReader>("Test2", nullptr)};
-    MessageRequest sourceRequest("{}", true, "", {});
+    MessageRequest sourceRequest("{}", true);
     EditableMessageRequest messageRequest = sourceRequest;
 
     EXPECT_EQ(0, messageRequest.attachmentReadersCount());
@@ -86,7 +86,7 @@ TEST_F(EditableMessageRequestTest, test_setAttachmentReadersFails) {
 }
 
 TEST_F(EditableMessageRequestTest, test_setMessageRequestResolveFunction) {
-    MessageRequest sourceRequest("{}", true, "", {});
+    MessageRequest sourceRequest("{}", true);
     EditableMessageRequest request = sourceRequest;
     MockFunction<bool(const std::shared_ptr<EditableMessageRequest>&, std::string)> mockResolverFunc;
 
diff --git a/AVSCommon/AVS/test/MessageRequestTest.cpp b/AVSCommon/AVS/test/MessageRequestTest.cpp
index 1f5ddd8c..a32aaf33 100644
--- a/AVSCommon/AVS/test/MessageRequestTest.cpp
+++ b/AVSCommon/AVS/test/MessageRequestTest.cpp
@@ -69,6 +69,7 @@ TEST_F(MessageRequestTest, test_copyConstructor) {
     EXPECT_FALSE(copiedReq.isResolved());
     EXPECT_EQ(1, copiedReq.attachmentReadersCount());
     EXPECT_EQ(request.getAttachmentReader(0), copiedReq.getAttachmentReader(0));
+    EXPECT_EQ(avsCommon::avs::AgentId::getAlexaAgentId(), copiedReq.getAgentId());
 
     // Verify that observers are not copied in copy constructor.
     EXPECT_CALL(*mockMessageRequestObserver, onSendCompleted(_)).Times(1);
@@ -87,6 +88,25 @@ TEST_F(MessageRequestTest, test_extraHeaders) {
     EXPECT_EQ(expected, actual);
 }
 
+/**
+ * Test functionality for agentId
+ */
+TEST_F(MessageRequestTest, test_default_agent) {
+    const auto expected = avsCommon::avs::AgentId::getAlexaAgentId();
+    MessageRequest messageRequest(expected, "{}", true, "");
+    auto actual = messageRequest.getAgentId();
+
+    EXPECT_EQ(expected, actual);
+}
+
+TEST_F(MessageRequestTest, test_custom_agent) {
+    const auto expected = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+    MessageRequest messageRequest(expected, "{}", true, "");
+    auto actual = messageRequest.getAgentId();
+
+    EXPECT_EQ(expected, actual);
+}
+
 TEST_F(MessageRequestTest, test_isResolved) {
     MessageRequest resolvedReq("{}", true, "");
     EXPECT_TRUE(resolvedReq.isResolved());
diff --git a/AVSCommon/AVS/test/NamespaceAndNameTest.cpp b/AVSCommon/AVS/test/NamespaceAndNameTest.cpp
index e7efdace..9b375de4 100644
--- a/AVSCommon/AVS/test/NamespaceAndNameTest.cpp
+++ b/AVSCommon/AVS/test/NamespaceAndNameTest.cpp
@@ -45,12 +45,14 @@ static const std::string NAME_SET_VOLUME("SetVolume");
 class NamespaceAndNameTest : public ::testing::Test {};
 
 /**
- * Invoke default constructor.  Expect @c nameSpace and @c name properties are both empty strings.
+ * Invoke default constructor.  Expect @c nameSpace and @c name properties are both empty strings and AgentId to be
+ * ALEXA.
  */
 TEST_F(NamespaceAndNameTest, test_defaultConstructor) {
     NamespaceAndName instance;
     ASSERT_TRUE(instance.nameSpace.empty());
     ASSERT_TRUE(instance.name.empty());
+    ASSERT_EQ(instance.getAgentId(), avsCommon::avs::AgentId::getAlexaAgentId());
 }
 
 /**
@@ -60,20 +62,34 @@ TEST_F(NamespaceAndNameTest, test_constructorWithValues) {
     NamespaceAndName instance(NAMESPACE_SPEECH_RECOGNIZER, NAME_RECOGNIZE);
     ASSERT_EQ(instance.nameSpace, NAMESPACE_SPEECH_RECOGNIZER);
     ASSERT_EQ(instance.name, NAME_RECOGNIZE);
+    ASSERT_EQ(instance.getAgentId(), avsCommon::avs::AgentId::getAlexaAgentId());
+
+    const auto someOtherAgent = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+    NamespaceAndName instanceWithOtherAgent(NAMESPACE_SPEECH_RECOGNIZER, NAME_RECOGNIZE, someOtherAgent);
+    ASSERT_EQ(instanceWithOtherAgent.nameSpace, NAMESPACE_SPEECH_RECOGNIZER);
+    ASSERT_EQ(instanceWithOtherAgent.name, NAME_RECOGNIZE);
+    ASSERT_EQ(instanceWithOtherAgent.getAgentId(), someOtherAgent);
 }
 
 /**
  * Create an @c std::unordered_map using NamespaceAndName values as keys. Expect that the keys map to distinct values.
  */
 TEST_F(NamespaceAndNameTest, test_inUnorderedMap) {
+    const auto someOtherAgent = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
     std::unordered_map<NamespaceAndName, int> testMap;
     NamespaceAndName key1(NAMESPACE_SPEECH_RECOGNIZER, NAME_RECOGNIZE);
     NamespaceAndName key2(NAMESPACE_SPEAKER, NAME_SET_VOLUME);
+    NamespaceAndName key3(NAMESPACE_SPEECH_RECOGNIZER, NAME_RECOGNIZE, someOtherAgent);
+
     testMap[key1] = 1;
     testMap[key2] = 2;
+    testMap[key3] = 3;
     ASSERT_EQ(testMap[key1], 1);
     ASSERT_EQ(testMap[key2], 2);
+    ASSERT_EQ(testMap[key3], 3);
     ASSERT_NE(testMap[key1], testMap[key2]);
+    ASSERT_NE(testMap[key1], testMap[key3]);
+    ASSERT_NE(testMap[key2], testMap[key3]);
 }
 
 }  // namespace test
diff --git a/AVSCommon/CMakeLists.txt b/AVSCommon/CMakeLists.txt
index 0ff9cb43..b44195c2 100644
--- a/AVSCommon/CMakeLists.txt
+++ b/AVSCommon/CMakeLists.txt
@@ -7,6 +7,7 @@ add_subdirectory("SDKInterfaces")
 add_subdirectory("Utils")
 
 add_library(AVSCommon
+    AVS/src/AgentId.cpp
     AVS/src/AVSContext.cpp
     AVS/src/AVSDirective.cpp
     AVS/src/AVSMessage.cpp
@@ -24,8 +25,8 @@ add_library(AVSCommon
     AVS/src/CapabilityConfiguration.cpp
     AVS/src/CapabilityTag.cpp
     AVS/src/ComponentConfiguration.cpp
-    AVS/src/DialogUXStateAggregator.cpp
     AVS/src/DirectiveRoutingRule.cpp
+    AVS/src/EndpointResources.cpp
     AVS/src/EventBuilder.cpp
     AVS/src/ExceptionEncounteredSender.cpp
     AVS/src/CapabilityResources.cpp
@@ -60,6 +61,8 @@ add_library(AVSCommon
     Utils/src/LibcurlUtils/HTTPContentFetcherFactory.cpp
     Utils/src/LibcurlUtils/HttpPost.cpp
     Utils/src/LibcurlUtils/HttpPut.cpp
+    Utils/src/LibcurlUtils/HttpGet.cpp
+    Utils/src/LibcurlUtils/HttpDelete.cpp
     Utils/src/LibcurlUtils/HTTPResponse.cpp
     Utils/src/LibcurlUtils/LibCurlHttpContentFetcher.cpp
     Utils/src/LibcurlUtils/LibcurlHTTP2Connection.cpp
@@ -146,11 +149,22 @@ target_link_libraries(AVSCommon
     acsdkApplicationAudioPipelineFactoryInterfaces
     acsdkEqualizerInterfaces
     acsdkInteractionModelInterfaces
+    MultiAgentInterface
     )
 
+add_library(acsdkDUXSA
+        AVS/src/DialogUXStateAggregator.cpp)
+
+target_link_libraries(acsdkDUXSA
+        AVSCommon
+        MultiAgentInterface)
+
 # install target
 LIST(APPEND PATHS "${PROJECT_SOURCE_DIR}/AVS/include")
 LIST(APPEND PATHS "${PROJECT_SOURCE_DIR}/SDKInterfaces/include")
 LIST(APPEND PATHS "${PROJECT_SOURCE_DIR}/Utils/include")
 LIST(APPEND PATHS "${PROJECT_BINARY_DIR}/Utils/include")
 asdk_install_multiple("${PATHS}")
+
+# Now that DUXSA is its own target, install it as well
+asdk_install_targets(acsdkDUXSA FALSE)
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/AudioInputProcessorObserverInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/AudioInputProcessorObserverInterface.h
index b99e1765..c0756163 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/AudioInputProcessorObserverInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/AudioInputProcessorObserverInterface.h
@@ -19,6 +19,8 @@
 #include <sstream>
 #include <string>
 
+#include <AVSCommon/AVS/AgentId.h>
+
 namespace alexaClientSDK {
 namespace avsCommon {
 namespace sdkInterfaces {
@@ -51,9 +53,10 @@ public:
      * This function is called when the state of the observed @c AudioInputProcessor changes.  This function will block
      * processing of audio inputs, so implementations should return quickly.
      *
-     * @param state The new state of the @c AudioInputProcessor.
+     * @param agentId The @c AgentId for which the state changed.
+     * @param state The new state for the @c AgentId.
      */
-    virtual void onStateChanged(State state) = 0;
+    virtual void onStateChanged(avsCommon::avs::AgentId::IdType agentId, State state) = 0;
 
     /**
      * This function converts the provided @c State to a string.
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ContextManagerInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ContextManagerInterface.h
index 4cf9d96d..19a2b994 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ContextManagerInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ContextManagerInterface.h
@@ -185,6 +185,31 @@ public:
         ContextRequestToken stateRequestToken,
         bool isEndpointUnreachable) = 0;
 
+    /**
+     * Request the @c ContextManager for context for Alexa Agent. If a request to the @c StateProviderInterfaces
+     * for updated states is not in progress, then requests will be sent to the @c StateProviderInterfaces via the
+     * @c provideState requests. If updated states have already been requested, this @ getContext request will be put on
+     * a queue and updated when the head of queue's request arrives. Once updated states are available, the context
+     * requester is informed via @c onContextAvailable. If any error is encountered while updating states, the context
+     * requester is informed via @c onContextFailure with the details of the error.
+     *
+     * @note If you are using RequestToken to track the context response, make sure that the access is synchronized
+     * with the @c onContextAvailable response.
+     *
+     * @param contextRequester The context requester asking for context.
+     * @param endpointId The @c endpointId used to select which context is being requested.
+     * @param timeout The maximum time this request should take. After the timeout, the context manager will abort the
+     * request.
+     * @return A token that can be used to correlate this request with the context response.
+     *
+     * @warning An empty endpointId will select the defaultEndpoint context for now. This argument will become
+     * required in future versions of the SDK.
+     */
+    virtual ContextRequestToken getContext(
+        std::shared_ptr<ContextRequesterInterface> contextRequester,
+        const std::string& endpointId = "",
+        const std::chrono::milliseconds& timeout = std::chrono::seconds(2)) = 0;
+
     /**
      * Request the @c ContextManager for context. If a request to the @c StateProviderInterfaces for updated states
      * is not in progress, then requests will be sent to the @c StateProviderInterfaces via the @c provideState
@@ -197,6 +222,8 @@ public:
      * with the @c onContextAvailable response.
      *
      * @param contextRequester The context requester asking for context.
+     * @param agentId The Agent for which the context is for.  AGENT_ID_ALL is NOT a valid agentId and ContextManager
+     * will return an empty context if it's the case.
      * @param endpointId The @c endpointId used to select which context is being requested.
      * @param timeout The maximum time this request should take. After the timeout, the context manager will abort the
      * request.
@@ -206,6 +233,38 @@ public:
      * required in future versions of the SDK.
      */
     virtual ContextRequestToken getContext(
+        std::shared_ptr<ContextRequesterInterface> contextRequester,
+        avsCommon::avs::AgentId::IdType agentId,
+        const std::string& endpointId = "",
+        const std::chrono::milliseconds& timeout = std::chrono::seconds(2)) = 0;
+
+    /**
+     * Request the @c ContextManager for context for Alexa while skipping state from @c StateProviders which have
+     * reportable state properties.
+     *
+     * @see https://developer.amazon.com/en-US/docs/alexa/alexa-voice-service/reportable-state-properties.html
+     *
+     * @note An example use case of when this method can be is used is to get the Context sent in
+     * @c SpeechRecognizer.Recognize event. The reason being, sending all state information can make the context
+     * bloated which might adversely effect user perceived latency. Additionally, state from reportable state properties
+     * can be sent to the cloud either by using @c StateReport event or the @c ChangeReport event.
+     *
+     * @note This method is functionally similar to the getContext() method except that it skips state information of
+     * reportable state properties.
+     *
+     * @note If you are using RequestToken to track the context response, make sure that the access is synchronized
+     * with the @c onContextAvailable response.
+     *
+     * @param contextRequester The context requester asking for context.
+     * @param endpointId The @c endpointId used to select which context is being requested.
+     * @param timeout The maximum time this request should take. After the timeout, the context manager will abort the
+     * request.
+     * @return A token that can be used to correlate this request with the context response.
+     *
+     * @warning An empty endpointId will select the defaultEndpoint context for now. This argument will become
+     * required in future versions of the SDK.
+     */
+    virtual ContextRequestToken getContextWithoutReportableStateProperties(
         std::shared_ptr<ContextRequesterInterface> contextRequester,
         const std::string& endpointId = "",
         const std::chrono::milliseconds& timeout = std::chrono::seconds(2)) = 0;
@@ -228,6 +287,8 @@ public:
      * with the @c onContextAvailable response.
      *
      * @param contextRequester The context requester asking for context.
+     * @param agentId The Agent for which the context is for.  AGENT_ID_ALL is NOT a valid agentId and ContextManager
+     * will return an empty context if it's the case.
      * @param endpointId The @c endpointId used to select which context is being requested.
      * @param timeout The maximum time this request should take. After the timeout, the context manager will abort the
      * request.
@@ -238,6 +299,7 @@ public:
      */
     virtual ContextRequestToken getContextWithoutReportableStateProperties(
         std::shared_ptr<ContextRequesterInterface> contextRequester,
+        avsCommon::avs::AgentId::IdType agentId,
         const std::string& endpointId = "",
         const std::chrono::milliseconds& timeout = std::chrono::seconds(2)) = 0;
 
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DialogUXStateObserverInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DialogUXStateObserverInterface.h
index 4ddd75d6..f76cb607 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DialogUXStateObserverInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DialogUXStateObserverInterface.h
@@ -21,6 +21,8 @@
 #include <ostream>
 #include <string>
 
+#include <AVSCommon/AVS/AgentId.h>
+
 namespace alexaClientSDK {
 namespace avsCommon {
 namespace sdkInterfaces {
@@ -66,9 +68,10 @@ public:
      * This function is called whenever the AVS UX dialog state of the system changes. This function will block
      * processing of other state changes, so any implementation of this should return quickly.
      *
+     * @param agentId The agent id for which the Dialog UX state is changing
      * @param newState The new dialog specific AVS UX state.
      */
-    virtual void onDialogUXStateChanged(DialogUXState newState) = 0;
+    virtual void onDialogUXStateChanged(avsCommon::avs::AgentId::IdType agentId, DialogUXState newState) = 0;
 
     /**
      * This function converts the provided @c DialogUXState to a string.
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h
index a995b256..978017a0 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h
@@ -19,10 +19,12 @@
 #include <memory>
 #include <string>
 
+#include "AVSCommon/AVS/EndpointResources.h"
 #include "AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h"
 #include "AVSCommon/SDKInterfaces/DirectiveHandlerInterface.h"
 #include "AVSCommon/SDKInterfaces/Endpoints/EndpointCapabilitiesBuilderInterface.h"
 #include "AVSCommon/SDKInterfaces/Endpoints/EndpointCapabilitiesRegistrarInterface.h"
+#include "AVSCommon/SDKInterfaces/Endpoints/EndpointIdentifier.h"
 #include "AVSCommon/SDKInterfaces/Endpoints/EndpointInterface.h"
 #include "AVSCommon/SDKInterfaces/ModeController/ModeControllerAttributes.h"
 #include "AVSCommon/SDKInterfaces/ModeController/ModeControllerInterface.h"
@@ -151,18 +153,32 @@ public:
      * @note This value can contain up to 128 characters.
      * @note The builder will fail if the manufacturer name param is invalid.
      *
-     * @param description The manufacturer name of the device representing the endpoint.
+     * @param manufacturerName The manufacturer name of the device representing the endpoint.
      * @return This builder which can be used to nest configuration function calls.
      */
     virtual EndpointBuilderInterface& withManufacturerName(const std::string& manufacturerName) = 0;
 
+    /**
+     * Configures builder to use endpointResources representing the endpoint.
+     *
+     * @note EndpointResources contains friendlyNames, manufacturer name and description.
+     * @note Use either withFriendlyName, withDescription, withManufacturerName to build or withEndpointResources
+     * to build. 
+     * @note The builder will fail if the endpointResources param is invalid.
+     *
+     * @param endpointResources The endpointResources of the device representing the endpoint.
+     * @return This builder which can be used to nest configuration function calls.
+     */
+    virtual EndpointBuilderInterface& withEndpointResources(
+            const avsCommon::avs::EndpointResources& endpointResources) = 0;
+
     /**
      * Configures builder to use the following display categories.
      *
      * @note This will override any previous display categories configuration.
      * @note The builder will fail if the displayCategories param is invalid.
      *
-     * @param description The display category the device belongs to.
+     * @param displayCategories The display category the device belongs to.
      * @return This builder which can be used to nest configuration function calls.
      */
     virtual EndpointBuilderInterface& withDisplayCategory(const std::vector<std::string>& displayCategories) = 0;
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExceptionEncounteredSenderInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExceptionEncounteredSenderInterface.h
index 7331b43c..025d5aae 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExceptionEncounteredSenderInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExceptionEncounteredSenderInterface.h
@@ -18,6 +18,8 @@
 
 #include "AVSCommon/AVS/ExceptionErrorType.h"
 
+#include <AVSCommon/AVS/AgentId.h>
+
 namespace alexaClientSDK {
 namespace avsCommon {
 namespace sdkInterfaces {
@@ -38,11 +40,31 @@ public:
      * @note The implementation of this method MUST return quickly. Failure to do so blocks the processing
      * of subsequent @c AVSDirectives.
      *
+     * @deprecated Should use the new @c sendExceptionEncountered() method with the @c AgentId as an additional
+     * parameter.
+     *
+     * @param unparsedDirective The unparsed JSON of the directive.
+     * @param error The type of error encountered.
+     * @param errorDescription Additional error details for logging and troubleshooting.
+     */
+    virtual void sendExceptionEncountered(
+        const std::string& unparsedDirective,
+        avs::ExceptionErrorType error,
+        const std::string& errorDescription) = 0;
+
+    /**
+     * Send a @c System::ExceptionEncountered message.
+     *
+     * @note The implementation of this method MUST return quickly. Failure to do so blocks the processing
+     * of subsequent @c AVSDirectives.
+     *
+     * @param agentId is the agent that is associated with the message.
      * @param unparsedDirective The unparsed JSON of the directive.
      * @param error The type of error encountered.
      * @param errorDescription Additional error details for logging and troubleshooting.
      */
     virtual void sendExceptionEncountered(
+        avsCommon::avs::AgentId::IdType agentId,
         const std::string& unparsedDirective,
         avs::ExceptionErrorType error,
         const std::string& errorDescription) = 0;
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/LocaleAssetsManagerInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/LocaleAssetsManagerInterface.h
index cf34a932..ac1f9ad9 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/LocaleAssetsManagerInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/LocaleAssetsManagerInterface.h
@@ -21,6 +21,7 @@
 #include <string>
 #include <vector>
 
+#include <AVSCommon/AVS/Locale.h>
 #include <AVSCommon/SDKInterfaces/CapabilityConfigurationChangeObserverInterface.h>
 #include <AVSCommon/SDKInterfaces/Endpoints/EndpointRegistrationManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/LocaleAssetsObserverInterface.h>
@@ -40,10 +41,9 @@ namespace sdkInterfaces {
 class LocaleAssetsManagerInterface : public CapabilityConfigurationChangeObserverInterface {
 public:
     /**
-     * Alias for the locale. The locale should follow <a href="https://tools.ietf.org/html/bcp47">BCP 47 format</a> and
-     * it's composed of a language tag and a region tag, e.g.: en-CA.
+     *  Alias for Locale.
      */
-    using Locale = std::string;
+    using Locale = avsCommon::avs::Locale;
 
     /**
      * Alias for the language tag. The language tag should follow <a href="https://tools.ietf.org/html/bcp47">BCP 47
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/MessageObserverInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/MessageObserverInterface.h
index fe186ad1..076601cc 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/MessageObserverInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/MessageObserverInterface.h
@@ -16,6 +16,8 @@
 #ifndef ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_MESSAGEOBSERVERINTERFACE_H_
 #define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_MESSAGEOBSERVERINTERFACE_H_
 
+#include <AVSCommon/AVS/AgentId.h>
+
 #include <string>
 
 namespace alexaClientSDK {
@@ -33,13 +35,17 @@ public:
     virtual ~MessageObserverInterface() = default;
 
     /**
-     * A function that a client must implement to receive Messages from AVS.
+     * A function that a client must implement to receive Messages from AVS from any agent.
      *
+     * @param agentId The @c AgentId of which the message is from.
      * @param contextId The context for the message, which in this case reflects the logical HTTP/2 stream the
      * message arrived on.
      * @param message The AVS message that has been received.
      */
-    virtual void receive(const std::string& contextId, const std::string& message) = 0;
+    virtual void receive(
+        avsCommon::avs::AgentId::IdType agentId,
+        const std::string& contextId,
+        const std::string& message) = 0;
 };
 
 }  // namespace sdkInterfaces
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h
new file mode 100644
index 00000000..80258547
--- /dev/null
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h
@@ -0,0 +1,129 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_MESSAGING_MESSAGINGOBSERVERINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_MESSAGING_MESSAGINGOBSERVERINTERFACE_H_
+
+#include <string>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace sdkInterfaces {
+namespace messaging {
+
+/**
+ * This @c MessagingObserverInterface class is used to notify observers when a @c SendMessage,
+ * @c UpdateMessageStatus, or @c UploadConversations directive is received.
+ */
+class MessagingObserverInterface {
+public:
+    /**
+     * An enum representing the messaging endpoints.
+     */
+    enum class MessagingEndpoint {
+        /// Default messaging endpoint
+        DEFAULT
+    };
+
+    /**
+     * Destructor
+     */
+    virtual ~MessagingObserverInterface() = default;
+
+    /**
+     * Used to notify the observer when a @c Alexa.Comms.MessagingController.SendMessage directive
+     * is received. Once called, the client should send the message to the given recipients
+     * using the specified messaging endpoint.
+     *
+     * @param token The token for this request.
+     * @param endpoint The messaging endpoint to send the message.
+     * @param jsonPayload The payload of the @c SendMessage directive in structured JSON format.
+     * @code{.json}
+     * {
+     *     "payload": {
+     *         "@type" : "text",
+     *         "text" : "{{STRING}}"
+     *     },
+     *     "recipients" : [
+     *         {
+     *             "address" : "{{STRING}}",
+     *             "addressType" : "PhoneNumberAddress"
+     *         }
+     *     ]
+     * }
+     * @endcode
+     *
+     */
+    virtual void sendMessage(const std::string& token, MessagingEndpoint endpoint, const std::string& jsonPayload) = 0;
+
+    /**
+     * Used to notify the observer when a @c Alexa.Comms.MessagingController.UploadConversations directive
+     * is received. Once called, the client should upload a conversations report using the specified
+     * filter in the JSON payload.
+     *
+     * @param token The token for this request.
+     * @param endpoint The messaging endpoint whose messages are requested to be uploaded.
+     * @param jsonPayload The payload of the @c UploadConversations directive in structured JSON format. The only
+     * supported filter values are shown below.
+     * @code{.json}
+     * {
+     *     "filter" : {
+     *         "conversationFilter" : {
+     *             "@type" : "AllConversations",
+     *             "conversationIds" : [{{STRING}}]
+     *         },
+     *         "messageFilter" : {
+     *             "@type" : "UnreadMessages"
+     *         },
+     *         "maxMessageCount" : 40
+     *      }
+     * }
+     * @endcode
+     *
+     */
+    virtual void uploadConversations(
+        const std::string& token,
+        MessagingEndpoint endpoint,
+        const std::string& jsonPayload) = 0;
+
+    /**
+     * Used to notify the observer when a @c Alexa.Comms.MessagingController.UpdateMessagesStatus directive
+     * is received. Once called, the client should update the specified messages with the given
+     * status.
+     *
+     * @param token The token for this request.
+     * @param endpoint The messaging endpoint whose messages status need to be updated.
+     * @param jsonPayload The payload of the @c UpdateMessagesStatus directive in structured JSON format.
+     * @code{.json}
+     * {
+     *     "conversationId" : {{STRING}},
+     *     "statusMap" : {
+     *         "read" : [{{STRING}}],
+     *     }
+     * }
+     * @endcode
+     */
+    virtual void updateMessagesStatus(
+        const std::string& token,
+        MessagingEndpoint endpoint,
+        const std::string& jsonPayload) = 0;
+};
+
+}  // namespace messaging
+}  // namespace sdkInterfaces
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_MESSAGING_MESSAGINGOBSERVERINTERFACE_H_
\ No newline at end of file
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/SpeechSynthesizerObserverInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/SpeechSynthesizerObserverInterface.h
index 01f1ba80..1374f05f 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/SpeechSynthesizerObserverInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/SpeechSynthesizerObserverInterface.h
@@ -19,6 +19,7 @@
 #include <iostream>
 #include <vector>
 
+#include <AVSCommon/AVS/AgentId.h>
 #include <AVSCommon/Utils/MediaPlayer/MediaPlayerInterface.h>
 #include <AVSCommon/Utils/AudioAnalyzer/AudioAnalyzerState.h>
 
@@ -57,18 +58,31 @@ public:
     virtual ~SpeechSynthesizerObserverInterface() = default;
 
     /**
-     * Notification that the @c SpeechSynthesizer state has changed. Callback functions must return as soon as possible.
+     * This is a struct that contains the context of SpeechSynthesizer during a state change.
+     */
+    struct Context {
+        /// The current media source id for SpeechSynthesizer
+        const avsCommon::utils::mediaPlayer::MediaPlayerInterface::SourceId mediaSourceId;
+
+        /// Optional state of the media player as of this state change. The Optional is blank if the state is
+        /// unavailable.
+        const avsCommon::utils::Optional<avsCommon::utils::mediaPlayer::MediaPlayerState> mediaPlayerState;
+
+        /// States of the audio analyzers related to the speech output.
+        const std::vector<avsCommon::utils::audioAnalyzer::AudioAnalyzerState> audioAnalyzerState;
+
+        /// The AgentId associated with the state change.
+        const avsCommon::avs::AgentId::IdType agentId;
+    };
+
+    /**
+     * Notification that the @c SpeechSynthesizer state has changed. The callback functions must return as soon as
+     * possible.
+     *
      * @param state The new state of the @c speechSynthesizer.
-     * @param mediaSourceId The current media source id for SpeechSynthesizer
-     * @param mediaPlayerState Optional state of the media player as of this state change. The Optional is blank
-     *                         if the state is unavailable.
-     * @param audioAnalyzerState states of the audio analyzers related to the speech output.
+     * @param context The current context of SpeechSynthesizer
      */
-    virtual void onStateChanged(
-        SpeechSynthesizerState state,
-        const avsCommon::utils::mediaPlayer::MediaPlayerInterface::SourceId mediaSourceId,
-        const avsCommon::utils::Optional<avsCommon::utils::mediaPlayer::MediaPlayerState>& mediaPlayerState,
-        const std::vector<avsCommon::utils::audioAnalyzer::AudioAnalyzerState>& audioAnalyzerState) = 0;
+    virtual void onStateChanged(SpeechSynthesizerState state, const Context& context) = 0;
 };
 
 /**
diff --git a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockContextManager.h b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockContextManager.h
index c70889e1..3849a328 100644
--- a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockContextManager.h
+++ b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockContextManager.h
@@ -44,12 +44,26 @@ public:
             std::shared_ptr<ContextRequesterInterface>,
             const std::string&,
             const std::chrono::milliseconds&));
+    MOCK_METHOD4(
+        getContext,
+        ContextRequestToken(
+            std::shared_ptr<ContextRequesterInterface>,
+            avsCommon::avs::AgentId::IdType,
+            const std::string&,
+            const std::chrono::milliseconds&));
     MOCK_METHOD3(
         getContextWithoutReportableStateProperties,
         ContextRequestToken(
             std::shared_ptr<ContextRequesterInterface>,
             const std::string&,
             const std::chrono::milliseconds&));
+    MOCK_METHOD4(
+        getContextWithoutReportableStateProperties,
+        ContextRequestToken(
+            std::shared_ptr<ContextRequesterInterface>,
+            avsCommon::avs::AgentId::IdType,
+            const std::string&,
+            const std::chrono::milliseconds&));
     MOCK_METHOD3(
         reportStateChange,
         void(
diff --git a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockExceptionEncounteredSender.h b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockExceptionEncounteredSender.h
index 13faab02..8adea0c4 100644
--- a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockExceptionEncounteredSender.h
+++ b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockExceptionEncounteredSender.h
@@ -32,6 +32,13 @@ public:
     MOCK_METHOD3(
         sendExceptionEncountered,
         void(const std::string& unparsedDirective, avs::ExceptionErrorType error, const std::string& errorDescription));
+    MOCK_METHOD4(
+        sendExceptionEncountered,
+        void(
+            avsCommon::avs::AgentId::IdType agentId,
+            const std::string& unparsedDirective,
+            avs::ExceptionErrorType error,
+            const std::string& errorDescription));
 };
 
 }  // namespace test
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
index 69976e2b..0cd1d8dc 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
@@ -93,7 +93,9 @@ public:
         /// HTTP POST
         kPOST,
         /// HTTP PUT
-        kPUT
+        kPUT,
+        /// HTTP DELETE
+        kDELETE
     };
 
     /**
@@ -278,9 +280,9 @@ public:
      * connection.
      *
      * Network interface provided will be used in preference over the value
-     * in provided in config. Set emtpy string to reset to default.
+     * in provided in config. Set empty string to reset to default.
      *
-     * @note The network interace set shall applied only to newly instantiated
+     * @note The network interface set shall applied only to newly instantiated
      * @c CurlEasyHandleWrapper objects.
      *
      * @param value The interface name as defined in CURLOPT_INTERFACE.
@@ -296,6 +298,25 @@ public:
 
     CurlEasyHandleWrapperOptionsSettingAdapter& curlOptionsSetter();
 
+    /**
+     * Static function to set custom HTTP headers to pass in the HTTP request sent to a proxy, for example:
+     *
+     * "Proxy-Authorization: Bearer 1234" (should not be CRLF-terminated)
+     *
+     * The specified headers will be applied to all subsequent requests sent to a proxy. They will not be applied
+     * if there is no proxy specified by `CURLOPT_PROXY` in the config.
+     *
+     * @param headers the list of headers. See https://curl.se/libcurl/c/CURLOPT_HTTPHEADER.html for detailed rules about the header.
+     */
+    static void setProxyHeaders(const std::vector<std::string>& headers);
+
+    /**
+     * Static function to get custom HTTP headers to pass in the HTTP request sent to a proxy.
+     *
+     * @returns the list of headers.
+     */
+    static std::vector<std::string> getProxyHeaders();
+
 private:
     /**
      * Helper function for calling curl_easy_setopt and checking the result.
@@ -358,14 +379,14 @@ private:
     curl_httppost* m_lastPost;
     /// Name for this handle.
     std::string m_id;
-    /// Synchronizes access to the @c m_interfaceName
-    static std::mutex m_interfaceNameMutex;
+    /// Synchronizes access to the settings e.g. @c s_interfaceName or @c s_proxyHeaders
+    static std::mutex s_settingsMutex;
     /// Indicates the initialization of @c m_interfaceName
-    static bool m_isInterfaceNameInitialized;
+    static bool s_isInterfaceNameInitialized;
     /// Interface name to be used for curl
-    static std::string m_interfaceName;
+    static std::string s_interfaceName;
     /// If no id is provided by the user, we will generate it from this counter.
-    static std::atomic<uint64_t> m_idGenerator;
+    static std::atomic<uint64_t> s_idGenerator;
 
     CurlEasyHandleWrapperOptionsSettingAdapter m_curlOptionsSettingAdapter;
 
@@ -377,6 +398,10 @@ private:
     std::unique_ptr<std::ofstream> m_streamOutDump;
     /// Object to format log strings correctly.
     avsCommon::utils::logger::LogStringFormatter m_logFormatter;
+    /// Custom HTTP headers provided by setProxyHeaders call.
+    static std::vector<std::string> s_proxyHeaders;
+    /// A list of headers needed to be added to a proxy request
+    curl_slist* m_proxyHeaders;
 
     friend class CurlEasyHandleWrapperOptionsSettingAdapter;
 };
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
new file mode 100644
index 00000000..bff624b6
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
+
+#include <memory>
+#include <mutex>
+#include <string>
+
+#include <curl/curl.h>
+
+#include "AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h"
+#include "HttpDeleteInterface.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// LIBCURL based implementation of HttpDeleteInterface.
+class HttpDelete : public HttpDeleteInterface {
+public:
+    /**
+     * Create a new HttpDelete instance, passing ownership of the new instance on to the caller.
+     *
+     * @return Returns an std::unique_ptr to the new HttpDelete instance, or @c nullptr of the operation failed.
+     */
+    static std::unique_ptr<HttpDelete> create();
+
+    /**
+     * HttpDelete destructor
+     */
+    ~HttpDelete() = default;
+
+    /**
+     * Deleted copy constructor.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     */
+    HttpDelete(const HttpDelete& rhs) = delete;
+
+    /**
+     * Deleted assignment operator.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     * @return The object assigned to.
+     */
+    HttpDelete& operator=(const HttpDelete& rhs) = delete;
+
+    HTTPResponse doDelete(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout) override;
+
+private:
+    /**
+     * Default HttpDelete constructor.
+     */
+    HttpDelete() = default;
+
+    /// Mutex to serialize access to @c m_curl.
+    std::mutex m_mutex;
+
+    /// CURL handle with which to make requests
+    CurlEasyHandleWrapper m_curl;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
new file mode 100644
index 00000000..14459fa6
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
+
+#include <chrono>
+#include <string>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/HTTPResponse.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// Minimal interface for making HTTP DELETE requests.
+class HttpDeleteInterface {
+public:
+    /// Virtual destructor to assure proper cleanup of derived types.
+    virtual ~HttpDeleteInterface() = default;
+
+    /**
+     * Perform an HTTP DELETE request returning the response body as a string. This method blocks for the duration
+     * of the request.
+     *
+     * @param url The URL to send the DELETE to.
+     * @param headers vector of strings to add in the header.
+     * @param timeout The maximum amount of time (in seconds) to wait for the request to complete.
+     * @return An object describing the response to the DELETE request.
+     */
+    virtual HTTPResponse doDelete(
+        const std::string& url,
+        const std::vector<std::string>& headers,
+        std::chrono::seconds timeout) = 0;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
new file mode 100644
index 00000000..58099ed9
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
+
+#include <memory>
+#include <mutex>
+#include <string>
+
+#include <curl/curl.h>
+
+#include "AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h"
+#include "HttpGetInterface.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// LIBCURL based implementation of HttpGetInterface.
+class HttpGet : public HttpGetInterface {
+public:
+    /**
+     * Create a new HttpGet instance, passing ownership of the new instance on to the caller.
+     *
+     * @return Returns an std::unique_ptr to the new HttpGet instance, or @c nullptr of the operation failed.
+     */
+    static std::unique_ptr<HttpGet> create();
+
+    /**
+     * HttpGet destructor
+     */
+    ~HttpGet() = default;
+
+    /**
+     * Deleted copy constructor.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     */
+    HttpGet(const HttpGet& rhs) = delete;
+
+    /**
+     * Deleted assignment operator.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     * @return The object assigned to.
+     */
+    HttpGet& operator=(const HttpGet& rhs) = delete;
+
+    HTTPResponse doGet(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout = std::chrono::minutes(1)) override;
+
+private:
+    /**
+     * Default HttpGet constructor.
+     */
+    HttpGet() = default;
+
+    /// Mutex to serialize access to @c m_curl.
+    std::mutex m_mutex;
+
+    /// CURL handle with which to make requests
+    CurlEasyHandleWrapper m_curl;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
index d76d0c45..b3fa11f1 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
@@ -16,6 +16,7 @@
 #ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
 #define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
 
+#include <chrono>
 #include <string>
 #include <vector>
 
@@ -38,9 +39,13 @@ public:
      *
      * @param url The URL to send the GET to.
      * @param headers Collection of strings to add in the header.
+     * @param timeout The maximum amount of time (in seconds) to wait for the request to complete.
      * @return An object describing the response to the GET request.
      */
-    virtual HTTPResponse doGet(const std::string& url, const std::vector<std::string>& headers) = 0;
+    virtual HTTPResponse doGet(
+        const std::string& url,
+        const std::vector<std::string>& headers,
+        std::chrono::seconds timeout = std::chrono::minutes(1)) = 0;
 };
 
 }  // namespace libcurlUtils
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/LibcurlUtils.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/LibcurlUtils.h
index e7582d94..7c792d5a 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/LibcurlUtils.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/LibcurlUtils.h
@@ -45,7 +45,7 @@ namespace libcurlUtils {
 bool prepareForTLS(CURL* handle);
 
 /**
- * Prepare a CURL handle to set the proxy to use for the upcoming request.
+ * Prepare a CURL handle to set the proxy to use for the upcoming requests.
  *
  * The 'libCurlUtils' sub-component of the global configuration supports the following options:
  * - CURLOPT_PROXY If present, specifies a value for the libcurl property CURLOPT_PROXY.
@@ -61,9 +61,10 @@ bool prepareForTLS(CURL* handle);
  * @endcode
  *
  * @param handle The libcurl handle to prepare.
+ * @param headers Additional headers for proxy request.
  * @return Whether the operation was successful.
  */
-bool prepareForProxy(CURL* handle);
+bool prepareForProxy(CURL* handle, curl_slist* headers = NULL);
 
 }  // namespace libcurlUtils
 }  // namespace utils
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h b/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h
index ec70c280..6aa7bff6 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h
@@ -39,7 +39,7 @@ public:
      *
      * @return The moniker for @c std::this_thread.
      */
-    static inline std::string getThisThreadMoniker();
+    static inline const char* getThisThreadMoniker();
 
     /**
      * Generate a unique moniker.
@@ -52,7 +52,8 @@ public:
      * Set the moniker for @c std::this_thread. This method should be called before @c getThisThreadMoniker() in order
      * to take effect.
      *
-     * @param moniker The moniker for @c std::this_thread.
+     * @param moniker The moniker for @c std::this_thread. The maximum length of the moniker is 15 characters. Any
+     * characters beyond the limit will be truncated.
      */
     static inline void setThisThreadMoniker(const std::string& moniker);
 
@@ -81,10 +82,10 @@ private:
     static const ThreadMoniker& getMonikerObjectFromMap(const std::string& moniker = std::string());
 
     /// The current thread's moniker.
-    std::string m_moniker;
+    char m_moniker[16];
 };
 
-std::string ThreadMoniker::getThisThreadMoniker() {
+const char* ThreadMoniker::getThisThreadMoniker() {
     return getMonikerObject().m_moniker;
 }
 
@@ -93,7 +94,7 @@ void ThreadMoniker::setThisThreadMoniker(const std::string& moniker) {
 }
 
 const ThreadMoniker& ThreadMoniker::getMonikerObject(const std::string& moniker) {
-#ifdef _WIN32
+#if defined(_WIN32) || defined(__QNX__)
     return getMonikerObjectFromMap(moniker);
 #else
     /// Per-thread static instance so that @c m_threadMoniker.m_moniker is @c std::this_thread's moniker.
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/MetricContext.h b/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/MetricContext.h
new file mode 100644
index 00000000..cb25ad92
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/MetricContext.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_METRICS_METRICCONTEXT_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_METRICS_METRICCONTEXT_H_
+
+#include <AVSCommon/AVS/AgentId.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace metrics {
+
+/**
+ * Struct to contain all the context data related to a specific metric event.
+ */
+struct MetricContext {
+    /// Default constructor to initialize the default values.
+    MetricContext() {
+    }
+
+    /// Constructor with @c agentId as the parameter
+    MetricContext(avsCommon::avs::AgentId::IdType agentId) : agentId{agentId} {
+    }
+
+    /// AgentId for the metric context.
+    avsCommon::avs::AgentId::IdType agentId = avsCommon::avs::AgentId::AGENT_ID_NONE;  // None by default
+};
+
+}  // namespace metrics
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_METRICS_METRICCONTEXT_H_
\ No newline at end of file
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/MetricEvent.h b/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/MetricEvent.h
index 094e4296..8864ca40 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/MetricEvent.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/MetricEvent.h
@@ -19,6 +19,7 @@
 #include <vector>
 
 #include "AVSCommon/Utils/Metrics/DataPoint.h"
+#include "AVSCommon/Utils/Metrics/MetricContext.h"
 #include "AVSCommon/Utils/Metrics/Priority.h"
 #include "AVSCommon/Utils/Optional.h"
 
@@ -33,7 +34,7 @@ namespace metrics {
 class MetricEvent {
 public:
     /**
-     * Constructor
+     * Constructor of MetricEvent that is defaulted to NONE agent.
      *
      * @param activityName is the activity name of the metric event.
      * @param priority is the priority of the metric event
@@ -46,6 +47,22 @@ public:
         const std::unordered_map<std::string, DataPoint>& dataPoints,
         std::chrono::steady_clock::time_point timestamp);
 
+    /**
+     * Constructor
+     *
+     * @param activityName is the activity name of the metric event.
+     * @param priority is the priority of the metric event
+     * @param dataPoints is the collection of key value pairs from dataPoint id to dataPoint objects
+     * @param timestamp is the timestamp at which this metric event was created.
+     * @param metricContext is the metric context for which this metric event was created.
+     */
+    MetricEvent(
+        const std::string& activityName,
+        Priority priority,
+        const std::unordered_map<std::string, DataPoint>& dataPoints,
+        std::chrono::steady_clock::time_point timestamp,
+        const MetricContext& metricContext);
+
     /**
      * Getter method for the activity name of the metric event
      *
@@ -89,6 +106,13 @@ public:
      */
     std::chrono::steady_clock::time_point getSteadyTimestamp() const;
 
+    /**
+     * Getter method for the MetricContext
+     *
+     * @return the MetricContext for the metric event
+     */
+    MetricContext getMetricContext() const;
+
 private:
     // The activity name of the metric event
     const std::string m_activityName;
@@ -101,6 +125,9 @@ private:
 
     // The timestamp for when the metric event was created
     const std::chrono::steady_clock::time_point m_timestamp;
+
+    // The metric context of the metric event
+    const MetricContext m_metricContext;
 };
 
 }  // namespace metrics
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/MetricEventBuilder.h b/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/MetricEventBuilder.h
index 692cae58..bd4975da 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/MetricEventBuilder.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/MetricEventBuilder.h
@@ -18,6 +18,7 @@
 #include <unordered_map>
 
 #include "AVSCommon/Utils/Metrics/DataPoint.h"
+#include "AVSCommon/Utils/Metrics/MetricContext.h"
 #include "AVSCommon/Utils/Metrics/MetricEvent.h"
 
 namespace alexaClientSDK {
@@ -51,6 +52,14 @@ public:
      */
     MetricEventBuilder& setPriority(Priority priority);
 
+    /**
+     * Sets the metric context for the current metric event
+     *
+     * @param metricContext The metric context of current metric event
+     * @return This instance to facilitate adding more information to this metric event.
+     */
+    MetricEventBuilder& setMetricContext(const MetricContext& metricContext);
+
     /**
      * Adds a dataPoint object for the current metric event
      *
@@ -126,6 +135,9 @@ private:
     // The priority of the current metric event
     Priority m_priority;
 
+    // The metric context of the current metric event
+    MetricContext m_metricContext;
+
     // The dataPoints of the current metric event
     std::unordered_map<std::string, DataPoint> m_dataPoints;
 };
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/UplCalculatorInterface.h b/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/UplCalculatorInterface.h
index 04e55240..7236eee5 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/UplCalculatorInterface.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/UplCalculatorInterface.h
@@ -19,6 +19,7 @@
 #include <unordered_map>
 
 #include <AVSCommon/Utils/Metrics/MetricEvent.h>
+#include <AVSCommon/Utils/Metrics/UplContext.h>
 #include <AVSCommon/Utils/Metrics/UplData.h>
 
 namespace alexaClientSDK {
@@ -47,14 +48,25 @@ public:
     virtual void inspectMetric(const std::shared_ptr<avsCommon::utils::metrics::MetricEvent>& metricEvent) = 0;
 
     /**
-     * Sets the uplData to the given pointer.
+     * Returns the pointer to the collected UplData
+     * @param uplCalculatorContext the context for a specific instance of uplData
+     * @returns @c UplData
+     */
+    virtual std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> getUplData(
+        const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext) const = 0;
+
+    /**
+     * Adds the uplData to the given map.
      *
      * @param uplData Object to record in.
+     * @param uplCalculatorContext for the UPlCalculator.
      */
-    virtual void setUplData(const std::shared_ptr<UplData>& uplData) = 0;
+    virtual void addUplData(
+        const std::shared_ptr<UplData>& uplData,
+        const UPLCalculatorContext& uplCalculatorContext) = 0;
 
 protected:
-    std::shared_ptr<UplData> m_uplData;
+    std::unordered_map<UPLCalculatorContext, std::shared_ptr<UplData>> m_UPLCalculatorContextToUPLdataMap;
 };
 
 }  // namespace metrics
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/UplContext.h b/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/UplContext.h
new file mode 100644
index 00000000..b83a0757
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/UplContext.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_METRICS_UPLCONTEXT_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_METRICS_UPLCONTEXT_H_
+
+#include <chrono>
+#include <string>
+#include <unordered_map>
+
+#include <AVSCommon/AVS/AgentId.h>
+#include <AVSCommon/Utils/Metrics/MetricContext.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace metrics {
+
+/**
+ * Struct to contain the context data for identifying a specific UPLData
+ */
+struct UPLCalculatorContext {
+    /// Constructor with @c MetricContext as the parameter.
+    UPLCalculatorContext(const MetricContext& metricContext) : agentId{metricContext.agentId} {
+    }
+
+    /**
+     * Operator == for @c UPLCalculatorContext
+     *
+     * @param rhs The right hand side of the == operation.
+     * @return Whether or not this instance and @c rhs are equivalent.
+     */
+    inline bool operator==(const UPLCalculatorContext& rhs) const {
+        return agentId == rhs.agentId;
+    }
+
+    /// AgentId for the UPLCalculatorContext.
+    const avsCommon::avs::AgentId::IdType agentId;
+};
+
+}  // namespace metrics
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+namespace std {
+/**
+ * @ std::hash() specialization defined to allow @c UPLCalculatorContext to be used as a key in @c std::unordered_map.
+ */
+template <>
+struct hash<alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext> {
+    inline size_t operator()(const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& context) const {
+        return std::hash<alexaClientSDK::avsCommon::avs::AgentId::IdType>{}(context.agentId);
+    }
+};
+
+}  // namespace std
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_METRICS_UPLCONTEXT_H_
\ No newline at end of file
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/Utils.h b/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/Utils.h
new file mode 100644
index 00000000..bac2151d
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Metrics/Utils.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_METRICS_UTILS_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_METRICS_UTILS_H_
+
+#include <chrono>
+#include <string>
+#include <unordered_map>
+
+#include "AVSCommon/Utils/Metrics/MetricContext.h"
+#include "AVSCommon/Utils/Metrics/UplContext.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace metrics {
+
+/**
+ * Creates a UPLcalculatorContext from Metric Context.
+ * UPLcalculator Context should only contain information that is required to modify/create UPLData.
+ *
+ * @param metricContext The metric context with which to create the UPL Calculator context.
+ * @return UPLCalculatorContext for the provided MetricContext.
+ */
+inline UPLCalculatorContext createUPLCalculatorContext(const MetricContext& metricContext) {
+    return UPLCalculatorContext(metricContext);
+}
+
+}  // namespace metrics
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_METRICS_UTILS_H_
\ No newline at end of file
diff --git a/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp b/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
index e72244ae..113e3a56 100644
--- a/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
+++ b/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
@@ -53,13 +53,15 @@ static const std::string LIBCURLUTILS_CONFIG_KEY = "libcurlUtils";
 /// Key for looking up a configuration value for @c CURLOPT_INTERFACE
 static const std::string INTERFACE_CONFIG_KEY = "CURLOPT_INTERFACE";
 /// Counter used to geneate unique IDs.
-std::atomic<uint64_t> CurlEasyHandleWrapper::m_idGenerator{1};
+std::atomic<uint64_t> CurlEasyHandleWrapper::s_idGenerator{1};
 ///  Interface used for the curl connection.
-std::string CurlEasyHandleWrapper::m_interfaceName{""};
-/// Indicates the initialization of @c m_interfaceName
-bool CurlEasyHandleWrapper::m_isInterfaceNameInitialized = false;
-/// Synchronizes access to the @c m_interfaceName
-std::mutex CurlEasyHandleWrapper::m_interfaceNameMutex;
+std::string CurlEasyHandleWrapper::s_interfaceName{""};
+/// Indicates the initialization of @c s_interfaceName
+bool CurlEasyHandleWrapper::s_isInterfaceNameInitialized = false;
+/// Synchronizes access to the settings e.g. @c s_interfaceName or @c s_proxyHeaders
+std::mutex CurlEasyHandleWrapper::s_settingsMutex;
+/// HTTP headers for proxy request
+std::vector<std::string> CurlEasyHandleWrapper::s_proxyHeaders{};
 
 #ifdef ACSDK_EMIT_CURL_LOGS
 /// Key under 'libcurlUtils' configuration node for path/prefix of per-stream log file names.
@@ -135,12 +137,13 @@ CurlEasyHandleWrapper::CurlEasyHandleWrapper(std::string id) :
         m_postHeaders{nullptr},
         m_post{nullptr},
         m_lastPost{nullptr},
-        m_curlOptionsSettingAdapter{this} {
+        m_curlOptionsSettingAdapter{this},
+        m_proxyHeaders{nullptr} {
     if (m_handle == nullptr) {
         ACSDK_ERROR(LX("CurlEasyHandleWrapperFailed").d("reason", "curl_easy_init failed"));
     } else {
         if (id.empty()) {
-            m_id = std::to_string(m_idGenerator++);
+            m_id = std::to_string(s_idGenerator++);
         } else {
             m_id = std::move(id);
         }
@@ -157,7 +160,7 @@ CurlEasyHandleWrapper::~CurlEasyHandleWrapper() {
 
 bool CurlEasyHandleWrapper::reset(std::string id) {
     if (id.empty()) {
-        m_id = std::to_string(m_idGenerator++);
+        m_id = std::to_string(s_idGenerator++);
     } else {
         m_id = std::move(id);
     }
@@ -249,6 +252,9 @@ bool CurlEasyHandleWrapper::setTransferType(TransferType type) {
         case TransferType::kPUT:
             ret = setopt(CURLOPT_UPLOAD, 1L);
             break;
+        case TransferType::kDELETE:
+            ret = setopt(CURLOPT_CUSTOMREQUEST, "DELETE");
+            break;
     }
     return ret;
 }
@@ -258,7 +264,7 @@ bool CurlEasyHandleWrapper::setTransferTimeout(const long timeoutSeconds) {
 }
 
 bool CurlEasyHandleWrapper::setPostData(const std::string& data) {
-    return setopt(CURLOPT_POSTFIELDS, data.c_str());
+    return setopt(CURLOPT_POSTFIELDS, data.c_str()) && setopt(CURLOPT_POSTFIELDSIZE_LARGE, (curl_off_t) data.size());
 }
 
 bool CurlEasyHandleWrapper::setConnectionTimeout(const std::chrono::seconds timeoutSeconds) {
@@ -303,6 +309,11 @@ void CurlEasyHandleWrapper::cleanupResources() {
         m_post = nullptr;
         m_lastPost = nullptr;
     }
+
+    if (m_proxyHeaders) {
+        curl_slist_free_all(m_proxyHeaders);
+        m_proxyHeaders = nullptr;
+    }
 }
 
 bool CurlEasyHandleWrapper::setDefaultOptions() {
@@ -321,11 +332,6 @@ bool CurlEasyHandleWrapper::setDefaultOptions() {
             break;
         }
 
-        if (!prepareForProxy(m_handle)) {
-            ACSDK_ERROR(LX("setDefaultOptions").d("reason", "prepareForProxy failed"));
-            break;
-        }
-
         /*
          * The documentation from libcurl recommends setting CURLOPT_NOSIGNAL to 1 for multi-threaded applications.
          * https://curl.haxx.se/libcurl/c/threadsafe.html
@@ -335,13 +341,24 @@ bool CurlEasyHandleWrapper::setDefaultOptions() {
         }
 
         {
-            std::lock_guard<std::mutex> lock(m_interfaceNameMutex);
-            if (!m_isInterfaceNameInitialized) {
+            std::lock_guard<std::mutex> lock(s_settingsMutex);
+            if (!s_isInterfaceNameInitialized) {
                 initializeNetworkInterfaceNameLocked();
             }
+
+            curl_slist_free_all(m_proxyHeaders);
+            m_proxyHeaders = nullptr;
+            for (auto& header: s_proxyHeaders) {
+                m_proxyHeaders = curl_slist_append(m_proxyHeaders, header.c_str());
+            }
+
+            if (!prepareForProxy(m_handle, m_proxyHeaders)) {
+                ACSDK_ERROR(LX("setDefaultOptions").d("reason", "prepareForProxy failed"));
+                break;
+            }
         }
 
-        if (!m_interfaceName.empty() && !setopt(CURLOPT_INTERFACE, m_interfaceName.c_str())) {
+        if (!s_interfaceName.empty() && !setopt(CURLOPT_INTERFACE, s_interfaceName.c_str())) {
             break;
         }
 
@@ -411,24 +428,24 @@ CURLcode CurlEasyHandleWrapper::pause(int mask) {
 }
 
 void CurlEasyHandleWrapper::setInterfaceName(const std::string& interfaceName) {
-    std::lock_guard<std::mutex> lock(m_interfaceNameMutex);
+    std::lock_guard<std::mutex> lock(s_settingsMutex);
     ACSDK_DEBUG(LX("setInterfaceName").d("interfaceName", interfaceName));
 
     if (interfaceName.empty()) {
-        m_interfaceName = interfaceName;
+        s_interfaceName = interfaceName;
         // Reset to default value from config, if provided.
         initializeNetworkInterfaceNameLocked();
         return;
     }
-    m_interfaceName = interfaceName;
+    s_interfaceName = interfaceName;
 }
 
 std::string CurlEasyHandleWrapper::getInterfaceName() {
-    std::lock_guard<std::mutex> lock(m_interfaceNameMutex);
-    if (!m_isInterfaceNameInitialized) {
+    std::lock_guard<std::mutex> lock(s_settingsMutex);
+    if (!s_isInterfaceNameInitialized) {
         initializeNetworkInterfaceNameLocked();
     }
-    return m_interfaceName;
+    return s_interfaceName;
 }
 
 void CurlEasyHandleWrapper::initializeNetworkInterfaceNameLocked() {
@@ -436,19 +453,34 @@ void CurlEasyHandleWrapper::initializeNetworkInterfaceNameLocked() {
     std::string interfaceNameFromConfig;
     config.getString(INTERFACE_CONFIG_KEY, &interfaceNameFromConfig, "");
 
-    if (m_interfaceName.empty() && !interfaceNameFromConfig.empty()) {
+    if (s_interfaceName.empty() && !interfaceNameFromConfig.empty()) {
         // Update the value from config, so that getInterfaceName always
         // return the current value.
-        m_interfaceName = interfaceNameFromConfig;
+        s_interfaceName = interfaceNameFromConfig;
     }
-    m_isInterfaceNameInitialized = true;
-    ACSDK_DEBUG(LX("initializeNetworkInterfaceName").d("m_interfaceName", m_interfaceName));
+    s_isInterfaceNameInitialized = true;
+    ACSDK_DEBUG(LX("initializeNetworkInterfaceNameLocked").d("s_interfaceName", s_interfaceName));
 }
 
 CurlEasyHandleWrapperOptionsSettingAdapter& CurlEasyHandleWrapper::curlOptionsSetter() {
     return m_curlOptionsSettingAdapter;
 }
 
+void CurlEasyHandleWrapper::setProxyHeaders(const std::vector<std::string>& headers) {
+    std::lock_guard<std::mutex> lock(s_settingsMutex);
+
+    std::ostringstream ss;
+    std::copy(headers.begin(), headers.end(), std::ostream_iterator<std::string>(ss, ";"));
+    ACSDK_DEBUG(LX("setProxyHeaders").d("headers", ss.str()));
+
+    s_proxyHeaders = headers;
+}
+
+std::vector<std::string> CurlEasyHandleWrapper::getProxyHeaders() {
+    std::lock_guard<std::mutex> lock(s_settingsMutex);
+    return s_proxyHeaders;
+}
+
 #ifdef ACSDK_EMIT_CURL_LOGS
 void CurlEasyHandleWrapper::initStreamLog() {
     std::string streamLogPrefix;
@@ -514,7 +546,7 @@ int CurlEasyHandleWrapper::debugFunction(CURL* handle, curl_infotype type, char*
         (*stream->m_streamLog) << logFormatter.format(
                                       logger::Level::INFO,
                                       std::chrono::system_clock::now(),
-                                      logger::ThreadMoniker::getThisThreadMoniker().c_str(),
+                                      logger::ThreadMoniker::getThisThreadMoniker(),
                                       curlInfoTypeToString(type))
                                << std::endl;
         if (CURLINFO_TEXT == type) {
diff --git a/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp b/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
new file mode 100644
index 00000000..129fca85
--- /dev/null
+++ b/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <cstdlib>
+#include <cstring>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/CallbackData.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpDelete.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+using namespace alexaClientSDK::avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("HttpDelete");
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/**
+ * Write callback function used for CURLOPT_WRITEFUNCTION option in libcurl
+ */
+static size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream);
+
+std::unique_ptr<HttpDelete> HttpDelete::create() {
+    std::unique_ptr<HttpDelete> httpDelete(new HttpDelete());
+    if (httpDelete->m_curl.isValid()) {
+        return httpDelete;
+    }
+    return nullptr;
+}
+
+HTTPResponse HttpDelete::doDelete(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout ) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    const std::string errorEvent = "doDeleteFailed";
+    const std::string errorReasonKey = "reason";
+    HTTPResponse httpResponse;
+
+    if (!m_curl.reset()) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToResetCurlHandle"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferTimeout(static_cast<long>(timeout.count()))) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetTimeout"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setURL(url)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetUrl"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferType(CurlEasyHandleWrapper::TransferType::kDELETE)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetHttpRequestType"));
+        return httpResponse;
+    }
+
+    for (auto header : headers) {
+        if (!m_curl.addHTTPHeader(header)) {
+            ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToAddHttpHeader"));
+            return httpResponse;
+        }
+    }
+
+    CallbackData responseData;
+    if (!m_curl.setWriteCallback(writeCallback, &responseData)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetWriteCallback"));
+        return httpResponse;
+    }
+
+    CURLcode curlResult = m_curl.perform();
+    if (curlResult != CURLE_OK) {
+        ACSDK_ERROR(
+            LX(errorEvent).d(errorReasonKey, "curlFailedWithCode: " + std::string(curl_easy_strerror(curlResult))));
+        return httpResponse;
+    }
+
+    size_t responseSize = responseData.getSize();
+    if (responseSize > 0) {
+        std::vector<char> responseBody(responseSize + 1, 0);
+        responseData.getData(responseBody.data(), responseSize);
+        httpResponse.body = std::string(responseBody.data());
+    } else {
+        httpResponse.body = "";
+    }
+    httpResponse.code = m_curl.getHTTPResponseCode();
+
+    return httpResponse;
+}
+
+size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream) {
+    if (!dataStream) {
+        ACSDK_ERROR(LX("writeCallbackFailed").d("reason", "nullDataStream"));
+        return 0;
+    }
+
+    size_t realSize = blockSize * numBlocks;
+    CallbackData* callbackData = reinterpret_cast<CallbackData*>(dataStream);
+
+    return callbackData->appendData(dataBuffer, realSize);
+}
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp b/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
new file mode 100644
index 00000000..10e6836a
--- /dev/null
+++ b/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <cstdlib>
+#include <cstring>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/CallbackData.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpGet.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+using namespace alexaClientSDK::avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("HttpGet");
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/**
+ * Write callback function used for CURLOPT_WRITEFUNCTION option in libcurl
+ */
+static size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream);
+
+std::unique_ptr<HttpGet> HttpGet::create() {
+    std::unique_ptr<HttpGet> httpGet(new HttpGet());
+    if (httpGet->m_curl.isValid()) {
+        return httpGet;
+    }
+    return nullptr;
+}
+
+HTTPResponse HttpGet::doGet(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout ) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    const std::string errorEvent = "doGetFailed";
+    const std::string errorReasonKey = "reason";
+    HTTPResponse httpResponse;
+
+    if (!m_curl.reset()) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToResetCurlHandle"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferTimeout(static_cast<long>(timeout.count()))) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetTimeout"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setURL(url)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetUrl"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferType(CurlEasyHandleWrapper::TransferType::kGET)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetHttpRequestType"));
+        return httpResponse;
+    }
+
+    for (auto header : headers) {
+        if (!m_curl.addHTTPHeader(header)) {
+            ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToAddHttpHeader"));
+            return httpResponse;
+        }
+    }
+
+    CallbackData responseData;
+    if (!m_curl.setWriteCallback(writeCallback, &responseData)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetWriteCallback"));
+        return httpResponse;
+    }
+
+    CURLcode curlResult = m_curl.perform();
+    if (curlResult != CURLE_OK) {
+        ACSDK_ERROR(
+            LX(errorEvent).d(errorReasonKey, "curlFailedWithCode: " + std::string(curl_easy_strerror(curlResult))));
+        return httpResponse;
+    }
+
+    size_t responseSize = responseData.getSize();
+    if (responseSize > 0) {
+        std::vector<char> responseBody(responseSize + 1, 0);
+        responseData.getData(responseBody.data(), responseSize);
+        httpResponse.body = std::string(responseBody.data());
+    } else {
+        httpResponse.body = "";
+    }
+    httpResponse.code = m_curl.getHTTPResponseCode();
+
+    return httpResponse;
+}
+
+size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream) {
+    if (!dataStream) {
+        ACSDK_ERROR(LX("writeCallbackFailed").d("reason", "nullDataStream"));
+        return 0;
+    }
+
+    size_t realSize = blockSize * numBlocks;
+    CallbackData* callbackData = reinterpret_cast<CallbackData*>(dataStream);
+
+    return callbackData->appendData(dataBuffer, realSize);
+}
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/LibcurlUtils/LibcurlUtils.cpp b/AVSCommon/Utils/src/LibcurlUtils/LibcurlUtils.cpp
index 3bedd403..ff2a3f64 100644
--- a/AVSCommon/Utils/src/LibcurlUtils/LibcurlUtils.cpp
+++ b/AVSCommon/Utils/src/LibcurlUtils/LibcurlUtils.cpp
@@ -131,7 +131,7 @@ bool prepareForTLS(CURL* handle) {
     return true;
 }
 
-bool prepareForProxy(CURL* handle) {
+bool prepareForProxy(CURL* handle, curl_slist* headers) {
     if (!handle) {
         ACSDK_ERROR(LX("prepareForProxyFailed").d("reason", "nullHandle"));
         return false;
@@ -140,10 +140,18 @@ bool prepareForProxy(CURL* handle) {
     auto config = configuration::ConfigurationNode::getRoot()[LIBCURLUTILS_CONFIG_KEY];
 
     std::string proxy;
-    if (config.getString(PROXY_CONFIG_KEY, &proxy) &&
-        !setopt(handle, CURLOPT_PROXY, proxy.c_str(), "CURLOPT_PROXY", proxy.c_str())) {
-        ACSDK_ERROR(LX("prepareForProxyFailed").d("reason", "CURLOPT_PROXY setopt Failed"));
-        return false;
+    if (config.getString(PROXY_CONFIG_KEY, &proxy)) {
+        if (!setopt(handle, CURLOPT_PROXY, proxy.c_str(), "CURLOPT_PROXY", proxy.c_str())) {
+            ACSDK_ERROR(LX("prepareForProxyFailed").d("reason", "CURLOPT_PROXY setopt Failed"));
+            return false;
+        }
+
+        if (headers) {
+            if (!setopt(handle, CURLOPT_PROXYHEADER, headers, "CURLOPT_PROXYHEADER", "...")) {
+                ACSDK_ERROR(LX("prepareForProxyFailed").d("reason", "CURLOPT_PROXYHEADER setopt Failed"));
+                return false;
+            }
+        }
     }
 
     return true;
diff --git a/AVSCommon/Utils/src/Logger/Logger.cpp b/AVSCommon/Utils/src/Logger/Logger.cpp
index 77097fd1..83e12b36 100644
--- a/AVSCommon/Utils/src/Logger/Logger.cpp
+++ b/AVSCommon/Utils/src/Logger/Logger.cpp
@@ -36,7 +36,7 @@ Logger::Logger(Level level) : m_level{level} {
 
 void Logger::log(Level level, const LogEntry& entry) {
     if (shouldLog(level)) {
-        emit(level, std::chrono::system_clock::now(), ThreadMoniker::getThisThreadMoniker().c_str(), entry.c_str());
+        emit(level, std::chrono::system_clock::now(), ThreadMoniker::getThisThreadMoniker(), entry.c_str());
     }
 }
 
diff --git a/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp b/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp
index 363ae08b..98e2ac93 100644
--- a/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp
+++ b/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp
@@ -14,6 +14,7 @@
  */
 
 #include <atomic>
+#include <cstring>
 #include <iomanip>
 #include <mutex>
 #include <sstream>
@@ -30,7 +31,9 @@ namespace logger {
 /// Counter to generate (small) unique thread monikers.
 static std::atomic<int> g_nextThreadMoniker(1);
 
-ThreadMoniker::ThreadMoniker(const std::string& moniker) : m_moniker{moniker.empty() ? generateMoniker() : moniker} {
+ThreadMoniker::ThreadMoniker(const std::string& moniker) : m_moniker{} {
+    auto& m = moniker.empty() ? generateMoniker() : moniker;
+    std::strncpy(m_moniker, m.c_str(), sizeof(m_moniker) - 1);
 }
 
 std::string ThreadMoniker::generateMoniker() {
diff --git a/AVSCommon/Utils/src/Metrics/MetricEvent.cpp b/AVSCommon/Utils/src/Metrics/MetricEvent.cpp
index c93393dc..334156f5 100644
--- a/AVSCommon/Utils/src/Metrics/MetricEvent.cpp
+++ b/AVSCommon/Utils/src/Metrics/MetricEvent.cpp
@@ -12,13 +12,14 @@
  * express or implied. See the License for the specific language governing
  * permissions and limitations under the License.
  */
-#include "AVSCommon/Utils/Metrics/MetricEvent.h"
 
 #include "AVSCommon/Utils/Logger/LogEntry.h"
 #include "AVSCommon/Utils/Logger/Logger.h"
 #include "AVSCommon/Utils/Metrics/MetricEventBuilder.h"
 #include "AVSCommon/Utils/Optional.h"
 
+#include "AVSCommon/Utils/Metrics/MetricEvent.h"
+
 namespace alexaClientSDK {
 namespace avsCommon {
 namespace utils {
@@ -42,7 +43,21 @@ MetricEvent::MetricEvent(
         m_activityName{activityName},
         m_priority{priority},
         m_dataPoints{dataPoints},
-        m_timestamp{timestamp} {
+        m_timestamp{timestamp},
+        m_metricContext{MetricContext()} {
+}
+
+MetricEvent::MetricEvent(
+    const std::string& activityName,
+    Priority priority,
+    const std::unordered_map<std::string, DataPoint>& dataPoints,
+    std::chrono::steady_clock::time_point timestamp,
+    const MetricContext& metricContext) :
+        m_activityName{activityName},
+        m_priority{priority},
+        m_dataPoints{dataPoints},
+        m_timestamp{timestamp},
+        m_metricContext{metricContext} {
 }
 
 std::string MetricEvent::getActivityName() const {
@@ -81,6 +96,10 @@ std::chrono::steady_clock::time_point MetricEvent::getSteadyTimestamp() const {
     return m_timestamp;
 }
 
+MetricContext MetricEvent::getMetricContext() const {
+    return m_metricContext;
+}
+
 }  // namespace metrics
 }  // namespace utils
 }  // namespace avsCommon
diff --git a/AVSCommon/Utils/src/Metrics/MetricEventBuilder.cpp b/AVSCommon/Utils/src/Metrics/MetricEventBuilder.cpp
index 1b49ebf7..19a00976 100644
--- a/AVSCommon/Utils/src/Metrics/MetricEventBuilder.cpp
+++ b/AVSCommon/Utils/src/Metrics/MetricEventBuilder.cpp
@@ -14,6 +14,7 @@
  */
 #include "AVSCommon/Utils/Logger/LogEntry.h"
 #include "AVSCommon/Utils/Logger/Logger.h"
+
 #include "AVSCommon/Utils/Metrics/MetricEventBuilder.h"
 
 namespace alexaClientSDK {
@@ -31,7 +32,7 @@ static const std::string TAG("MetricEventBuilder");
  */
 #define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
 
-MetricEventBuilder::MetricEventBuilder() : m_priority{Priority::NORMAL} {
+MetricEventBuilder::MetricEventBuilder() : m_priority{Priority::NORMAL}, m_metricContext{MetricContext{}} {
 }
 
 MetricEventBuilder& MetricEventBuilder::setActivityName(const std::string& activityName) {
@@ -44,6 +45,11 @@ MetricEventBuilder& MetricEventBuilder::setPriority(Priority priority) {
     return *this;
 }
 
+MetricEventBuilder& MetricEventBuilder::setMetricContext(const MetricContext& metricContext) {
+    m_metricContext = metricContext;
+    return *this;
+}
+
 MetricEventBuilder& MetricEventBuilder::addDataPoint(const DataPoint& dataPoint) {
     if (!dataPoint.isValid()) {
         ACSDK_WARN(LX("addDataPointFailed").d("reason", "invalidDataPoint"));
@@ -84,6 +90,7 @@ MetricEventBuilder& MetricEventBuilder::removeDataPoints() {
 void MetricEventBuilder::clear() {
     m_activityName = "";
     m_priority = Priority::NORMAL;
+    m_metricContext = MetricContext{};
     removeDataPoints();
 }
 
@@ -93,7 +100,8 @@ std::shared_ptr<MetricEvent> MetricEventBuilder::build() {
         return nullptr;
     }
 
-    return std::make_shared<MetricEvent>(m_activityName, m_priority, m_dataPoints, std::chrono::steady_clock::now());
+    return std::make_shared<MetricEvent>(
+        m_activityName, m_priority, m_dataPoints, std::chrono::steady_clock::now(), m_metricContext);
 }
 
 MetricEventBuilder& MetricEventBuilder::removeDataPoint(const std::string& key) {
diff --git a/AVSCommon/Utils/test/AVSCommon/Utils/Common/TestableMessageObserver.h b/AVSCommon/Utils/test/AVSCommon/Utils/Common/TestableMessageObserver.h
index 43b99cde..f9f4a27f 100644
--- a/AVSCommon/Utils/test/AVSCommon/Utils/Common/TestableMessageObserver.h
+++ b/AVSCommon/Utils/test/AVSCommon/Utils/Common/TestableMessageObserver.h
@@ -32,7 +32,8 @@ namespace utils {
  */
 class TestableMessageObserver : public avsCommon::sdkInterfaces::MessageObserverInterface {
 public:
-    void receive(const std::string& contextId, const std::string& message) override;
+    void receive(avsCommon::avs::AgentId::IdType agentId, const std::string& contextId, const std::string& message)
+        override;
 
     /**
      * A function to wait for a specific directive to be received.
diff --git a/AVSCommon/Utils/test/AVSCommon/Utils/LibcurlUtils/MockHttpGet.h b/AVSCommon/Utils/test/AVSCommon/Utils/LibcurlUtils/MockHttpGet.h
index 2b86329c..2891677c 100644
--- a/AVSCommon/Utils/test/AVSCommon/Utils/LibcurlUtils/MockHttpGet.h
+++ b/AVSCommon/Utils/test/AVSCommon/Utils/LibcurlUtils/MockHttpGet.h
@@ -29,7 +29,7 @@ namespace test {
 /// A mock object that implements the @c HttpGetInterface.
 class MockHttpGet : public HttpGetInterface {
 public:
-    MOCK_METHOD2(doGet, HTTPResponse(const std::string& url, const std::vector<std::string>& headers));
+    MOCK_METHOD3(doGet, HTTPResponse(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout));
 };
 
 }  // namespace test
diff --git a/AVSCommon/Utils/test/Common/TestableMessageObserver.cpp b/AVSCommon/Utils/test/Common/TestableMessageObserver.cpp
index 6764d208..e23439a7 100644
--- a/AVSCommon/Utils/test/Common/TestableMessageObserver.cpp
+++ b/AVSCommon/Utils/test/Common/TestableMessageObserver.cpp
@@ -33,8 +33,11 @@ static const std::string TAG("TestableMessageObserver");
  */
 #define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
 
-void TestableMessageObserver::receive(const std::string& contextId, const std::string& message) {
-    ACSDK_INFO(LX("receive").d("message", message));
+void TestableMessageObserver::receive(
+    avsCommon::avs::AgentId::IdType agentId,
+    const std::string& contextId,
+    const std::string& message) {
+    ACSDK_INFO(LX("receive").d("AgentId", agentId).d("message", message));
     std::lock_guard<std::mutex> lock(m_mutex);
     m_receivedDirectives.push_back(message);
     m_cv.notify_all();
diff --git a/AVSCommon/Utils/test/MetricEventTest.cpp b/AVSCommon/Utils/test/MetricEventTest.cpp
index 9603de6c..4df39229 100644
--- a/AVSCommon/Utils/test/MetricEventTest.cpp
+++ b/AVSCommon/Utils/test/MetricEventTest.cpp
@@ -17,8 +17,10 @@
 
 #include <gtest/gtest.h>
 
+#include "AVSCommon/AVS/AgentId.h"
 #include "AVSCommon/Utils/Metrics/DataPoint.h"
 #include "AVSCommon/Utils/Metrics/DataPointStringBuilder.h"
+#include "AVSCommon/Utils/Metrics/MetricContext.h"
 #include "AVSCommon/Utils/Metrics/MetricEvent.h"
 #include "AVSCommon/Utils/Metrics/MetricEventBuilder.h"
 #include "AVSCommon/Utils/Metrics/Priority.h"
@@ -49,6 +51,32 @@ TEST_F(MetricEventTest, test_buildDefault) {
     ASSERT_TRUE(metricEvent != nullptr);
 }
 
+/**
+ * Tests MetricEventBuilder build() without specifying agent id for metric context
+ */
+TEST_F(MetricEventTest, test_buildWithoutAgentId) {
+    MetricEventBuilder builder = MetricEventBuilder{};
+    std::shared_ptr<MetricEvent> metricEvent = builder.setActivityName("activityName").build();
+    ASSERT_TRUE(metricEvent != nullptr);
+    MetricContext metricContext = metricEvent->getMetricContext();
+    ASSERT_TRUE(metricContext.agentId == avsCommon::avs::AgentId::AGENT_ID_NONE);
+}
+
+/**
+ * Tests MetricEventBuilder build() with specifying an agent id for metric context
+ */
+TEST_F(MetricEventTest, test_buildWithAgentId) {
+    avsCommon::avs::AgentId::IdType anotherAgent = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+    MetricEventBuilder builder = MetricEventBuilder{};
+    MetricContext context = MetricContext{};
+    context.agentId = anotherAgent;
+    std::shared_ptr<MetricEvent> metricEvent =
+        builder.setActivityName("activityName").setMetricContext(context).build();
+    ASSERT_TRUE(metricEvent != nullptr);
+    MetricContext metricContext = metricEvent->getMetricContext();
+    ASSERT_TRUE(metricContext.agentId == anotherAgent);
+}
+
 /**
  * Tests default MetricEventBuilder addDataPoint()
  */
diff --git a/ApplicationUtilities/DefaultClient/include/DefaultClient/ConnectionRetryTrigger.h b/ApplicationUtilities/DefaultClient/include/DefaultClient/ConnectionRetryTrigger.h
index 0ff33d1c..bc4fa4f3 100644
--- a/ApplicationUtilities/DefaultClient/include/DefaultClient/ConnectionRetryTrigger.h
+++ b/ApplicationUtilities/DefaultClient/include/DefaultClient/ConnectionRetryTrigger.h
@@ -51,7 +51,8 @@ private:
 
     /// @name AudioInputProcessorObserverInterface methods.
     /// @{
-    void onStateChanged(AudioInputProcessorObserverInterface::State state) override;
+    void onStateChanged(avsCommon::avs::AgentId::IdType agentId, AudioInputProcessorObserverInterface::State state)
+        override;
     /// @}
 
     /// The last state reported by AudioInputProcessor.
diff --git a/ApplicationUtilities/DefaultClient/include/DefaultClient/DefaultClient.h b/ApplicationUtilities/DefaultClient/include/DefaultClient/DefaultClient.h
index 2569e2d6..a2e493fe 100644
--- a/ApplicationUtilities/DefaultClient/include/DefaultClient/DefaultClient.h
+++ b/ApplicationUtilities/DefaultClient/include/DefaultClient/DefaultClient.h
@@ -156,6 +156,7 @@ public:
         std::shared_ptr<acsdkSystemClockMonitorInterfaces::SystemClockMonitorInterface>,
         std::shared_ptr<avsCommon::sdkInterfaces::DirectiveSequencerInterface>,
         std::shared_ptr<afml::interruptModel::InterruptModel>,
+        std::shared_ptr<multiAgentInterface::AgentManagerInterface>,
         std::shared_ptr<avsCommon::avs::DialogUXStateAggregator>,
         std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface>,
         std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface>,
@@ -216,6 +217,7 @@ public:
         std::shared_ptr<acsdkSystemClockMonitorInterfaces::SystemClockMonitorInterface>,
         std::shared_ptr<avsCommon::sdkInterfaces::DirectiveSequencerInterface>,
         std::shared_ptr<afml::interruptModel::InterruptModel>,
+        std::shared_ptr<multiAgentInterface::AgentManagerInterface>,
         std::shared_ptr<avsCommon::avs::DialogUXStateAggregator>,
         std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface>,
         std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface>,
@@ -489,7 +491,8 @@ AudioInputProcessor.
         const std::shared_ptr<avsCommon::sdkInterfaces::ExpectSpeechTimeoutHandlerInterface>&
             expectSpeechTimeoutHandler = nullptr,
         capabilityAgents::aip::AudioProvider firstInteractionAudioProvider =
-            capabilityAgents::aip::AudioProvider::null());
+            capabilityAgents::aip::AudioProvider::null(),
+        const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager = nullptr);
 
     /**
      * Connects the client to AVS. After this call, users can observe the state of the connection asynchronously by
@@ -1306,6 +1309,9 @@ private:
 
     /// The @c DeviceSetupInterface
     std::shared_ptr<acsdkDeviceSetupInterfaces::DeviceSetupInterface> m_deviceSetup;
+
+    /// The @c AgentManager
+    std::shared_ptr<multiAgentInterface::AgentManagerInterface> m_agentManager;
 };
 
 }  // namespace defaultClient
diff --git a/ApplicationUtilities/DefaultClient/include/DefaultClient/DefaultClientComponent.h b/ApplicationUtilities/DefaultClient/include/DefaultClient/DefaultClientComponent.h
index 0673c3c6..5675b8d2 100644
--- a/ApplicationUtilities/DefaultClient/include/DefaultClient/DefaultClientComponent.h
+++ b/ApplicationUtilities/DefaultClient/include/DefaultClient/DefaultClientComponent.h
@@ -140,7 +140,8 @@ using DefaultClientComponent = acsdkManufactory::Component<
     std::shared_ptr<settings::DeviceSettingsManager>,
     std::shared_ptr<settings::storage::DeviceSettingStorageInterface>,
     std::shared_ptr<speechencoder::SpeechEncoder>,
-    std::shared_ptr<acsdkDeviceSetupInterfaces::DeviceSetupInterface>>;
+    std::shared_ptr<acsdkDeviceSetupInterfaces::DeviceSetupInterface>,
+    std::shared_ptr<multiAgentInterface::AgentManagerInterface>>;
 
 /**
  * Get the manufactory @c Component for (legacy) @c DefaultClient initialization.
@@ -179,7 +180,8 @@ DefaultClientComponent getComponent(
     const std::shared_ptr<acsdkBluetoothInterfaces::BluetoothStorageInterface>& bluetoothStorage,
     const std::shared_ptr<acsdkBluetoothInterfaces::BluetoothDeviceConnectionRulesProviderInterface>&
         bluetoothConnectionRulesProvider,
-    const std::shared_ptr<acsdkNotificationsInterfaces::NotificationsStorageInterface>& notificationsStorage);
+    const std::shared_ptr<acsdkNotificationsInterfaces::NotificationsStorageInterface>& notificationsStorage,
+    const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager);
 
 }  // namespace defaultClient
 }  // namespace alexaClientSDK
diff --git a/ApplicationUtilities/DefaultClient/src/CMakeLists.txt b/ApplicationUtilities/DefaultClient/src/CMakeLists.txt
index 3ff75309..2f00ecdd 100644
--- a/ApplicationUtilities/DefaultClient/src/CMakeLists.txt
+++ b/ApplicationUtilities/DefaultClient/src/CMakeLists.txt
@@ -34,6 +34,7 @@ target_link_libraries(DefaultClient
     ApiGateway
     AudioResources
     AVSCommon
+    acsdkDUXSA
     AVSSystem
     Captions
     CaptionsComponent
@@ -64,7 +65,8 @@ target_link_libraries(DefaultClient
     acsdkDeviceSetup
     acsdkDeviceSetupInterfaces
     acsdkAuthorization
-    acsdkAuthorizationInterfaces)
+    acsdkAuthorizationInterfaces
+    MultiAgent)
 
 if (CAPTIONS)
     target_link_libraries(DefaultClient CaptionsLib)
diff --git a/ApplicationUtilities/DefaultClient/src/ConnectionRetryTrigger.cpp b/ApplicationUtilities/DefaultClient/src/ConnectionRetryTrigger.cpp
index 6c2e7fa3..f4a7dad0 100644
--- a/ApplicationUtilities/DefaultClient/src/ConnectionRetryTrigger.cpp
+++ b/ApplicationUtilities/DefaultClient/src/ConnectionRetryTrigger.cpp
@@ -59,8 +59,10 @@ ConnectionRetryTrigger::ConnectionRetryTrigger(
         m_connectionManager{connectionManager} {
 }
 
-void ConnectionRetryTrigger::onStateChanged(AudioInputProcessorObserverInterface::State state) {
-    ACSDK_DEBUG9(LX(__func__).d("state", state));
+void ConnectionRetryTrigger::onStateChanged(
+    avsCommon::avs::AgentId::IdType agentId,
+    AudioInputProcessorObserverInterface::State state) {
+    ACSDK_DEBUG9(LX(__func__).d("agentId", agentId).d("state", state));
     if (AudioInputProcessorObserverInterface::State::IDLE == m_state && state != m_state) {
         m_connectionManager->onWakeConnectionRetry();
     }
diff --git a/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp b/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
index e377a10f..596ac6aa 100644
--- a/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
+++ b/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
@@ -13,6 +13,7 @@
  * permissions and limitations under the License.
  */
 
+#include <acsdk/MultiAgentInterface/AgentManagerInterface.h>
 #include <acsdkExternalMediaPlayerInterfaces/ExternalMediaAdapterConstants.h>
 #include <acsdkNotifications/NotificationRenderer.h>
 #include <acsdkSystemClockMonitorInterfaces/SystemClockMonitorObserverInterface.h>
@@ -216,7 +217,8 @@ std::unique_ptr<DefaultClient> DefaultClient::create(
     bool startAlertSchedulingOnInitialization,
     std::shared_ptr<alexaClientSDK::acl::MessageRouterFactoryInterface> messageRouterFactory,
     const std::shared_ptr<avsCommon::sdkInterfaces::ExpectSpeechTimeoutHandlerInterface>& expectSpeechTimeoutHandler,
-    capabilityAgents::aip::AudioProvider firstInteractionAudioProvider) {
+    capabilityAgents::aip::AudioProvider firstInteractionAudioProvider,
+    const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager) {
 
     if (!equalizerRuntimeSetup) {
         equalizerRuntimeSetup = std::make_shared<defaultClient::EqualizerRuntimeSetup>(false);
@@ -304,7 +306,8 @@ std::unique_ptr<DefaultClient> DefaultClient::create(
         std::move(bluetoothDeviceManager),
         std::move(bluetoothStorage),
         bluetoothConnectionRulesProvider,
-        std::move(notificationsStorage));
+        std::move(notificationsStorage),
+        agentManager);
     auto manufactory = DefaultClientManufactory::create(component);
 
     auto speakerManager = manufactory->get<std::shared_ptr<SpeakerManagerInterface>>();
@@ -671,6 +674,8 @@ bool DefaultClient::initialize(
         return false;
     }
 
+    m_agentManager = manufactory->get<std::shared_ptr<multiAgentInterface::AgentManagerInterface>>();
+
     m_softwareReporterCapabilityAgent =
         capabilityAgents::softwareComponentReporter::SoftwareComponentReporterCapabilityAgent::create();
     if (!m_softwareReporterCapabilityAgent) {
@@ -744,7 +749,8 @@ bool DefaultClient::initialize(
         firstInteractionAudioProvider,
         powerResourceManager,
         metricRecorder,
-        manufactory->get<std::shared_ptr<avsCommon::sdkInterfaces::ExpectSpeechTimeoutHandlerInterface>>());
+        manufactory->get<std::shared_ptr<avsCommon::sdkInterfaces::ExpectSpeechTimeoutHandlerInterface>>(),
+        m_agentManager);
 
     if (!m_audioInputProcessor) {
         ACSDK_ERROR(LX("initializeFailed").d("reason", "unableToCreateAudioInputProcessor"));
@@ -775,7 +781,8 @@ bool DefaultClient::initialize(
         metricRecorder,
         m_dialogUXStateAggregator,
         m_captionManager,
-        powerResourceManager);
+        powerResourceManager,
+        m_agentManager);
 
     if (!m_speechSynthesizer) {
         ACSDK_ERROR(LX("initializeFailed").d("reason", "unableToCreateSpeechSynthesizer"));
@@ -1492,7 +1499,7 @@ std::future<bool> DefaultClient::notifyOfWakeWord(
 
     return m_audioInputProcessor->recognize(
         wakeWordAudioProvider,
-        capabilityAgents::aip::Initiator::WAKEWORD,
+        avsCommon::avs::AgentInitiator::WAKEWORD,
         startOfSpeechTimestamp,
         beginIndex,
         endIndex,
@@ -1506,7 +1513,7 @@ std::future<bool> DefaultClient::notifyOfTapToTalk(
     std::chrono::steady_clock::time_point startOfSpeechTimestamp) {
     ACSDK_DEBUG5(LX(__func__));
     return m_audioInputProcessor->recognize(
-        tapToTalkAudioProvider, capabilityAgents::aip::Initiator::TAP, startOfSpeechTimestamp, beginIndex);
+        tapToTalkAudioProvider, avsCommon::avs::AgentInitiator::TAP, startOfSpeechTimestamp, beginIndex);
 }
 
 std::future<bool> DefaultClient::notifyOfHoldToTalkStart(
@@ -1515,7 +1522,7 @@ std::future<bool> DefaultClient::notifyOfHoldToTalkStart(
     avsCommon::avs::AudioInputStream::Index beginIndex) {
     ACSDK_DEBUG5(LX(__func__));
     return m_audioInputProcessor->recognize(
-        holdToTalkAudioProvider, capabilityAgents::aip::Initiator::PRESS_AND_HOLD, startOfSpeechTimestamp, beginIndex);
+        holdToTalkAudioProvider, avsCommon::avs::AgentInitiator::PRESS_AND_HOLD, startOfSpeechTimestamp, beginIndex);
 }
 
 std::future<bool> DefaultClient::notifyOfHoldToTalkEnd() {
diff --git a/ApplicationUtilities/DefaultClient/src/DefaultClientComponent.cpp b/ApplicationUtilities/DefaultClient/src/DefaultClientComponent.cpp
index 98bab7f4..5ea751ff 100644
--- a/ApplicationUtilities/DefaultClient/src/DefaultClientComponent.cpp
+++ b/ApplicationUtilities/DefaultClient/src/DefaultClientComponent.cpp
@@ -222,7 +222,8 @@ DefaultClientComponent getComponent(
     const std::shared_ptr<acsdkBluetoothInterfaces::BluetoothStorageInterface>& bluetoothStorage,
     const std::shared_ptr<acsdkBluetoothInterfaces::BluetoothDeviceConnectionRulesProviderInterface>&
         bluetoothConnectionRulesProvider,
-    const std::shared_ptr<acsdkNotificationsInterfaces::NotificationsStorageInterface>& notificationsStorage) {
+    const std::shared_ptr<acsdkNotificationsInterfaces::NotificationsStorageInterface>& notificationsStorage,
+    const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager) {
     std::shared_ptr<avsCommon::utils::bluetooth::BluetoothEventBus> bluetoothEventBus;
     if (bluetoothDeviceManager) {
         bluetoothEventBus = bluetoothDeviceManager->getEventBus();
@@ -259,6 +260,7 @@ DefaultClientComponent getComponent(
         .addInstance(bluetoothEventBus)
         .addInstance(bluetoothStorage)
         .addInstance(notificationsStorage)
+        .addInstance(agentManager)
         .addRetainedFactory(getCreateApplicationAudioPipelineFactory(stubAudioPipelineFactory))
         .addRetainedFactory(getCreateDeviceSettingStorageInterface(deviceSettingStorage))
 
diff --git a/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h b/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h
index 8a7106f8..a24d60ac 100644
--- a/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h
+++ b/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h
@@ -317,6 +317,9 @@ private:
     /// A struct containing the in-flight and pending endpoints for Discovery.addOrUpdateReport event.
     InProcessEndpointsToConfigMapStruct m_addOrUpdateEndpoints;
 
+    /// A list that preserves the endpointId order.
+    std::vector<std::string> m_endpointsOrderList;
+
     /// A struct containing the in-flight and pending endpoints Discovery.deleteReport event.
     InProcessEndpointsToConfigMapStruct m_deleteEndpoints;
 
diff --git a/CapabilitiesDelegate/include/CapabilitiesDelegate/DiscoveryEventSender.h b/CapabilitiesDelegate/include/CapabilitiesDelegate/DiscoveryEventSender.h
index d936567f..f878eec0 100644
--- a/CapabilitiesDelegate/include/CapabilitiesDelegate/DiscoveryEventSender.h
+++ b/CapabilitiesDelegate/include/CapabilitiesDelegate/DiscoveryEventSender.h
@@ -51,13 +51,16 @@ public:
      * @param authDelegate The auth delegate instance to request the auth token from to be sent in the @c Discovery
      * events.
      * @param waitForEventProcessed Indicate if sender should wait for the EventProcessed directive.
+     * @param endpointOrderList A list of endpointIds in registration order, used to preserve the order in @c Discovery
+     * events.
      * @return a new instance of the @c DiscoveryEventSender.
      */
     static std::shared_ptr<DiscoveryEventSender> create(
         const std::unordered_map<std::string, std::string>& addOrUpdateReportEndpoints,
         const std::unordered_map<std::string, std::string>& deleteReportEndpoints,
         const std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface>& authDelegate,
-        const bool waitForEventProcessed = true);
+        const bool waitForEventProcessed = true,
+        const std::vector<std::string>& endpointOrderList = {});
 
     /**
      * Destructor.
@@ -92,12 +95,15 @@ private:
      * @param authDelegate The auth delegate instance to request the auth token from to be sent in the @c Discovery
      * events.
      * @param waitForEventProcessed Indicate if sender should wait for the EventProcessed directive.
+     * @param endpointOrderList A list of endpointIds in registration order, used to preserve the order in @c Discovery
+     * events.
      */
     DiscoveryEventSender(
         const std::unordered_map<std::string, std::string>& addOrUpdateReportEndpoints,
         const std::unordered_map<std::string, std::string>& deleteReportEndpoints,
         const std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface>& authDelegate,
-        const bool waitForEventProcessed);
+        const bool waitForEventProcessed,
+        const std::vector<std::string>& endpointOrderList = {});
 
     /**
      * Sends the discovery event while taking into account retries.
@@ -193,6 +199,9 @@ private:
     /// Auth delegate used to get the access token
     std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface> m_authDelegate;
 
+    /// The endpoint order list
+    std::vector<std::string> m_endpointsOrderList;
+
     /// The authDelegate's auth status.
     AuthObserverInterface::State m_currentAuthState;
 
diff --git a/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp b/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
index 57ba3563..43442fe3 100644
--- a/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
+++ b/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
@@ -303,6 +303,7 @@ bool CapabilitiesDelegate::addOrUpdateEndpoint(
         }
 
         m_addOrUpdateEndpoints.pending.insert(std::make_pair(endpointId, endpointConfigJson));
+        m_endpointsOrderList.push_back(endpointId);
     }
 
     if (!m_currentDiscoveryEventSender) {
@@ -466,6 +467,7 @@ std::shared_ptr<PostConnectOperationInterface> CapabilitiesDelegate::createPostC
     /// The endpoints that need to be sent to AVS.
     std::unordered_map<std::string, std::string> addOrUpdateEndpointsToSend;
     std::unordered_map<std::string, std::string> deleteEndpointsToSend;
+    std::vector<std::string> endpointOrderList;
     {
         std::lock_guard<std::mutex> lock{m_endpointsMutex};
 
@@ -513,6 +515,8 @@ std::shared_ptr<PostConnectOperationInterface> CapabilitiesDelegate::createPostC
         m_deleteEndpoints.inFlight = m_deleteEndpoints.pending;
         deleteEndpointsToSend = m_deleteEndpoints.inFlight;
         m_deleteEndpoints.pending.clear();
+
+        endpointOrderList = m_endpointsOrderList;
     }
 
     /// Sometimes pending add/update endpoints do not need to be sent to AVS as they are already stored
@@ -539,7 +543,7 @@ std::shared_ptr<PostConnectOperationInterface> CapabilitiesDelegate::createPostC
                      .d("num endpoints to delete", deleteEndpointsToSend.size()));
 
     std::shared_ptr<DiscoveryEventSenderInterface> newEventSender =
-        DiscoveryEventSender::create(addOrUpdateEndpointsToSend, deleteEndpointsToSend, m_authDelegate);
+        DiscoveryEventSender::create(addOrUpdateEndpointsToSend, deleteEndpointsToSend, m_authDelegate, true, endpointOrderList);
     if (!newEventSender) {
         ACSDK_ERROR(LX("createPostConnectOperationFailed").m("Could not create DiscoveryEventSender."));
         return nullptr;
diff --git a/CapabilitiesDelegate/src/DiscoveryEventSender.cpp b/CapabilitiesDelegate/src/DiscoveryEventSender.cpp
index 11106eae..11a57c29 100644
--- a/CapabilitiesDelegate/src/DiscoveryEventSender.cpp
+++ b/CapabilitiesDelegate/src/DiscoveryEventSender.cpp
@@ -61,14 +61,15 @@ std::shared_ptr<DiscoveryEventSender> DiscoveryEventSender::create(
     const std::unordered_map<std::string, std::string>& addOrUpdateReportEndpoints,
     const std::unordered_map<std::string, std::string>& deleteReportEndpoints,
     const std::shared_ptr<AuthDelegateInterface>& authDelegate,
-    const bool waitForEventProcessed) {
+    const bool waitForEventProcessed,
+    const std::vector<std::string>& endpointOrderList) {
     if (addOrUpdateReportEndpoints.empty() && deleteReportEndpoints.empty()) {
         ACSDK_ERROR(LX("createFailed").d("reason", "endpoint map empty"));
     } else if (!authDelegate) {
         ACSDK_ERROR(LX("createFailed").d("reason", "invalid auth delegate"));
     } else {
         auto instance = std::shared_ptr<DiscoveryEventSender>(new DiscoveryEventSender(
-            addOrUpdateReportEndpoints, deleteReportEndpoints, authDelegate, waitForEventProcessed));
+            addOrUpdateReportEndpoints, deleteReportEndpoints, authDelegate, waitForEventProcessed, endpointOrderList));
 
         return instance;
     }
@@ -79,10 +80,12 @@ DiscoveryEventSender::DiscoveryEventSender(
     const std::unordered_map<std::string, std::string>& addOrUpdateReportEndpoints,
     const std::unordered_map<std::string, std::string>& deleteReportEndpoints,
     const std::shared_ptr<AuthDelegateInterface>& authDelegate,
-    const bool waitForEventProcessed) :
+    const bool waitForEventProcessed,
+    const std::vector<std::string>& endpointOrderList) :
         m_addOrUpdateReportEndpoints{addOrUpdateReportEndpoints},
         m_deleteReportEndpoints{deleteReportEndpoints},
         m_authDelegate{authDelegate},
+        m_endpointsOrderList{endpointOrderList},
         m_currentAuthState{AuthObserverInterface::State::UNINITIALIZED},
         m_isStopping{false},
         m_isSendDiscoveryEventsInvoked{false},
@@ -192,7 +195,7 @@ MessageRequestObserverInterface::Status DiscoveryEventSender::sendDiscoveryEvent
     std::unique_lock<std::mutex> lock{m_mutex};
     m_eventProcessedWaitEvent.reset();
     m_messageRequest.reset();
-    m_messageRequest = std::make_shared<WaitableMessageRequest>(eventString);
+    m_messageRequest = std::make_shared<WaitableMessageRequest>(avsCommon::avs::AgentId::AGENT_ID_ALL, eventString);
     lock.unlock();
 
     messageSender->sendMessage(m_messageRequest);
@@ -317,8 +320,17 @@ bool DiscoveryEventSender::sendAddOrUpdateReportEvents(
     }
     /// Collect all endpoint configurations
     std::vector<std::string> allEndpointConfigs;
-    for (const auto& endpointIdToConfigPair : m_addOrUpdateReportEndpoints) {
-        allEndpointConfigs.push_back(endpointIdToConfigPair.second);
+    if (!m_endpointsOrderList.empty()) {
+        /// Look into the endpoints map in the order of the m_endpointsOrderList
+        for (const auto& endpointId : m_endpointsOrderList) {
+            if (m_addOrUpdateReportEndpoints.find(endpointId) != m_addOrUpdateReportEndpoints.end()) {
+                allEndpointConfigs.push_back(m_addOrUpdateReportEndpoints[endpointId]);
+            }
+        }
+    } else {
+        for (const auto& endpointIdToConfigPair : m_addOrUpdateReportEndpoints) {
+            allEndpointConfigs.push_back(endpointIdToConfigPair.second);
+        }
     }
 
     return sendDiscoveryEvents(allEndpointConfigs, messageSender, true);
diff --git a/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp b/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp
index 62c7dcdb..f07127ac 100644
--- a/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp
+++ b/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp
@@ -68,6 +68,8 @@ const static std::string FRIENDLY_NAME_KEY = "friendlyName";
 const static std::string DESCRIPTION_KEY = "description";
 /// Manufacturer name key
 const static std::string MANUFACTURER_NAME_KEY = "manufacturerName";
+/// EndpointResources ID key
+const static std::string ENDPOINTRESOURCES_KEY = "endpointResources";
 /// Display Categories key
 const static std::string DISPLAY_CATEGORIES_KEY = "displayCategories";
 /// Additional Attributes key
@@ -259,14 +261,18 @@ bool validateEndpointAttributes(const AVSDiscoveryEndpointAttributes& endpointAt
         return false;
     }
 
-    if (!endpoints::isDescriptionValid(endpointAttributes.description)) {
-        ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidDescription"));
-        return false;
-    }
+    if (!endpoints::isEndpointResourcesValid(endpointAttributes.endpointResources)) {
 
-    if (!endpoints::isManufacturerNameValid(endpointAttributes.manufacturerName)) {
-        ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidManufacturerName"));
-        return false;
+    // Validate the legacy fields if the endpointResources object is invalid.
+        if (!endpoints::isDescriptionValid(endpointAttributes.description)) {
+            ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidDescription"));
+            return false;
+        }
+
+        if (!endpoints::isManufacturerNameValid(endpointAttributes.manufacturerName)) {
+            ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidManufacturerName"));
+            return false;
+        }
     }
 
     if (endpointAttributes.displayCategories.empty()) {
@@ -299,9 +305,14 @@ std::string getEndpointConfigJson(
     JsonGenerator generator;
 
     generator.addMember(ENDPOINT_ID_KEY, endpointAttributes.endpointId);
-    generator.addMember(FRIENDLY_NAME_KEY, endpointAttributes.friendlyName);
-    generator.addMember(DESCRIPTION_KEY, endpointAttributes.description);
-    generator.addMember(MANUFACTURER_NAME_KEY, endpointAttributes.manufacturerName);
+    /// Endpoint Resources.
+    if (endpointAttributes.endpointResources.isValid()) {
+        generator.addRawJsonMember(ENDPOINTRESOURCES_KEY, endpointAttributes.endpointResources.build());
+    } else {
+        generator.addMember(FRIENDLY_NAME_KEY, endpointAttributes.friendlyName);
+        generator.addMember(DESCRIPTION_KEY, endpointAttributes.description);
+        generator.addMember(MANUFACTURER_NAME_KEY, endpointAttributes.manufacturerName);
+    }
     addSortedStringArray(generator, DISPLAY_CATEGORIES_KEY, endpointAttributes.displayCategories);
 
     /// Additional Attributes Object.
diff --git a/CapabilityAgents/AIP/include/AIP/AudioInputProcessor.h b/CapabilityAgents/AIP/include/AIP/AudioInputProcessor.h
index e01cda88..d9db3d3f 100644
--- a/CapabilityAgents/AIP/include/AIP/AudioInputProcessor.h
+++ b/CapabilityAgents/AIP/include/AIP/AudioInputProcessor.h
@@ -23,6 +23,11 @@
 #include <unordered_set>
 #include <vector>
 
+#include <AVSCommon/AVS/AgentId.h>
+#include <acsdk/MultiAgentInterface/AgentManagerInterface.h>
+#include <acsdk/MultiAgentInterface/Observer/AgentEnablementObserverInterface.h>
+#include <acsdkNotifier/internal/Notifier.h>
+#include <AVSCommon/AVS/AgentInitiator.h>
 #include <AVSCommon/AVS/Attachment/InProcessAttachmentReader.h>
 #include <AVSCommon/AVS/CapabilityAgent.h>
 #include <AVSCommon/AVS/CapabilityConfiguration.h>
@@ -32,6 +37,7 @@
 #include <AVSCommon/AVS/ExceptionErrorType.h>
 #include <AVSCommon/AVS/EditableMessageRequest.h>
 #include <AVSCommon/AVS/MessageRequest.h>
+#include <AVSCommon/SDKInterfaces/AlexaInterfaceMessageSenderInterface.h>
 #include <AVSCommon/SDKInterfaces/AudioInputProcessorObserverInterface.h>
 #include <AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h>
 #include <AVSCommon/SDKInterfaces/ChannelObserverInterface.h>
@@ -59,7 +65,6 @@
 #include <SpeechEncoder/SpeechEncoder.h>
 
 #include "AudioProvider.h"
-#include "Initiator.h"
 
 namespace alexaClientSDK {
 namespace capabilityAgents {
@@ -79,6 +84,7 @@ namespace aip {
  */
 class AudioInputProcessor
         : public avsCommon::avs::CapabilityAgent
+        , public multiAgentInterface::observer::AgentEnablementObserverInterface
         , public avsCommon::sdkInterfaces::CapabilityConfigurationInterface
         , public avsCommon::sdkInterfaces::LocaleAssetsObserverInterface
         , public avsCommon::sdkInterfaces::DialogUXStateObserverInterface
@@ -159,6 +165,7 @@ public:
      * @param expectSpeechTimeoutHandler An optional interface that applications may provide to specify external
      * handling of the @c ExpectSpeech directive's timeout. If provided, this function must remain valid for the
      * lifetime of the @c AudioInputProcessor.
+     * @param agentManager The object to use for AgentManager operations.
      * @return A @c std::shared_ptr to the new @c AudioInputProcessor instance.
      */
     static std::shared_ptr<AudioInputProcessor> create(
@@ -179,7 +186,10 @@ public:
         AudioProvider defaultAudioProvider = AudioProvider::null(),
         std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface> powerResourceManager = nullptr,
         std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder = nullptr,
-        const std::shared_ptr<ExpectSpeechTimeoutHandler>& expectSpeechTimeoutHandler = nullptr);
+        const std::shared_ptr<ExpectSpeechTimeoutHandler>& expectSpeechTimeoutHandler = nullptr,
+        const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager = nullptr,
+        const std::shared_ptr<avsCommon::sdkInterfaces::AlexaInterfaceMessageSenderInterface>& alexaMessageSender =
+            nullptr);
 
     /**
      * Adds an observer to be notified of AudioInputProcessor state changes.
@@ -216,7 +226,7 @@ public:
      *
      * False-wakeword detection in the cloud will be used when all of the following requirements are met:
      *
-     * @li `initiator == Initiator::WAKEWORD`
+     * @li `AgentInitiator == AgentInitiator::WAKEWORD`
      * @li `begin != INVALID_INDEX`
      * @li `end != INVALID_INDEX`
      * @li `!keyword.empty()`
@@ -254,7 +264,7 @@ public:
      */
     std::future<bool> recognize(
         AudioProvider audioProvider,
-        Initiator initiator,
+        avsCommon::avs::AgentInitiator initiator,
         std::chrono::steady_clock::time_point startOfSpeechTimestamp = std::chrono::steady_clock::now(),
         avsCommon::avs::AudioInputStream::Index begin = INVALID_INDEX,
         avsCommon::avs::AudioInputStream::Index keywordEnd = INVALID_INDEX,
@@ -311,6 +321,7 @@ public:
     /// @name DialogUXStateObserverInterface Functions
     /// @{
     void onDialogUXStateChanged(
+        avsCommon::avs::AgentId::IdType agentId,
         avsCommon::sdkInterfaces::DialogUXStateObserverInterface::DialogUXState newState) override;
     /// @}
 
@@ -378,6 +389,19 @@ public:
      */
     EncodingFormatResponse getEncodingAudioFormats() const;
 
+    /**
+     * Getter method for the agentId
+     *
+     * @return the agentId of the current directive/event being handled by AIP.
+     */
+    avsCommon::avs::AgentId::IdType getAgentId() const;
+
+    /// @name AgentEnablementObserverInterface Functions
+    /// @{
+    void onEnabled(avsCommon::avs::AgentId::IdType id) override;
+    void onDisabled(avsCommon::avs::AgentId::IdType id) override;
+    /// @}
+
 private:
     /**
      * Inintialize audio input processor.
@@ -436,7 +460,9 @@ private:
         std::shared_ptr<avsCommon::avs::CapabilityConfiguration> capabilitiesConfiguration,
         std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface> powerResourceManager,
         std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder,
-        const std::shared_ptr<ExpectSpeechTimeoutHandler>& expectSpeechTimeoutHandler);
+        const std::shared_ptr<ExpectSpeechTimeoutHandler>& expectSpeechTimeoutHandler,
+        const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager,
+        const std::shared_ptr<avsCommon::sdkInterfaces::AlexaInterfaceMessageSenderInterface>& alexaMessageSender);
 
     /// @name RequiresShutdown Functions
     /// @{
@@ -496,8 +522,8 @@ private:
 
     /**
      * This function builds @c a Recognize event and will request context so the events will be sent upon @c
-     * onContextAvailable().  This version of the function expects an enumerated @c Initiator, and will build up the
-     * initiator json content for the event, before calling the @c executeRecognize() function below which takes an
+     * onContextAvailable().  This version of the function expects an enumerated @c AgentInitiator, and will build up
+     * the initiator json content for the event, before calling the @c executeRecognize() function below which takes an
      * initiator string.
      *
      * @see @c recognize() for a detailed explanation of the Recognize Event.
@@ -515,7 +541,7 @@ private:
      */
     bool executeRecognize(
         AudioProvider provider,
-        Initiator initiator,
+        avsCommon::avs::AgentInitiator initiator,
         std::chrono::steady_clock::time_point startOfSpeechTimestamp,
         avsCommon::avs::AudioInputStream::Index begin,
         avsCommon::avs::AudioInputStream::Index keywordEnd,
@@ -526,18 +552,19 @@ private:
     /**
      * This function builds and sends a @c Recognize event.  This version of the function expects a pre-built string
      * containing the initiator json content for the event.  This initiator string is either built by the
-     * @c executeRecognize() function above which takes an enumerated @c Initiator, or is an opaque object provided by
-     * an @c ExpectSpeech directive.
+     * @c executeRecognize() function above which takes an enumerated @c AgentInitiator, or is an opaque object provided
+     * by an @c ExpectSpeech directive.
      *
      * @see @c recognize() for a detailed explanation of the Recognize Event.
      *
      * @param audioProvider The @c AudioProvider to stream audio from.
      * @param initiatorJson A JSON string describing the type of interface that initiated this recognize event.
+     * @param agentId associated with the recognize event.
      * @param startOfSpeechTimestamp Moment in time when user started talking to Alexa.
      * @param begin The @c Index in @c audioProvider.stream where audio streaming should begin.  This parameter is
      *     optional, and defaults to @c INVALID_INDEX.  When this parameter is not specified, @c recognize() will
-     *     stream audio starting at the time of the @c recognize() call.  If the @c initiator is @c WAKEWORD, and this
-     *     and @c keywordEnd are specified, streaming will begin between 0 and 500ms prior to the @c Index specified by
+     *     stream audio starting at the time of the @c recognize() call.  If the @c AgentInitiator is @c WAKEWORD, and
+     * this and @c keywordEnd are specified, streaming will begin between 0 and 500ms prior to the @c Index specified by
      *     this parameter to attempt false wakeword validation.
      * @param end The @c Index in @c audioProvider.stream where the wakeword ends.
      * @param keyword The text of the keyword which was recognized.  This parameter is optional, and defaults to an
@@ -547,12 +574,13 @@ private:
      * @param KWDMetadata Wake word engine metadata.
      * @param initiatedByWakeword Whether the Initiator was Wakeword; false by default.
      * @param falseWakewordDetection Whether false Wakeword detection was enabled; false by default.
-     * @param initiatorString - The @c Initiator string to be used to log a metric.
+     * @param initiatorString - The @c AgentInitiator string to be used to log a metric.
      * @return @c true if the Recognize Event was started successfully, else @c false.
      */
     bool executeRecognize(
         AudioProvider provider,
         const std::string& initiatorJson,
+        const avsCommon::avs::AgentId::IdType& agentId,
         std::chrono::steady_clock::time_point startOfSpeechTimestamp = std::chrono::steady_clock::now(),
         avsCommon::avs::AudioInputStream::Index begin = INVALID_INDEX,
         avsCommon::avs::AudioInputStream::Index end = INVALID_INDEX,
@@ -776,9 +804,6 @@ private:
      */
     /// @{
 
-    /// Observer objects to notify when the @c AudioInputProvder changes states.
-    std::unordered_set<std::shared_ptr<ObserverInterface>> m_observers;
-
     /**
      * Default @c AudioProvider which was passed to the constructor; used for ExpectSpeech directives when
      * @c m_lastAudioProvider is not capable of streaming on demand (@c AudioProvider::alwaysReadable).
@@ -967,6 +992,32 @@ private:
      *     before the Executor Thread Variables are destroyed.
      */
     avsCommon::utils::threading::Executor m_executor;
+
+    /**
+     * The object that relays @c AudioInputProcessor state changes to registered observers.
+     * */
+    acsdkNotifier::Notifier<avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface>
+        m_audioInputProcessorStateNotifier;
+
+    /**
+     * Current AgentId.
+     * */
+    avsCommon::avs::AgentId::IdType m_agentId;
+
+    /**
+     * Current DirectiveInfo.
+     * */
+    std::shared_ptr<DirectiveInfo> m_directiveInfo;
+
+    /**
+     * The instance of the @c AgentManagerInterface to use for getting agent related information.
+     * */
+    std::shared_ptr<multiAgentInterface::AgentManagerInterface> m_agentManager;
+
+    /**
+     * The @c AlexaInterfaceMessageSenderInterface used to send event messages.
+     * */
+    std::shared_ptr<avsCommon::sdkInterfaces::AlexaInterfaceMessageSenderInterface> m_alexaMessageSender;
 };
 
 }  // namespace aip
diff --git a/CapabilityAgents/AIP/include/AIP/Initiator.h b/CapabilityAgents/AIP/include/AIP/Initiator.h
deleted file mode 100644
index f2be71af..00000000
--- a/CapabilityAgents/AIP/include/AIP/Initiator.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *     http://aws.amazon.com/apache2.0/
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
-#ifndef ALEXA_CLIENT_SDK_CAPABILITYAGENTS_AIP_INCLUDE_AIP_INITIATOR_H_
-#define ALEXA_CLIENT_SDK_CAPABILITYAGENTS_AIP_INCLUDE_AIP_INITIATOR_H_
-
-namespace alexaClientSDK {
-namespace capabilityAgents {
-namespace aip {
-
-#include <string>
-
-/**
- * Enumerates the different initiators supported by AVS.
- */
-enum class Initiator {
-    /// Recognize event was initiated by a press-and-hold action.
-    PRESS_AND_HOLD,
-    /// Recognize event was initiated by a tap-to-talk action.
-    TAP,
-    /// Recognize event was initiated by a wakeword action.
-    WAKEWORD
-};
-
-/**
- * Convert an @c Initiator value to an AVS-compliant string.
- *
- * @param initiator The initiator value to convert to a string.
- * @return The @c std::string conversion of the @c Initiator value.
- */
-inline std::string initiatorToString(Initiator initiator) {
-    switch (initiator) {
-        case Initiator::PRESS_AND_HOLD:
-            return "PRESS_AND_HOLD";
-        case Initiator::TAP:
-            return "TAP";
-        case Initiator::WAKEWORD:
-            return "WAKEWORD";
-    }
-    return "Unknown Inititator";
-}
-
-}  // namespace aip
-}  // namespace capabilityAgents
-}  // namespace alexaClientSDK
-
-#endif  // ALEXA_CLIENT_SDK_CAPABILITYAGENTS_AIP_INCLUDE_AIP_INITIATOR_H_
diff --git a/CapabilityAgents/AIP/src/AudioInputProcessor.cpp b/CapabilityAgents/AIP/src/AudioInputProcessor.cpp
index d0944a00..bec39f28 100644
--- a/CapabilityAgents/AIP/src/AudioInputProcessor.cpp
+++ b/CapabilityAgents/AIP/src/AudioInputProcessor.cpp
@@ -100,13 +100,19 @@ static const std::string CHANNEL_NAME = FocusManagerInterface::DIALOG_CHANNEL_NA
 static const std::string NAMESPACE = "SpeechRecognizer";
 
 /// The StopCapture directive signature.
-static const avsCommon::avs::NamespaceAndName STOP_CAPTURE{NAMESPACE, "StopCapture"};
+static const avsCommon::avs::NamespaceAndName STOP_CAPTURE{NAMESPACE,
+                                                           "StopCapture",
+                                                           avsCommon::avs::AgentId::AGENT_ID_ALL};
 
 /// The ExpectSpeech directive signature.
-static const avsCommon::avs::NamespaceAndName EXPECT_SPEECH{NAMESPACE, "ExpectSpeech"};
+static const avsCommon::avs::NamespaceAndName EXPECT_SPEECH{NAMESPACE,
+                                                            "ExpectSpeech",
+                                                            avsCommon::avs::AgentId::AGENT_ID_ALL};
 
 /// The SetEndOfSpeechOffset directive signature.
-static const avsCommon::avs::NamespaceAndName SET_END_OF_SPEECH_OFFSET{NAMESPACE, "SetEndOfSpeechOffset"};
+static const avsCommon::avs::NamespaceAndName SET_END_OF_SPEECH_OFFSET{NAMESPACE,
+                                                                       "SetEndOfSpeechOffset",
+                                                                       avsCommon::avs::AgentId::AGENT_ID_ALL};
 
 /// The SetWakeWordConfirmation directive signature.
 static const avsCommon::avs::NamespaceAndName SET_WAKE_WORD_CONFIRMATION{NAMESPACE, "SetWakeWordConfirmation"};
@@ -275,20 +281,47 @@ static std::string encodingFormatToString(avsCommon::utils::AudioFormat::Encodin
     return "UNKNOWN";
 }
 
+/**
+ * Helper function to add directive routing rules and their respective blocking policy.
+ * @param agentManager The object to use for AgentManager operations.
+ * @param configuration Map of blocking policies per @c DirectiveRoutingRule
+ * @param avsNameSpace namespace value to identify AVSDirective
+ * @param avsName name value to identify AVSDirective
+ * @param policy blocking policy for the DirectiveRoutingRule
+ */
+static void DirectiveHandlerConfigurationHelper(
+    const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager,
+    DirectiveHandlerConfiguration& configuration,
+    const std::string& avsNameSpace,
+    const std::string& avsName,
+    const BlockingPolicy& policy) {
+    if (!agentManager) {
+        configuration[avsCommon::avs::NamespaceAndName(avsNameSpace, avsName)] = policy;
+    } else {
+        auto agentIds = agentManager->getAVSInterfaceEnabledAgentIds(avsNameSpace, avsName);
+        for (const auto& agentId : agentIds) {
+            configuration[avsCommon::avs::NamespaceAndName(avsNameSpace, avsName, agentId)] = policy;
+        }
+    }
+}
+
 /**
  * Handles a Metric event by creating and recording it. Failure to create or record the event results
  * in an early return.
  *
  * @param metricRecorder The @c MetricRecorderInterface which records Metric events.
  * @param metricEventBuilder The @c MetricEventBuilder.
+ * @param metricContext The metric context of current metric event
  * @param dialogRequestId The dialogRequestId associated with this Metric event; default is empty string.
  */
 static void submitMetric(
     const std::shared_ptr<MetricRecorderInterface>& metricRecorder,
     MetricEventBuilder& metricEventBuilder,
+    const MetricContext& metricContext,
     const std::string& dialogRequestId = "") {
     metricEventBuilder.addDataPoint(
         DataPointStringBuilder{}.setName("DIALOG_REQUEST_ID").setValue(dialogRequestId).build());
+    metricEventBuilder.setMetricContext(metricContext);
 
     auto metricEvent = metricEventBuilder.build();
 
@@ -316,6 +349,7 @@ static void submitMetric(
     auto metricEventBuilder = MetricEventBuilder{}.setActivityName(activityName).addDataPoint(dataPoint);
 
     if (directive != nullptr) {
+        metricEventBuilder.setMetricContext(MetricContext{directive->getAgentId()});
         metricEventBuilder.addDataPoint(
             DataPointStringBuilder{}.setName("HTTP2_STREAM").setValue(directive->getAttachmentContextId()).build());
         metricEventBuilder.addDataPoint(
@@ -338,12 +372,14 @@ static void submitMetric(
  * @param metricRecorder The @c MetricRecorderInterface which records Metric events.
  * @param segmentId The segmentId corresponding to this metric event.
  * @param name The name of this metric
+ * @param metricContext The metric context of current metric event
  * @param metadata Any metadata to be associated with this metric; default is empty
  */
 static void submitInstanceEntryMetric(
     const std::shared_ptr<MetricRecorderInterface>& metricRecorder,
     const std::string& segmentId,
     const std::string& name,
+    const MetricContext& metricContext,
     const std::map<std::string, std::string>& metadata = {}) {
     if (segmentId.empty() || name.empty()) {
         ACSDK_ERROR(LX(__FUNCTION__).m("Unable to create instance metric").d("segmentId", segmentId).d("name", name));
@@ -351,6 +387,7 @@ static void submitInstanceEntryMetric(
     }
 
     auto metricBuilder = MetricEventBuilder{}.setActivityName(ENTRY_METRIC_ACTIVITY_NAME);
+    metricBuilder.setMetricContext(metricContext);
     metricBuilder.addDataPoint(
         DataPointStringBuilder{}.setName(ENTRY_METRIC_KEY_SEGMENT_ID).setValue(segmentId).build());
     metricBuilder.addDataPoint(
@@ -414,7 +451,9 @@ std::shared_ptr<AudioInputProcessor> AudioInputProcessor::create(
     AudioProvider defaultAudioProvider,
     std::shared_ptr<PowerResourceManagerInterface> powerResourceManager,
     std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder,
-    const std::shared_ptr<ExpectSpeechTimeoutHandler>& expectSpeechTimeoutHandler) {
+    const std::shared_ptr<ExpectSpeechTimeoutHandler>& expectSpeechTimeoutHandler,
+    const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager,
+    const std::shared_ptr<avsCommon::sdkInterfaces::AlexaInterfaceMessageSenderInterface>& alexaMessageSender) {
     if (!directiveSequencer) {
         ACSDK_ERROR(LX("createFailed").d("reason", "nullDirectiveSequencer"));
         return nullptr;
@@ -479,7 +518,9 @@ std::shared_ptr<AudioInputProcessor> AudioInputProcessor::create(
         capabilitiesConfiguration,
         powerResourceManager,
         std::move(metricRecorder),
-        expectSpeechTimeoutHandler));
+        expectSpeechTimeoutHandler,
+        agentManager,
+        alexaMessageSender));
 
     if (!aip->initialize()) {
         ACSDK_ERROR(LX("createFailed").d("reason", "unableToInitialize"));
@@ -494,12 +535,30 @@ std::shared_ptr<AudioInputProcessor> AudioInputProcessor::create(
 
 avsCommon::avs::DirectiveHandlerConfiguration AudioInputProcessor::getConfiguration() const {
     avsCommon::avs::DirectiveHandlerConfiguration configuration;
-    configuration[STOP_CAPTURE] = BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false);
-    configuration[EXPECT_SPEECH] = BlockingPolicy(BlockingPolicy::MEDIUM_AUDIO, true);
-    configuration[SET_END_OF_SPEECH_OFFSET] = BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false);
-    configuration[SET_WAKE_WORD_CONFIRMATION] = BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false);
-    configuration[SET_SPEECH_CONFIRMATION] = BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false);
-    configuration[SET_WAKE_WORDS] = BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false);
+    DirectiveHandlerConfigurationHelper(
+        m_agentManager, configuration, NAMESPACE, "StopCapture", BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false));
+    DirectiveHandlerConfigurationHelper(
+        m_agentManager, configuration, NAMESPACE, "ExpectSpeech", BlockingPolicy(BlockingPolicy::MEDIUM_AUDIO, true));
+    DirectiveHandlerConfigurationHelper(
+        m_agentManager,
+        configuration,
+        NAMESPACE,
+        "SetEndOfSpeechOffset",
+        BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false));
+    DirectiveHandlerConfigurationHelper(
+        m_agentManager,
+        configuration,
+        NAMESPACE,
+        "SetWakeWordConfirmation",
+        BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false));
+    DirectiveHandlerConfigurationHelper(
+        m_agentManager,
+        configuration,
+        NAMESPACE,
+        "SetSpeechConfirmation",
+        BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false));
+    DirectiveHandlerConfigurationHelper(
+        m_agentManager, configuration, NAMESPACE, "SetWakeWords", BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false));
     return configuration;
 }
 
@@ -508,7 +567,7 @@ void AudioInputProcessor::addObserver(std::shared_ptr<ObserverInterface> observe
         ACSDK_ERROR(LX("addObserverFailed").d("reason", "nullObserver"));
         return;
     }
-    m_executor.submit([this, observer]() { m_observers.insert(observer); });
+    m_audioInputProcessorStateNotifier.addWeakPtrObserver(observer);
 }
 
 void AudioInputProcessor::removeObserver(std::shared_ptr<ObserverInterface> observer) {
@@ -516,12 +575,12 @@ void AudioInputProcessor::removeObserver(std::shared_ptr<ObserverInterface> obse
         ACSDK_ERROR(LX("removeObserverFailed").d("reason", "nullObserver"));
         return;
     }
-    m_executor.submit([this, observer]() { m_observers.erase(observer); }).wait();
+    m_audioInputProcessorStateNotifier.removeWeakPtrObserver(observer);
 }
 
 std::future<bool> AudioInputProcessor::recognize(
     AudioProvider audioProvider,
-    Initiator initiator,
+    avsCommon::avs::AgentInitiator initiator,
     steady_clock::time_point startOfSpeechTimestamp,
     avsCommon::avs::AudioInputStream::Index begin,
     avsCommon::avs::AudioInputStream::Index keywordEnd,
@@ -603,8 +662,18 @@ void AudioInputProcessor::handleDirective(std::shared_ptr<DirectiveInfo> info) {
         ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "nullDirective"));
         return;
     }
+    auto directiveName = info->directive->getName();
+    if (directiveName == EXPECT_SPEECH.name || directiveName == SET_END_OF_SPEECH_OFFSET.name ||
+        directiveName == STOP_CAPTURE.name) {
+        m_directiveInfo = info;
+        auto agentId = info->directive->getAgentId();
+        if (m_agentId != agentId) {
+            m_agentId = agentId;
+            ACSDK_DEBUG5(LX(__func__).d("currentAgentId", m_agentId));
+        }
+    }
 
-    if (info->directive->getName() == STOP_CAPTURE.name) {
+    if (directiveName == STOP_CAPTURE.name) {
         ACSDK_METRIC_MSG(TAG, info->directive, Metrics::Location::AIP_RECEIVE);
         submitMetric(
             m_metricRecorder,
@@ -612,15 +681,15 @@ void AudioInputProcessor::handleDirective(std::shared_ptr<DirectiveInfo> info) {
             DataPointCounterBuilder{}.setName(STOP_CAPTURE_RECEIVED).increment(1).build(),
             info->directive);
         handleStopCaptureDirective(info);
-    } else if (info->directive->getName() == EXPECT_SPEECH.name) {
+    } else if (directiveName == EXPECT_SPEECH.name) {
         handleExpectSpeechDirective(info);
-    } else if (info->directive->getName() == SET_END_OF_SPEECH_OFFSET.name) {
+    } else if (directiveName == SET_END_OF_SPEECH_OFFSET.name) {
         handleSetEndOfSpeechOffsetDirective(info);
-    } else if (info->directive->getName() == SET_WAKE_WORD_CONFIRMATION.name) {
+    } else if (directiveName == SET_WAKE_WORD_CONFIRMATION.name) {
         handleSetWakeWordConfirmation(info);
-    } else if (info->directive->getName() == SET_SPEECH_CONFIRMATION.name) {
+    } else if (directiveName == SET_SPEECH_CONFIRMATION.name) {
         handleSetSpeechConfirmation(info);
-    } else if (info->directive->getName() == SET_WAKE_WORDS.name) {
+    } else if (directiveName == SET_WAKE_WORDS.name) {
         handleSetWakeWords(info);
     } else {
         std::string errorMessage =
@@ -635,7 +704,7 @@ void AudioInputProcessor::handleDirective(std::shared_ptr<DirectiveInfo> info) {
         ACSDK_ERROR(LX("handleDirectiveFailed")
                         .d("reason", "unknownDirective")
                         .d("namespace", info->directive->getNamespace())
-                        .d("name", info->directive->getName()));
+                        .d("name", directiveName));
         removeDirective(info);
     }
 }
@@ -653,7 +722,9 @@ void AudioInputProcessor::onFocusChanged(avsCommon::avs::FocusState newFocus, av
     m_executor.submit([this, newFocus]() { executeOnFocusChanged(newFocus); });
 }
 
-void AudioInputProcessor::onDialogUXStateChanged(DialogUXStateObserverInterface::DialogUXState newState) {
+void AudioInputProcessor::onDialogUXStateChanged(
+    avsCommon::avs::AgentId::IdType agentId,
+    DialogUXStateObserverInterface::DialogUXState newState) {
     m_executor.submit([this, newState]() { executeOnDialogUXStateChanged(newState); });
 }
 
@@ -675,7 +746,9 @@ AudioInputProcessor::AudioInputProcessor(
     std::shared_ptr<avsCommon::avs::CapabilityConfiguration> capabilitiesConfiguration,
     std::shared_ptr<PowerResourceManagerInterface> powerResourceManager,
     std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder,
-    const std::shared_ptr<ExpectSpeechTimeoutHandler>& expectSpeechTimeoutHandler) :
+    const std::shared_ptr<ExpectSpeechTimeoutHandler>& expectSpeechTimeoutHandler,
+    const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager,
+    const std::shared_ptr<avsCommon::sdkInterfaces::AlexaInterfaceMessageSenderInterface>& alexaMessageSender) :
         CapabilityAgent{NAMESPACE, exceptionEncounteredSender},
         RequiresShutdown{"AudioInputProcessor"},
         m_metricRecorder{metricRecorder},
@@ -707,7 +780,9 @@ AudioInputProcessor::AudioInputProcessor(
         m_resourceFlags{0},
         m_usingEncoder{false},
         m_messageRequestResolver{nullptr},
-        m_encodingAudioFormats{{DEFAULT_RESOLVE_KEY, AudioFormat::Encoding::LPCM}} {
+        m_encodingAudioFormats{{DEFAULT_RESOLVE_KEY, AudioFormat::Encoding::LPCM}},
+        m_agentManager{agentManager},
+        m_alexaMessageSender{alexaMessageSender} {
     m_capabilityConfigurations.insert(capabilitiesConfiguration);
 
     if (m_powerResourceManager) {
@@ -778,11 +853,15 @@ void AudioInputProcessor::doShutdown() {
     m_contextManager.reset();
     m_focusManager.reset();
     m_userInactivityMonitor.reset();
-    m_observers.clear();
     m_expectSpeechTimeoutHandler.reset();
     if (m_powerResourceManager && m_powerResourceId) {
         m_powerResourceManager->close(m_powerResourceId);
     }
+    if (m_agentManager) {
+        m_agentManager->removeAgentEnablementObserverInterface(
+            avsCommon::avs::AgentId::AGENT_ID_ALL, shared_from_this());
+        m_agentManager.reset();
+    }
 }
 
 bool resolveMessageRequest(
@@ -829,6 +908,8 @@ bool resolveMessageRequest(
             rapidjson::StringRef(FORMAT_KEY.c_str()), formatValue, eventWithContext.GetAllocator());
     }
 
+    MetricContext metricContext(request->getAgentId());
+
     // emit metric
     auto metricEvent = MetricEventBuilder{}
                            .setActivityName(AUDIO_ENCODING_FORMAT_ACTIVITY_NAME)
@@ -838,13 +919,15 @@ bool resolveMessageRequest(
             submitMetric(
                 metricRecorder,
                 metricEvent.addDataPoint(
-                    DataPointCounterBuilder{}.setName(AUDIO_ENCODING_FORMAT_LPCM).increment(1).build()));
+                    DataPointCounterBuilder{}.setName(AUDIO_ENCODING_FORMAT_LPCM).increment(1).build()),
+                metricContext);
             break;
         case AudioFormat::Encoding::OPUS:
             submitMetric(
                 metricRecorder,
                 metricEvent.addDataPoint(
-                    DataPointCounterBuilder{}.setName(AUDIO_ENCODING_FORMAT_OPUS).increment(1).build()));
+                    DataPointCounterBuilder{}.setName(AUDIO_ENCODING_FORMAT_OPUS).increment(1).build()),
+                metricContext);
             break;
         default:
             break;
@@ -862,6 +945,32 @@ bool resolveMessageRequest(
     return true;
 }
 
+void AudioInputProcessor::onEnabled(avsCommon::avs::AgentId::IdType id) {
+    // No-op
+}
+
+void AudioInputProcessor::onDisabled(avsCommon::avs::AgentId::IdType id) {
+    if (m_agentManager && (m_agentId == id)) {
+        resetState();
+        if (m_alexaMessageSender) {
+            // AIP is currently handling a directive for the agentId that is getting disabled,
+            // send an error response event back in this scenario.
+            if (m_directiveInfo && !m_alexaMessageSender->sendErrorResponseEvent(
+                                       m_directiveInfo->directive->getInstance(),
+                                       m_directiveInfo->directive->getCorrelationToken(),
+                                       m_directiveInfo->directive->getEndpoint().value().endpointId,
+                                       AlexaInterfaceMessageSenderInterface::ErrorResponseType::NO_SUCH_ENDPOINT,
+                                       "AgentID Disabled")) {
+                ACSDK_ERROR(LX("executeSendErrorResponseFailed").d("reason", "failedToSendEvent"));
+            }
+        }
+    }
+}
+
+avsCommon::avs::AgentId::IdType AudioInputProcessor::getAgentId() const {
+    return m_agentId;
+}
+
 std::future<bool> AudioInputProcessor::expectSpeechTimedOut() {
     return m_executor.submit([this]() { return executeExpectSpeechTimedOut(); });
 }
@@ -927,6 +1036,8 @@ void AudioInputProcessor::handleSetEndOfSpeechOffsetDirective(std::shared_ptr<Di
             info->directive);
         std::istringstream iss{startOfSpeechTimeStampInString};
         iss >> startOfSpeechTimestamp;
+        // convert startOfSpeechTimestamp to ms
+        startOfSpeechTimestamp = startOfSpeechTimestamp / MILLISECONDS_PER_SECOND;
 
         ACSDK_DEBUG0(LX("handleSetEndOfSpeechOffsetDirective")
                          .d("startTimeSpeech(ms)", startOfSpeechTimestamp)
@@ -950,7 +1061,7 @@ void AudioInputProcessor::handleSetEndOfSpeechOffsetDirective(std::shared_ptr<Di
 
 bool AudioInputProcessor::executeRecognize(
     AudioProvider provider,
-    Initiator initiator,
+    avsCommon::avs::AgentInitiator initiator,
     steady_clock::time_point startOfSpeechTimestamp,
     avsCommon::avs::AudioInputStream::Index begin,
     avsCommon::avs::AudioInputStream::Index end,
@@ -958,7 +1069,7 @@ bool AudioInputProcessor::executeRecognize(
     std::shared_ptr<const std::vector<char>> KWDMetadata,
     const std::string& initiatorToken) {
     // Make sure we have a keyword if this is a wakeword initiator.
-    if (Initiator::WAKEWORD == initiator && keyword.empty()) {
+    if (avsCommon::avs::AgentInitiator::WAKEWORD == initiator && keyword.empty()) {
         ACSDK_ERROR(LX("executeRecognizeFailed").d("reason", "emptyKeywordWithWakewordInitiator"));
         return false;
     }
@@ -968,8 +1079,8 @@ bool AudioInputProcessor::executeRecognize(
 
     // Check if we have everything we need to enable false wakeword detection.
     // TODO: Consider relaxing the hard requirement for a full 500ms preroll - ACSDK-276.
-    bool falseWakewordDetection =
-        Initiator::WAKEWORD == initiator && begin != INVALID_INDEX && begin >= preroll && end != INVALID_INDEX;
+    bool falseWakewordDetection = avsCommon::avs::AgentInitiator::WAKEWORD == initiator && begin != INVALID_INDEX &&
+                                  begin >= preroll && end != INVALID_INDEX;
 
     // If we will be enabling false wakeword detection, add preroll and build the initiator payload.
     json::JsonGenerator generator;
@@ -984,6 +1095,9 @@ bool AudioInputProcessor::executeRecognize(
         generator.finishObject();
 
         begin -= preroll;
+
+        // Calculate startOfSpeechTimestamp by subtracting preroll.
+        startOfSpeechTimestamp -= PREROLL_DURATION;
     }
 
     if (!keyword.empty()) {
@@ -994,11 +1108,27 @@ bool AudioInputProcessor::executeRecognize(
         generator.addMember(TOKEN_KEY, initiatorToken);
     }
 
-    bool initiatedByWakeword = (Initiator::WAKEWORD == initiator) ? true : false;
+    bool initiatedByWakeword = (avsCommon::avs::AgentInitiator::WAKEWORD == initiator) ? true : false;
+
+    auto agentId = avsCommon::avs::AgentId::AGENT_ID_NONE;
+    if (m_agentManager) {
+        if (initiatedByWakeword) {
+            agentId = m_agentManager->resolveWakeWord(string::stringToUpperCase(keyword));
+        } else {
+            agentId = m_agentManager->resolveGesture(initiator);
+        }
+        if (avsCommon::avs::AgentId::AGENT_ID_NONE == agentId) {
+            ACSDK_ERROR(LX("executeRecognizeFailed").d("reason", "unknownAgent"));
+            return false;
+        }
+    } else {
+        agentId = avsCommon::avs::AgentId::getAlexaAgentId();
+    }
 
     return executeRecognize(
         provider,
         generator.toString(),
+        agentId,
         startOfSpeechTimestamp,
         begin,
         end,
@@ -1012,6 +1142,7 @@ bool AudioInputProcessor::executeRecognize(
 bool AudioInputProcessor::executeRecognize(
     AudioProvider provider,
     const std::string& initiatorJson,
+    const avsCommon::avs::AgentId::IdType& agentId,
     steady_clock::time_point startOfSpeechTimestamp,
     avsCommon::avs::AudioInputStream::Index begin,
     avsCommon::avs::AudioInputStream::Index end,
@@ -1104,6 +1235,11 @@ bool AudioInputProcessor::executeRecognize(
             return false;
     }
 
+    if (m_agentId != agentId) {
+        m_agentId = agentId;
+        ACSDK_DEBUG5(LX(__func__).d("currentAgentId", m_agentId));
+    }
+
     if (settings::WakeWordConfirmationSettingType::TONE == m_wakeWordConfirmation->get()) {
         m_executor.submit(
             [this]() { m_systemSoundPlayer->playTone(SystemSoundPlayerInterface::Tone::WAKEWORD_NOTIFICATION); });
@@ -1213,7 +1349,8 @@ bool AudioInputProcessor::executeRecognize(
                     submitMetric(
                         m_metricRecorder,
                         metricEvent.addDataPoint(
-                            DataPointCounterBuilder{}.setName(AUDIO_ENCODING_FORMAT_OPUS).increment(1).build()));
+                            DataPointCounterBuilder{}.setName(AUDIO_ENCODING_FORMAT_OPUS).increment(1).build()),
+                        MetricContext(m_agentId));
                     m_audioBytesForMetricThreshold = WAKEWORD_DETECTION_SEGMENT_SIZE_BYTES_OPUS;
                     m_uploadMetricName = WAKEWORD_DETECTION_SEGMENT_UPLOADED_OPUS;
                     break;
@@ -1221,7 +1358,8 @@ bool AudioInputProcessor::executeRecognize(
                     submitMetric(
                         m_metricRecorder,
                         metricEvent.addDataPoint(
-                            DataPointCounterBuilder{}.setName(AUDIO_ENCODING_FORMAT_LPCM).increment(1).build()));
+                            DataPointCounterBuilder{}.setName(AUDIO_ENCODING_FORMAT_LPCM).increment(1).build()),
+                        MetricContext(m_agentId));
                     m_audioBytesForMetricThreshold = WAKEWORD_DETECTION_SEGMENT_SIZE_BYTES_PCM;
                     m_uploadMetricName = WAKEWORD_DETECTION_SEGMENT_UPLOADED_PCM;
                     break;
@@ -1251,7 +1389,7 @@ bool AudioInputProcessor::executeRecognize(
     m_streamIsClosedInRecognizingState = false;
 
     //  Start assembling the context; we'll service the callback after assembling our Recognize event.
-    m_contextManager->getContextWithoutReportableStateProperties(shared_from_this());
+    m_contextManager->getContextWithoutReportableStateProperties(shared_from_this(), m_agentId);
 
     // Stop the ExpectSpeech timer so we don't get a timeout.
     m_expectingSpeechTimer.stop();
@@ -1283,6 +1421,7 @@ bool AudioInputProcessor::executeRecognize(
                               .setValue(std::to_string(m_resourceFlags.to_ulong()))
                               .build())
             .addDataPoint(DataPointCounterBuilder{}.setName(START_OF_UTTERANCE).increment(1).build()),
+        MetricContext(m_agentId),
         m_preCachedDialogRequestId);
 
     /// Submit initiator metric if available.
@@ -1293,27 +1432,24 @@ bool AudioInputProcessor::executeRecognize(
                 .setActivityName(INITIATOR_ACTIVITY_NAME_PREFIX + initiatorString)
                 .addDataPoint(
                     DataPointCounterBuilder{}.setName(INITIATOR_PREFIX + initiatorString).increment(1).build()),
+            MetricContext(m_agentId),
             m_preCachedDialogRequestId);
     }
 
     if (initiatedByWakeword) {
         auto duration = milliseconds((end - begin) * MILLISECONDS_PER_SECOND / provider.format.sampleRateHz);
 
-        auto startOfStreamTimestamp = startOfSpeechTimestamp;
-        if (falseWakewordDetection) {
-            startOfStreamTimestamp -= PREROLL_DURATION;
-        }
-
         submitMetric(
             m_metricRecorder,
             MetricEventBuilder{}
                 .setActivityName(WW_DURATION_ACTIVITY_NAME)
                 .addDataPoint(DataPointDurationBuilder{duration}.setName(WW_DURATION).build())
                 .addDataPoint(
-                    DataPointDurationBuilder{duration_cast<milliseconds>(startOfStreamTimestamp.time_since_epoch())}
+                    DataPointDurationBuilder{duration_cast<milliseconds>(startOfSpeechTimestamp.time_since_epoch())}
                         .setName(START_OF_STREAM_TIMESTAMP)
                         .build())
                 .addDataPoint(DataPointCounterBuilder{}.setName(RECOGNIZE_START_SEND_MESSAGE).increment(1).build()),
+            MetricContext(m_agentId),
             m_preCachedDialogRequestId);
         ACSDK_DEBUG(LX(__func__).d("WW_DURATION(ms)", duration.count()));
     }
@@ -1322,6 +1458,7 @@ bool AudioInputProcessor::executeRecognize(
         m_metricRecorder,
         m_preCachedDialogRequestId,
         START_OF_UTTERANCE,
+        MetricContext(m_agentId),
         std::map<std::string, std::string>{{"initiator", !initiatorString.empty() ? initiatorString : "unknown"}});
 
     return true;
@@ -1373,6 +1510,7 @@ void AudioInputProcessor::executeOnContextAvailable(const std::string& jsonConte
     if (m_messageRequestResolver) {
         // Create unresolved MessageRequest
         m_recognizeRequest = std::make_shared<MessageRequest>(
+            m_agentId,
             msgIdAndJsonEvent.second,
             true,
             "",
@@ -1382,7 +1520,7 @@ void AudioInputProcessor::executeOnContextAvailable(const std::string& jsonConte
             m_uploadMetricName);
     } else {
         m_recognizeRequest = std::make_shared<MessageRequest>(
-            msgIdAndJsonEvent.second, m_audioBytesForMetricThreshold, m_uploadMetricName);
+            m_agentId, msgIdAndJsonEvent.second, m_audioBytesForMetricThreshold, m_uploadMetricName);
         // Only add attachment readers for resolved MessageRequest. For unresolved one, attachment readers will be
         // passed to the resolver function.
         if (!m_attachmentReaders.empty() && !m_attachmentReaders.begin()->second.empty()) {
@@ -1519,11 +1657,13 @@ void AudioInputProcessor::executeResetState() {
     m_recognizeRequest.reset();
     m_preparingToSend = false;
     m_deferredStopCapture = nullptr;
+    m_directiveInfo.reset();
     if (m_focusState != avsCommon::avs::FocusState::NONE) {
         m_focusManager->releaseChannel(CHANNEL_NAME, shared_from_this());
     }
     m_focusState = avsCommon::avs::FocusState::NONE;
     setState(ObserverInterface::State::IDLE);
+    m_agentId = avsCommon::avs::AgentId::AGENT_ID_NONE;
     m_audioBytesForMetricThreshold = 0;
 }
 
@@ -1581,9 +1721,9 @@ bool AudioInputProcessor::executeExpectSpeech(milliseconds timeout, std::shared_
 
     // If possible, start recognizing immediately.
     if (m_lastAudioProvider && m_lastAudioProvider.alwaysReadable) {
-        return executeRecognize(m_lastAudioProvider, "");
+        return executeRecognize(m_lastAudioProvider, "", m_agentId);
     } else if (m_defaultAudioProvider && m_defaultAudioProvider.alwaysReadable) {
-        return executeRecognize(m_defaultAudioProvider, "");
+        return executeRecognize(m_defaultAudioProvider, "", m_agentId);
     }
 
     return true;
@@ -1599,7 +1739,7 @@ bool AudioInputProcessor::executeExpectSpeechTimedOut() {
     }
     m_precedingExpectSpeechInitiator.reset();
     auto msgIdAndJsonEvent = buildJsonEventString("ExpectSpeechTimedOut");
-    auto request = std::make_shared<MessageRequest>(msgIdAndJsonEvent.second);
+    auto request = std::make_shared<MessageRequest>(m_agentId, msgIdAndJsonEvent.second);
     request->addObserver(shared_from_this());
     m_messageSender->sendMessage(request);
     setState(ObserverInterface::State::IDLE);
@@ -1642,6 +1782,7 @@ void AudioInputProcessor::setState(ObserverInterface::State state) {
             m_metricRecorder,
             currentDialogRequestId,
             ENTRY_METRIC_NAME_STATE_CHANGE,
+            MetricContext(m_agentId),
             std::map<std::string, std::string>{{"from", ObserverInterface::stateToString(m_state)},
                                                {"to", ObserverInterface::stateToString(state)}});
     }
@@ -1650,9 +1791,10 @@ void AudioInputProcessor::setState(ObserverInterface::State state) {
     m_state = state;
     managePowerResource(m_state);
 
-    for (auto observer : m_observers) {
-        observer->onStateChanged(m_state);
-    }
+    m_audioInputProcessorStateNotifier.notifyObservers(
+        [state, this](const std::shared_ptr<avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface>& observer) {
+            observer->onStateChanged(m_agentId, state);
+        });
 }
 
 void AudioInputProcessor::removeDirective(std::shared_ptr<DirectiveInfo> info) {
@@ -1737,7 +1879,7 @@ void AudioInputProcessor::handleDirectiveFailure(
     std::shared_ptr<DirectiveInfo> info,
     avsCommon::avs::ExceptionErrorType errorType) {
     m_exceptionEncounteredSender->sendExceptionEncountered(
-        info->directive->getUnparsedDirective(), errorType, errorMessage);
+        info->directive->getAgentId(), info->directive->getUnparsedDirective(), errorType, errorMessage);
 
     if (info->result) {
         info->result->setFailed(errorMessage);
@@ -1883,6 +2025,7 @@ void AudioInputProcessor::managePowerResource(ObserverInterface::State newState)
                     .addDataPoint(DataPointDurationBuilder{duration_cast<milliseconds>(steady_clock::now() - startTime)}
                                       .setName(ACQUIRE_POWER_RESOURCE)
                                       .build()),
+                MetricContext(m_agentId),
                 m_preCachedDialogRequestId);
             break;
         case ObserverInterface::State::BUSY:
@@ -1895,6 +2038,7 @@ void AudioInputProcessor::managePowerResource(ObserverInterface::State newState)
                     .addDataPoint(DataPointDurationBuilder{duration_cast<milliseconds>(steady_clock::now() - startTime)}
                                       .setName(RELEASE_POWER_RESOURCE)
                                       .build()),
+                MetricContext(m_agentId),
                 m_preCachedDialogRequestId);
             break;
     }
diff --git a/CapabilityAgents/AIP/src/CMakeLists.txt b/CapabilityAgents/AIP/src/CMakeLists.txt
index 2c2eed53..236e26bd 100644
--- a/CapabilityAgents/AIP/src/CMakeLists.txt
+++ b/CapabilityAgents/AIP/src/CMakeLists.txt
@@ -13,12 +13,14 @@ target_include_directories(AIP PUBLIC
 
 target_link_libraries(AIP
     AVSCommon
+    acsdkDUXSA
     ADSL
     AFML
     DeviceSettings
     SpeechEncoder
     SystemSoundPlayer
-    acsdkNotifier)
+    acsdkNotifier
+    MultiAgentInterface)
 
 # install target
 asdk_install()
diff --git a/CapabilityAgents/AIP/test/AudioInputProcessorTest.cpp b/CapabilityAgents/AIP/test/AudioInputProcessorTest.cpp
index c1b553b7..e87e57ef 100644
--- a/CapabilityAgents/AIP/test/AudioInputProcessorTest.cpp
+++ b/CapabilityAgents/AIP/test/AudioInputProcessorTest.cpp
@@ -27,6 +27,7 @@
 #include <rapidjson/stringbuffer.h>
 #include <rapidjson/writer.h>
 
+#include <acsdk/MultiAgentInterface/MockAgentManager.h>
 #include <AVSCommon/AVS/CapabilityChangeNotifier.h>
 #include <AVSCommon/AVS/CapabilityChangeNotifierInterface.h>
 #include <AVSCommon/AVS/Attachment/MockAttachmentManager.h>
@@ -67,6 +68,7 @@ using namespace alexaClientSDK::settings::test;
 using namespace alexaClientSDK::settings::storage;
 using namespace alexaClientSDK::settings::storage::test;
 using namespace testing;
+using namespace alexaClientSDK::multiAgentInterface;
 using PowerResourceLevel = PowerResourceManagerInterface::PowerResourceLevel;
 
 namespace alexaClientSDK {
@@ -234,6 +236,15 @@ static const std::string EXPECT_SPEECH_TIMED_OUT_EVENT_NAME = "ExpectSpeechTimed
 /// Value used in the tests for a wakeword recognize event.
 static const std::string KEYWORD_TEXT = "ALEXA";
 
+/// Value used in the tests for another wakeword recognize event.
+static const std::string FOO_KEYWORD_TEXT = "FOO";
+
+/// Value used for agent Id for alexa wakeword.
+static const size_t AGENT_ID_ALEXA_WAKEWORD = 2;
+
+/// Value used for agent Id for foo wakeword.
+static const size_t AGENT_ID_FOO_WAKEWORD = 3;
+
 /// Boolean value to indicate a directive being tested has a dialog request ID.
 static const bool WITH_DIALOG_REQUEST_ID = true;
 
@@ -278,6 +289,10 @@ static const auto START_OF_SPEECH_TIMESTAMP = std::chrono::steady_clock::now();
 /// String value used for start of speech timestamp string representation.
 static const auto START_OF_SPEECH_TIMESTAMP_STR = std::to_string(START_OF_SPEECH_TIMESTAMP.time_since_epoch().count());
 
+/// String value used for start of speech timestamp with preroll string representation.
+static const auto START_OF_SPEECH_TIMESTAMP_PREROLL_STR =
+    std::to_string((START_OF_SPEECH_TIMESTAMP - PREROLL_MS).time_since_epoch().count());
+
 /// The index of the Wakeword engine metadata in the @c MessageRequest.
 static const size_t MESSAGE_ATTACHMENT_KWD_METADATA_INDEX = 0;
 
@@ -390,7 +405,7 @@ public:
      */
     RecognizeEvent(
         AudioProvider audioProvider,
-        Initiator initiator,
+        AgentInitiator initiator,
         avsCommon::avs::AudioInputStream::Index begin = AudioInputProcessor::INVALID_INDEX,
         avsCommon::avs::AudioInputStream::Index keywordEnd = AudioInputProcessor::INVALID_INDEX,
         std::string keyword = "",
@@ -445,12 +460,19 @@ public:
      * @param request The @c MessageRequest to verify.
      * @param pattern Vector of samples holding a test pattern expected from the @c AudioInputStream.
      * @param dialogRequestId The expected dialogRequestId in the @c MessageRequest.
+     * @param agentId The expected agentId in the @c MessageRequest.
+     * @param wakeword THe expected wakeWord in he @c MessageRequest
+     * @param expectedFormat The expected encoder format
+     * @param prerollNeeded If preroll are needed for the StartOfSpeechTimestamp
      */
     void verifyMessage(
         std::shared_ptr<avsCommon::avs::MessageRequest> request,
         const std::vector<Sample>& pattern,
         const std::string& dialogRequestId,
-        const std::string& expectedFormat = "");
+        const avsCommon::avs::AgentId::IdType agentId,
+        const std::string& wakeWord,
+        const std::string& expectedFormat = "",
+        bool prerollNeeded = false);
 
     /**
      * Accessor function to get the attachment reader for a verified message.
@@ -464,7 +486,7 @@ private:
     AudioProvider m_audioProvider;
 
     /// The initiator to use for this recognize event.
-    Initiator m_initiator;
+    avsCommon::avs::AgentInitiator m_initiator;
 
     /// The begin index to use for this recognize event.
     avsCommon::avs::AudioInputStream::Index m_begin;
@@ -490,7 +512,7 @@ private:
 
 RecognizeEvent::RecognizeEvent(
     AudioProvider audioProvider,
-    Initiator initiator,
+    avsCommon::avs::AgentInitiator initiator,
     avsCommon::avs::AudioInputStream::Index begin,
     avsCommon::avs::AudioInputStream::Index keywordEnd,
     std::string keyword,
@@ -559,7 +581,12 @@ void RecognizeEvent::verifyMessage(
     std::shared_ptr<avsCommon::avs::MessageRequest> request,
     const std::vector<Sample>& pattern,
     const std::string& dialogRequestId,
-    const std::string& expectedFormat) {
+    avsCommon::avs::AgentId::IdType agentId,
+    const std::string& wakeWord,
+    const std::string& expectedFormat,
+    bool prerollNeeded) {
+    EXPECT_EQ(agentId, request->getAgentId());
+
     rapidjson::Document document;
     document.Parse(request->getJsonContent().c_str());
     EXPECT_FALSE(document.HasParseError())
@@ -585,7 +612,12 @@ void RecognizeEvent::verifyMessage(
     profile << m_audioProvider.profile;
 
     EXPECT_EQ(getJsonString(payload->value, ASR_PROFILE_KEY), profile.str());
-    EXPECT_EQ(getJsonString(payload->value, START_OF_SPEECH_TIMESTAMP_FIELD_NAME), START_OF_SPEECH_TIMESTAMP_STR);
+    if (prerollNeeded) {
+        EXPECT_EQ(
+            getJsonString(payload->value, START_OF_SPEECH_TIMESTAMP_FIELD_NAME), START_OF_SPEECH_TIMESTAMP_PREROLL_STR);
+    } else {
+        EXPECT_EQ(getJsonString(payload->value, START_OF_SPEECH_TIMESTAMP_FIELD_NAME), START_OF_SPEECH_TIMESTAMP_STR);
+    }
 
     if (!expectedFormat.empty()) {
         EXPECT_EQ(getJsonString(payload->value, AUDIO_FORMAT_KEY), expectedFormat);
@@ -605,7 +637,7 @@ void RecognizeEvent::verifyMessage(
         auto initiatorPayload = initiator->value.FindMember(INITIATOR_PAYLOAD_KEY);
         EXPECT_NE(initiatorPayload, initiator->value.MemberEnd());
 
-        if (m_initiator == Initiator::WAKEWORD) {
+        if (m_initiator == AgentInitiator::WAKEWORD) {
             if (m_begin != AudioInputProcessor::INVALID_INDEX && m_keywordEnd != AudioInputProcessor::INVALID_INDEX) {
                 auto wakeWordIndices = initiatorPayload->value.FindMember(WAKE_WORD_INDICES_KEY);
                 EXPECT_NE(wakeWordIndices, initiatorPayload->value.MemberEnd());
@@ -615,7 +647,7 @@ void RecognizeEvent::verifyMessage(
                     EXPECT_EQ(getJsonInt64(wakeWordIndices->value, END_INDEX_KEY), static_cast<int64_t>(m_keywordEnd));
                 }
             }
-            EXPECT_EQ(getJsonString(initiatorPayload->value, WAKEWORD_FIELD_NAME), KEYWORD_TEXT);
+            EXPECT_EQ(getJsonString(initiatorPayload->value, WAKEWORD_FIELD_NAME), wakeWord);
         }
     }
 
@@ -658,7 +690,7 @@ public:
      */
     TestDialogUXStateObserver(std::shared_ptr<avsCommon::avs::DialogUXStateAggregator> aggregator);
 
-    void onDialogUXStateChanged(DialogUXState newState) override;
+    void onDialogUXStateChanged(avsCommon::avs::AgentId::IdType agentId, DialogUXState newState) override;
 
 private:
     /// The @c DialogUXStateAggregator to move from @c THINKING to @c IDLE.
@@ -670,9 +702,11 @@ TestDialogUXStateObserver::TestDialogUXStateObserver(
         m_aggregator(aggregator) {
 }
 
-void TestDialogUXStateObserver::onDialogUXStateChanged(DialogUXState newState) {
+void TestDialogUXStateObserver::onDialogUXStateChanged(
+    avsCommon::avs::AgentId::IdType agentId,
+    DialogUXState newState) {
     if (DialogUXState::THINKING == newState) {
-        m_aggregator->onRequestProcessingCompleted();
+        m_aggregator->onRequestProcessingCompleted(agentId);
     }
 }
 
@@ -704,8 +738,25 @@ public:
     MOCK_METHOD1(onConfigurationChanged, void(const avsCommon::avs::CapabilityConfiguration& configuration));
 };
 
+/**
+ * A struct to encapsulate audioInputProcessor data.
+ *
+ * @private
+ */
+struct AudioInputProcessorTestData {
+    AudioInputProcessorTestData(
+        const std::string& wakeword,
+        avsCommon::avs::AgentId::IdType agentId = avsCommon::avs::AgentId::AGENT_ID_NONE) :
+            m_wakeword(wakeword),
+            m_agentId(agentId) {
+    }
+
+    const std::string m_wakeword;
+    avsCommon::avs::AgentId::IdType m_agentId;
+};
+
 /// Test harness for @c AudioInputProcessor class.
-class AudioInputProcessorTest : public ::testing::Test {
+class AudioInputProcessorTest : public testing::TestWithParam<AudioInputProcessorTestData> {
 public:
     /// Set up the test harness for running a test.
     void SetUp() override;
@@ -728,6 +779,29 @@ protected:
         NONE
     };
 
+    /// Enumerate different points to call @c onDisabled() during @c testRecognizeSucceeds().
+    enum class RecognizeAgentDisablePoint {
+        /// Call @c onDisabled() immediately after the @c onContextAvailable() call.
+        AFTER_CONTEXT,
+        /// Call @c onDisabled() immediately after the @c onFocusChanged() call.
+        AFTER_FOCUS,
+        /// Do not call @c onDisabled() during the test.
+        NONE
+    };
+
+    /// Enumerate different points to call @c handleDirectiveImmediately() for SpeechConfirmation setting during
+    /// recognize.
+    enum class RecognizeSpeechConfirmationPoint {
+        /// Call @c handleDirectiveImmediately() for SpeechConfirmation setting immediately after the @c
+        /// onContextAvailable() call.
+        AFTER_CONTEXT,
+        /// Call @c handleDirectiveImmediately() for SpeechConfirmation setting immediately after the @c
+        /// onFocusChanged() call.
+        AFTER_FOCUS,
+        /// Do not call @c handleDirectiveImmediately() for SpeechConfirmation setting during the test.
+        NONE
+    };
+
     /// Enumerates the different points when to pass a stop capture directive to AIP via @c
     /// AudioInputProcessor::handleDirectiveImmediately())
     enum class StopCaptureDirectiveSchedule {
@@ -749,7 +823,7 @@ protected:
      */
     bool testRecognizeFails(
         AudioProvider audioProvider,
-        Initiator initiator,
+        AgentInitiator initiator,
         avsCommon::avs::AudioInputStream::Index begin = AudioInputProcessor::INVALID_INDEX,
         avsCommon::avs::AudioInputStream::Index keywordEnd = AudioInputProcessor::INVALID_INDEX,
         std::string keyword = "");
@@ -763,15 +837,18 @@ protected:
      */
     bool testRecognizeSucceeds(
         AudioProvider audioProvider,
-        Initiator initiator,
+        AgentInitiator initiator,
         avsCommon::avs::AudioInputStream::Index begin = AudioInputProcessor::INVALID_INDEX,
         avsCommon::avs::AudioInputStream::Index keywordEnd = AudioInputProcessor::INVALID_INDEX,
         std::string keyword = "",
+        avsCommon::avs::AgentId::IdType agentId = avsCommon::avs::AgentId::AGENT_ID_NONE,
         RecognizeStopPoint stopPoint = RecognizeStopPoint::NONE,
         std::shared_ptr<std::string> avsInitiator = nullptr,
         const std::shared_ptr<std::vector<char>> KWDMetadata = nullptr,
         std::string expectedFormat = "",
-        std::map<std::string, std::string> encodingFormats = {});
+        std::map<std::string, std::string> encodingFormats = {},
+        RecognizeAgentDisablePoint agentDisablePoint = RecognizeAgentDisablePoint::NONE,
+        RecognizeSpeechConfirmationPoint speechConfirmationPoint = RecognizeSpeechConfirmationPoint::NONE);
 
     /**
      * Function to call @c AudioInputProcessor::stopCapture() and verify that it succeeds.
@@ -794,51 +871,70 @@ protected:
      * correctly.
      *
      * @param withDialogRequestId A flag indicating whether to send the directive with a dialog request ID.
+     * @param agentId The agentId for the directive.
      * @return @c true if the call works correctly, else @c false.
      */
-    bool testStopCaptureDirectiveSucceeds(bool withDialogRequestId);
+    bool testStopCaptureDirectiveSucceeds(
+        bool withDialogRequestId,
+        avsCommon::avs::AgentId::IdType agentId = avsCommon::avs::AgentId::getAlexaAgentId());
 
     /**
      * Function to receive a StopCapture directive and verify that @c AudioInputProcessor rejects it.
      *
      * @param withDialogRequestId A flag indicating whether to send the directive with a dialog request ID.
+     * @param agentId The agentId for the directive.
      * @return @c true if the call fails as expected, else @c false.
      */
-    bool testStopCaptureDirectiveFails(bool withDialogRequestId);
+    bool testStopCaptureDirectiveFails(
+        bool withDialogRequestId,
+        avsCommon::avs::AgentId::IdType agentId = avsCommon::avs::AgentId::getAlexaAgentId());
 
     /**
      * Function to send an expect speech event and verify that it succeeds.
      *
      * @param withDialogRequestId A flag indicating whether to send the directive with a dialog request ID.
+     * @param agentId The agentId for expect speech event.
      * @return @c true if the call works correctly, else @c false.
      */
-    bool testExpectSpeechSucceeds(bool withDialogRequestId);
+    bool testExpectSpeechSucceeds(
+        bool withDialogRequestId,
+        avsCommon::avs::AgentId::IdType agentId = avsCommon::avs::AgentId::getAlexaAgentId());
 
     /**
      * Function to send an expect speech event and optionally verify that it times out.
      *
-     * @param withDialogRequestId A flag indicating whether to send the event with a dialog request ID.
+     * @param withDialogRequestId A flag indicating whether to send the event with a dialog request ID
      * @param verifyTimeout A flag indicating whether to wait for a timeout.
+     * @param agentId The agentId for expect speech event.
      * @return @c true if the call works correctly, else @c false.
      */
-    bool testExpectSpeechWaits(bool withDialogRequestId, bool verifyTimeout);
+    bool testExpectSpeechWaits(
+        bool withDialogRequestId,
+        bool verifyTimeout,
+        avsCommon::avs::AgentId::IdType agentId = avsCommon::avs::AgentId::getAlexaAgentId());
 
     /**
      * Function to send an expect speech event and verify that that external handling does not result in an internal
      * timeout.
      *
      * @param notifyBackOfTimeout Whether to notify the AIP of the ExpectSpeech timing out
+     * @param agentId The agentId for expect speech event.
      * @return @c true if the call works correctly, else @c false.
      */
-    bool testExpectSpeechExternalHandling(bool notifyBackOfTimeout);
+    bool testExpectSpeechExternalHandling(
+        bool notifyBackOfTimeout,
+        avsCommon::avs::AgentId::IdType agentId = avsCommon::avs::AgentId::getAlexaAgentId());
 
     /**
      * Function to send an expect speech event and optionally verify that it fails.
      *
      * @param withDialogRequestId A flag indicating whether to send the event with a dialog request ID.
+     * @param agentId The agentId for expect speech event.
      * @return @c true if the call fails as expected, else @c false.
      */
-    bool testExpectSpeechFails(bool withDialogRequestId);
+    bool testExpectSpeechFails(
+        bool withDialogRequestId,
+        avsCommon::avs::AgentId::IdType agentId = avsCommon::avs::AgentId::getAlexaAgentId());
 
     /**
      * Function to send an ExpectSpeech directive and verify the initiator is handled correctly on the
@@ -867,6 +963,21 @@ protected:
         bool withDialogRequestId,
         bool withInitiator = true);
 
+    /**
+     * Function to construct an @c AVSDirective for the specified namespace/name.
+     *
+     * @param directive The namespace and name to use for this directive.
+     * @param withDialogRequestId A flag indicating whether to include a dialog request ID.
+     * @param agentId The agentId for the  @c AVSDirective.
+     * @param withInitiator A flag indicating whether the directive should have an initiator.
+     * @return the constructed @c AVSDirective.
+     */
+    std::shared_ptr<avsCommon::avs::AVSDirective> createAVSDirective(
+        const avsCommon::avs::NamespaceAndName& directive,
+        bool withDialogRequestId,
+        avsCommon::avs::AgentId::IdType agentId,
+        bool withInitiator = true);
+
     /**
      * Function to construct an @c AVSDirective for the specified namespace/name, with the given payload.
      *
@@ -880,6 +991,7 @@ protected:
     std::shared_ptr<avsCommon::avs::AVSDirective> createAVSDirective(
         const avsCommon::avs::NamespaceAndName& directive,
         bool withDialogRequestId,
+        avsCommon::avs::AgentId::IdType agentId,
         bool withInitiator,
         rapidjson::Document& document,
         rapidjson::Value& payloadJson);
@@ -1025,9 +1137,19 @@ protected:
 
     /// Message ID in directive
     std::string m_messageId;
+
+    /// Mock AgentManager.
+    std::shared_ptr<MockAgentManager> m_mockAgentManager;
+
+    /// Mock AgentID
+    avsCommon::avs::AgentId::IdType m_agentId;
+
+    /// Flag to indicate whether we want to override agentId in gestures
+    bool m_overrideGestures = false;
 };
 
 void AudioInputProcessorTest::SetUp() {
+    avsCommon::avs::AgentId::setAlexaAgentId(2);
     m_metricRecorder = std::make_shared<NiceMock<avsCommon::utils::metrics::test::MockMetricRecorder>>();
     m_mockDirectiveSequencer = std::make_shared<avsCommon::sdkInterfaces::test::MockDirectiveSequencer>();
     m_mockMessageSender = std::make_shared<avsCommon::sdkInterfaces::test::MockMessageSender>();
@@ -1094,6 +1216,31 @@ void AudioInputProcessorTest::SetUp() {
         }));
     EXPECT_CALL(*m_mockPowerResourceManager, close(IsSamePowerResource(COMPONENT_NAME))).Times(AtLeast(1));
 
+    avsCommon::avs::AgentId::setAlexaAgentId(avsCommon::avs::AgentId::IdType(AGENT_ID_ALEXA_WAKEWORD));
+    m_mockAgentManager = std::make_shared<MockAgentManager>();
+    EXPECT_CALL(*m_mockAgentManager, resolveGesture(_))
+        .WillRepeatedly(Invoke([this](avsCommon::avs::AgentInitiator gesture) {
+            if (m_overrideGestures) {
+                return m_agentId;
+            } else {
+                if (gesture == AgentInitiator::TAP || gesture == AgentInitiator::PRESS_AND_HOLD) {
+                    return avsCommon::avs::AgentId::getAlexaAgentId();
+                } else {
+                    return avsCommon::avs::AgentId::AGENT_ID_NONE;
+                }
+            }
+        }));
+    EXPECT_CALL(*m_mockAgentManager, resolveWakeWord(_)).WillRepeatedly(Invoke([](const std::string& wakeWord) {
+        if (!wakeWord.compare(KEYWORD_TEXT)) {
+            return avsCommon::avs::AgentId::getAlexaAgentId();
+        } else if (!wakeWord.compare(FOO_KEYWORD_TEXT)) {
+            return alexaClientSDK::avsCommon::avs::AgentId::IdType(AGENT_ID_FOO_WAKEWORD);
+        } else {
+            return alexaClientSDK::avsCommon::avs::AgentId::AGENT_ID_NONE;
+        }
+    }));
+    EXPECT_CALL(*m_mockAgentManager, getAVSInterfaceEnabledAgentIds(NAMESPACE, _, _))
+        .WillRepeatedly(Return(std::set<avsCommon::avs::AgentId::IdType>{avsCommon::avs::AgentId::getAlexaAgentId()}));
     m_audioInputProcessor = AudioInputProcessor::create(
         m_mockDirectiveSequencer,
         m_mockMessageSender,
@@ -1111,13 +1258,16 @@ void AudioInputProcessorTest::SetUp() {
         nullptr,
         *m_audioProvider,
         m_mockPowerResourceManager,
-        m_metricRecorder);
+        m_metricRecorder,
+        nullptr,
+        m_mockAgentManager);
     ASSERT_NE(m_audioInputProcessor, nullptr);
     m_audioInputProcessor->addObserver(m_dialogUXStateAggregator);
     // Note: StrictMock here so that we fail on unexpected AIP state changes
     m_mockObserver = std::make_shared<StrictMock<MockObserver>>();
     ASSERT_NE(m_mockObserver, nullptr);
     m_audioInputProcessor->addObserver(m_mockObserver);
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, _)).Times(AnyNumber());
 
     // Populate the test pattern with values that correspond to indexes for easy verification.
     m_pattern.resize(PATTERN_WORDS);
@@ -1168,7 +1318,9 @@ void AudioInputProcessorTest::setupEncoderTest() {
         m_speechEncoder,
         *m_audioProvider,
         m_mockPowerResourceManager,
-        m_metricRecorder);
+        m_metricRecorder,
+        nullptr,
+        m_mockAgentManager);
     ASSERT_NE(m_audioInputProcessor, nullptr);
     m_audioInputProcessor->addObserver(m_dialogUXStateAggregator);
     m_audioInputProcessor->addObserver(m_mockObserver);
@@ -1178,7 +1330,7 @@ void AudioInputProcessorTest::resetAudioInputProcessor() {
     if (m_audioInputProcessor) {
         m_audioInputProcessor->removeObserver(m_dialogUXStateAggregator);
         EXPECT_CALL(*m_mockFocusManager, releaseChannel(CHANNEL_NAME, _)).Times(AtLeast(0));
-        EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::IDLE))
+        EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::IDLE))
             .Times(AtLeast(0));
         m_audioInputProcessor->resetState().wait();
     }
@@ -1195,7 +1347,7 @@ void AudioInputProcessorTest::TearDown() {
 
 bool AudioInputProcessorTest::testRecognizeFails(
     AudioProvider audioProvider,
-    Initiator initiator,
+    AgentInitiator initiator,
     avsCommon::avs::AudioInputStream::Index begin,
     avsCommon::avs::AudioInputStream::Index keywordEnd,
     std::string keyword) {
@@ -1205,20 +1357,35 @@ bool AudioInputProcessorTest::testRecognizeFails(
 
 bool AudioInputProcessorTest::testRecognizeSucceeds(
     AudioProvider audioProvider,
-    Initiator initiator,
+    AgentInitiator initiator,
     avsCommon::avs::AudioInputStream::Index begin,
     avsCommon::avs::AudioInputStream::Index keywordEnd,
     std::string keyword,
+    avsCommon::avs::AgentId::IdType agentId,
     RecognizeStopPoint stopPoint,
     std::shared_ptr<std::string> avsInitiator,
     const std::shared_ptr<std::vector<char>> KWDMetadata,
     std::string expectedFormat,
-    std::map<std::string, std::string> expectedFormats) {
+    std::map<std::string, std::string> expectedFormats,
+    RecognizeAgentDisablePoint agentDisablePoint,
+    RecognizeSpeechConfirmationPoint speechConfirmationPoint) {
     std::mutex mutex;
     std::condition_variable conditionVariable;
 
     bool done = false;
     bool bargeIn = m_recognizeEvent != nullptr;
+    if (agentId == avsCommon::avs::AgentId::AGENT_ID_NONE) {
+        if (initiator == AgentInitiator::WAKEWORD) {
+            agentId = m_mockAgentManager->resolveWakeWord(keyword);
+        } else {
+            agentId = m_mockAgentManager->resolveGesture(initiator);
+        }
+    }
+    m_agentId = agentId;
+
+    bool prerollNeeded =
+        (avsCommon::avs::AgentInitiator::WAKEWORD == initiator) && (begin != AudioInputProcessor::INVALID_INDEX) &&
+        (begin >= audioProvider.format.sampleRateHz / 2) && (keywordEnd != AudioInputProcessor::INVALID_INDEX);
 
     // If a valid begin index is provided, preload the SDS buffer with the test pattern.
     if (begin != AudioInputProcessor::INVALID_INDEX) {
@@ -1235,12 +1402,12 @@ bool AudioInputProcessorTest::testRecognizeSucceeds(
     m_recognizeEvent = std::make_shared<RecognizeEvent>(
         audioProvider, initiator, begin, keywordEnd, keyword, avsInitiator, KWDMetadata, expectedFormat);
     if (keyword.empty()) {
-        EXPECT_CALL(*m_mockContextManager, getContextWithoutReportableStateProperties(_, _, _))
-            .WillOnce(InvokeWithoutArgs([this, contextJson, stopPoint] {
+        EXPECT_CALL(*m_mockContextManager, getContextWithoutReportableStateProperties(_, _, _, _))
+            .WillOnce(InvokeWithoutArgs([this, contextJson, stopPoint, agentId] {
                 m_audioInputProcessor->onContextAvailable(contextJson);
                 if (RecognizeStopPoint::AFTER_CONTEXT == stopPoint) {
                     EXPECT_TRUE(m_audioInputProcessor->stopCapture().valid());
-                    m_dialogUXStateAggregator->onRequestProcessingStarted();
+                    m_dialogUXStateAggregator->onRequestProcessingStarted(agentId);
                 }
                 return CONTEXT_REQUEST_TOKEN;
             }));
@@ -1249,74 +1416,147 @@ bool AudioInputProcessorTest::testRecognizeSucceeds(
         // otherwise ContextManager will not include the new state in the context for this recognize.
         InSequence dummy;
 
-        EXPECT_CALL(*m_mockContextManager, getContextWithoutReportableStateProperties(_, _, _))
-            .WillOnce(InvokeWithoutArgs([this, contextJson, stopPoint] {
-                m_audioInputProcessor->onContextAvailable(contextJson);
-                if (RecognizeStopPoint::AFTER_CONTEXT == stopPoint) {
-                    EXPECT_TRUE(m_audioInputProcessor->stopCapture().valid());
-                    m_dialogUXStateAggregator->onRequestProcessingStarted();
-                }
-                return CONTEXT_REQUEST_TOKEN;
-            }));
+        EXPECT_CALL(*m_mockContextManager, getContextWithoutReportableStateProperties(_, _, _, _))
+            .WillOnce(
+                InvokeWithoutArgs([this, contextJson, stopPoint, agentId, agentDisablePoint, speechConfirmationPoint] {
+                    m_audioInputProcessor->onContextAvailable(contextJson);
+                    if (RecognizeAgentDisablePoint::AFTER_CONTEXT == agentDisablePoint) {
+                        m_audioInputProcessor->onDisabled(m_agentId);
+                    }
+                    if (RecognizeSpeechConfirmationPoint::AFTER_CONTEXT == speechConfirmationPoint) {
+                        rapidjson::Document document(rapidjson::kObjectType);
+                        rapidjson::Value payloadJson(rapidjson::kObjectType);
+
+                        const std::string SPEECH_WORD_CONFIRMATION_ENABLED_VALUE = "TONE";
+
+                        payloadJson.AddMember(
+                            rapidjson::StringRef(SPEECH_CONFIRMATION_PAYLOAD_KEY),
+                            SPEECH_WORD_CONFIRMATION_ENABLED_VALUE,
+                            document.GetAllocator());
+                        auto avsDirective =
+                            createAVSDirective(SET_SPEECH_CONFIRMATION, true, agentId, true, document, payloadJson);
+                        std::shared_ptr<avsCommon::sdkInterfaces::DirectiveHandlerInterface> directiveHandler =
+                            m_audioInputProcessor;
+                        directiveHandler->handleDirectiveImmediately(avsDirective);
+                    }
+                    if (RecognizeStopPoint::AFTER_CONTEXT == stopPoint) {
+                        EXPECT_TRUE(m_audioInputProcessor->stopCapture().valid());
+                        m_dialogUXStateAggregator->onRequestProcessingStarted(agentId);
+                    }
+                    return CONTEXT_REQUEST_TOKEN;
+                }));
     }
 
     if (!bargeIn) {
         EXPECT_CALL(*m_mockUserInactivityMonitor, onUserActive()).Times(2);
-        EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING));
-        EXPECT_CALL(*m_mockFocusManager, acquireChannel(CHANNEL_NAME, _)).WillOnce(InvokeWithoutArgs([this, stopPoint] {
-            m_audioInputProcessor->onFocusChanged(avsCommon::avs::FocusState::FOREGROUND, MixingBehavior::PRIMARY);
-            if (RecognizeStopPoint::AFTER_FOCUS == stopPoint) {
-                EXPECT_TRUE(m_audioInputProcessor->stopCapture().valid());
-                m_dialogUXStateAggregator->onRequestProcessingStarted();
-            }
-            return true;
-        }));
+        EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::RECOGNIZING))
+            .WillOnce(Invoke([&](avsCommon::avs::AgentId::IdType agentId,
+                                 avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface::State state) {
+                EXPECT_EQ(m_agentId, agentId);
+            }));
+        EXPECT_CALL(*m_mockFocusManager, acquireChannel(CHANNEL_NAME, _))
+            .WillOnce(InvokeWithoutArgs([this, stopPoint, agentDisablePoint, agentId, speechConfirmationPoint] {
+                m_audioInputProcessor->onFocusChanged(avsCommon::avs::FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+                if (RecognizeAgentDisablePoint::AFTER_FOCUS == agentDisablePoint) {
+                    m_audioInputProcessor->onDisabled(m_agentId);
+                }
+                if (RecognizeSpeechConfirmationPoint::AFTER_CONTEXT == speechConfirmationPoint) {
+                    rapidjson::Document document(rapidjson::kObjectType);
+                    rapidjson::Value payloadJson(rapidjson::kObjectType);
+
+                    const std::string SPEECH_WORD_CONFIRMATION_ENABLED_VALUE = "TONE";
+
+                    payloadJson.AddMember(
+                        rapidjson::StringRef(SPEECH_CONFIRMATION_PAYLOAD_KEY),
+                        SPEECH_WORD_CONFIRMATION_ENABLED_VALUE,
+                        document.GetAllocator());
+                    auto avsDirective =
+                        createAVSDirective(SET_SPEECH_CONFIRMATION, true, agentId, true, document, payloadJson);
+                    std::shared_ptr<avsCommon::sdkInterfaces::DirectiveHandlerInterface> directiveHandler =
+                        m_audioInputProcessor;
+                    directiveHandler->handleDirectiveImmediately(avsDirective);
+                }
+                if (RecognizeStopPoint::AFTER_FOCUS == stopPoint) {
+                    EXPECT_TRUE(m_audioInputProcessor->stopCapture().valid());
+                    m_dialogUXStateAggregator->onRequestProcessingStarted(agentId);
+                }
+                return true;
+            }));
+
+        if (RecognizeAgentDisablePoint::NONE != agentDisablePoint) {
+            EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::IDLE))
+                .WillOnce(Invoke([&](avsCommon::avs::AgentId::IdType agentId,
+                                     avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface::State state) {
+                    EXPECT_EQ(m_agentId, agentId);
+                    std::lock_guard<std::mutex> lock(mutex);
+                    done = true;
+                    conditionVariable.notify_one();
+                }));
+        }
         EXPECT_CALL(*m_mockPowerResourceManager, acquire(IsSamePowerResource(COMPONENT_NAME), _)).Times(AtLeast(1));
     }
     m_mockDirectiveSequencer->setDialogRequestId("dialogRequestId");
     {
         // Enforce the sequence.
         InSequence dummy;
-        EXPECT_CALL(*m_mockMessageSender, sendMessage(_))
-            .WillOnce(DoAll(
-                Invoke([this, KWDMetadata, expectedFormat, expectedFormats](
-                           std::shared_ptr<avsCommon::avs::MessageRequest> request) {
-                    if (!expectedFormats.empty()) {
-                        EXPECT_FALSE(request->isResolved());
-                        for (auto const& it : expectedFormats) {
-                            auto resolveKey = it.first;
-                            auto encodingFormat = it.second;
-                            auto resolvedRequest = request->resolveRequest(resolveKey);
-                            EXPECT_FALSE(resolvedRequest == nullptr);
-                            m_recognizeEvent->verifyMetadata(resolvedRequest, KWDMetadata);
+        if (RecognizeAgentDisablePoint::NONE == agentDisablePoint) {
+            EXPECT_CALL(*m_mockMessageSender, sendMessage(_))
+                .WillOnce(DoAll(
+                    Invoke([this, KWDMetadata, expectedFormat, expectedFormats, keyword, prerollNeeded]
+                           (std::shared_ptr<avsCommon::avs::MessageRequest> request) {
+                        if (!expectedFormats.empty()) {
+                            EXPECT_FALSE(request->isResolved());
+                            for (auto const& it : expectedFormats) {
+                                auto resolveKey = it.first;
+                                auto encodingFormat = it.second;
+                                auto resolvedRequest = request->resolveRequest(resolveKey);
+                                EXPECT_FALSE(resolvedRequest == nullptr);
+                                m_recognizeEvent->verifyMetadata(resolvedRequest, KWDMetadata);
+
+                                m_recognizeEvent->verifyMessage(
+                                    resolvedRequest,
+                                    m_pattern,
+                                    m_mockDirectiveSequencer->getDialogRequestId(),
+                                    m_agentId,
+                                    keyword,
+                                    encodingFormat,
+                                    prerollNeeded);
+                            }
+                        } else {
+                            m_recognizeEvent->verifyMetadata(request, KWDMetadata);
                             m_recognizeEvent->verifyMessage(
-                                resolvedRequest,
+                                request,
                                 m_pattern,
                                 m_mockDirectiveSequencer->getDialogRequestId(),
-                                encodingFormat);
+                                m_agentId,
+                                keyword,
+                                expectedFormat,
+                                prerollNeeded);
                         }
-                    } else {
-                        m_recognizeEvent->verifyMetadata(request, KWDMetadata);
-                        m_recognizeEvent->verifyMessage(
-                            request, m_pattern, m_mockDirectiveSequencer->getDialogRequestId(), expectedFormat);
-                    }
-                }),
-                InvokeWithoutArgs([&] {
-                    if (RecognizeStopPoint::AFTER_SEND == stopPoint) {
-                        EXPECT_TRUE(m_audioInputProcessor->stopCapture().valid());
-                        m_dialogUXStateAggregator->onRequestProcessingStarted();
-                    } else if (RecognizeStopPoint::NONE == stopPoint) {
-                        std::lock_guard<std::mutex> lock(mutex);
-                        done = true;
-                        conditionVariable.notify_one();
-                    }
-                })));
+                    }),
+                    InvokeWithoutArgs([&] {
+                        if (RecognizeStopPoint::AFTER_SEND == stopPoint) {
+                            EXPECT_TRUE(m_audioInputProcessor->stopCapture().valid());
+                            m_dialogUXStateAggregator->onRequestProcessingStarted(agentId);
+                        } else if (RecognizeStopPoint::NONE == stopPoint) {
+                            std::lock_guard<std::mutex> lock(mutex);
+                            done = true;
+                            conditionVariable.notify_one();
+                        }
+                    })));
+        }
     }
     if (stopPoint != RecognizeStopPoint::NONE) {
-        EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::BUSY));
+        EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::BUSY))
+            .WillOnce(Invoke([&](avsCommon::avs::AgentId::IdType agentId,
+                                 avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface::State state) {
+                EXPECT_EQ(m_agentId, agentId);
+            }));
         EXPECT_CALL(*m_mockFocusManager, releaseChannel(CHANNEL_NAME, _));
-        EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::IDLE))
-            .WillOnce(InvokeWithoutArgs([&] {
+        EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::IDLE))
+            .WillOnce(Invoke([&](avsCommon::avs::AgentId::IdType agentId,
+                                 avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface::State state) {
+                EXPECT_EQ(m_agentId, agentId);
                 std::lock_guard<std::mutex> lock(mutex);
                 done = true;
                 conditionVariable.notify_one();
@@ -1339,7 +1579,7 @@ bool AudioInputProcessorTest::testRecognizeSucceeds(
 
     if (RecognizeStopPoint::AFTER_RECOGNIZE == stopPoint) {
         EXPECT_TRUE(m_audioInputProcessor->stopCapture().valid());
-        m_dialogUXStateAggregator->onRequestProcessingStarted();
+        m_dialogUXStateAggregator->onRequestProcessingStarted(agentId);
     }
 
     std::unique_lock<std::mutex> lock(mutex);
@@ -1351,9 +1591,9 @@ bool AudioInputProcessorTest::testStopCaptureSucceeds() {
     std::condition_variable conditionVariable;
     bool done = false;
 
-    EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::BUSY));
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::BUSY));
     EXPECT_CALL(*m_mockFocusManager, releaseChannel(CHANNEL_NAME, _));
-    EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::IDLE))
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::IDLE))
         .WillOnce(InvokeWithoutArgs([&] {
             std::lock_guard<std::mutex> lock(mutex);
             done = true;
@@ -1362,7 +1602,7 @@ bool AudioInputProcessorTest::testStopCaptureSucceeds() {
     EXPECT_CALL(*m_mockPowerResourceManager, release(IsSamePowerResource(COMPONENT_NAME))).Times(AtLeast(1));
 
     auto stopCaptureResult = m_audioInputProcessor->stopCapture();
-    m_dialogUXStateAggregator->onRequestProcessingStarted();
+    m_dialogUXStateAggregator->onRequestProcessingStarted(avsCommon::avs::AgentId::getAlexaAgentId());
     EXPECT_TRUE(stopCaptureResult.valid());
     if (!stopCaptureResult.valid() && stopCaptureResult.get()) {
         return false;
@@ -1376,16 +1616,16 @@ bool AudioInputProcessorTest::testContextFailure(avsCommon::sdkInterfaces::Conte
     std::mutex mutex;
     std::condition_variable conditionVariable;
     bool done = false;
-    RecognizeEvent recognize(*m_audioProvider, Initiator::TAP);
+    RecognizeEvent recognize(*m_audioProvider, AgentInitiator::TAP);
 
-    EXPECT_CALL(*m_mockContextManager, getContextWithoutReportableStateProperties(_, _, _))
+    EXPECT_CALL(*m_mockContextManager, getContextWithoutReportableStateProperties(_, _, _, _))
         .WillOnce(InvokeWithoutArgs([this, error] {
             m_audioInputProcessor->onContextFailure(error);
             return CONTEXT_REQUEST_TOKEN;
         }));
-    EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING));
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::RECOGNIZING));
     EXPECT_CALL(*m_mockUserInactivityMonitor, onUserActive()).Times(2);
-    EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::IDLE))
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::IDLE))
         .WillOnce(InvokeWithoutArgs([&] {
             std::lock_guard<std::mutex> lock(mutex);
             done = true;
@@ -1401,21 +1641,23 @@ bool AudioInputProcessorTest::testContextFailure(avsCommon::sdkInterfaces::Conte
     return false;
 }
 
-bool AudioInputProcessorTest::testStopCaptureDirectiveSucceeds(bool withDialogRequestId) {
+bool AudioInputProcessorTest::testStopCaptureDirectiveSucceeds(
+    bool withDialogRequestId,
+    avsCommon::avs::AgentId::IdType agentId) {
     std::mutex mutex;
     std::condition_variable conditionVariable;
     bool done = false;
 
-    auto avsDirective = createAVSDirective(STOP_CAPTURE, withDialogRequestId);
+    auto avsDirective = createAVSDirective(STOP_CAPTURE, withDialogRequestId, agentId);
     auto result = avsCommon::utils::memory::make_unique<avsCommon::sdkInterfaces::test::MockDirectiveHandlerResult>();
     std::shared_ptr<avsCommon::sdkInterfaces::DirectiveHandlerInterface> directiveHandler = m_audioInputProcessor;
 
-    EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::BUSY));
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::BUSY));
     EXPECT_CALL(*m_mockFocusManager, releaseChannel(CHANNEL_NAME, _));
     if (withDialogRequestId) {
         EXPECT_CALL(*result, setCompleted());
     }
-    EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::IDLE))
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::IDLE))
         .WillOnce(InvokeWithoutArgs([&] {
             std::lock_guard<std::mutex> lock(mutex);
             done = true;
@@ -1429,18 +1671,20 @@ bool AudioInputProcessorTest::testStopCaptureDirectiveSucceeds(bool withDialogRe
         directiveHandler->preHandleDirective(avsDirective, std::move(result));
         EXPECT_TRUE(directiveHandler->handleDirective(avsDirective->getMessageId()));
     }
-    m_dialogUXStateAggregator->onRequestProcessingStarted();
+    m_dialogUXStateAggregator->onRequestProcessingStarted(agentId);
 
     std::unique_lock<std::mutex> lock(mutex);
     return conditionVariable.wait_for(lock, TEST_TIMEOUT, [&done] { return done; });
 }
 
-bool AudioInputProcessorTest::testStopCaptureDirectiveFails(bool withDialogRequestId) {
+bool AudioInputProcessorTest::testStopCaptureDirectiveFails(
+    bool withDialogRequestId,
+    avsCommon::avs::AgentId::IdType agentId) {
     std::mutex mutex;
     std::condition_variable conditionVariable;
     bool done = false;
 
-    auto avsDirective = createAVSDirective(STOP_CAPTURE, withDialogRequestId);
+    auto avsDirective = createAVSDirective(STOP_CAPTURE, withDialogRequestId, agentId);
     auto result = avsCommon::utils::memory::make_unique<avsCommon::sdkInterfaces::test::MockDirectiveHandlerResult>();
     EXPECT_CALL(*result, setFailed(_)).WillOnce(InvokeWithoutArgs([&] {
         std::lock_guard<std::mutex> lock(mutex);
@@ -1459,23 +1703,25 @@ bool AudioInputProcessorTest::testStopCaptureDirectiveFails(bool withDialogReque
     return conditionVariable.wait_for(lock, TEST_TIMEOUT, [&done] { return done; });
 }
 
-bool AudioInputProcessorTest::testExpectSpeechSucceeds(bool withDialogRequestId) {
+bool AudioInputProcessorTest::testExpectSpeechSucceeds(
+    bool withDialogRequestId,
+    avsCommon::avs::AgentId::IdType agentId) {
     std::mutex mutex;
     std::condition_variable conditionVariable;
     bool done = false;
 
-    auto avsDirective = createAVSDirective(EXPECT_SPEECH, withDialogRequestId);
+    auto avsDirective = createAVSDirective(EXPECT_SPEECH, withDialogRequestId, agentId);
     auto result = avsCommon::utils::memory::make_unique<avsCommon::sdkInterfaces::test::MockDirectiveHandlerResult>();
     std::shared_ptr<avsCommon::sdkInterfaces::DirectiveHandlerInterface> directiveHandler = m_audioInputProcessor;
 
-    EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::EXPECTING_SPEECH));
-    EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING));
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::EXPECTING_SPEECH));
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::RECOGNIZING));
     EXPECT_CALL(*m_mockUserInactivityMonitor, onUserActive()).Times(2);
     EXPECT_CALL(*m_mockPowerResourceManager, acquire(IsSamePowerResource(COMPONENT_NAME), _)).Times(AtLeast(1));
     if (withDialogRequestId) {
         EXPECT_CALL(*result, setCompleted());
     }
-    EXPECT_CALL(*m_mockContextManager, getContextWithoutReportableStateProperties(_, _, _))
+    EXPECT_CALL(*m_mockContextManager, getContextWithoutReportableStateProperties(_, _, _, _))
         .WillOnce(InvokeWithoutArgs([&] {
             std::lock_guard<std::mutex> lock(mutex);
             done = true;
@@ -1494,12 +1740,15 @@ bool AudioInputProcessorTest::testExpectSpeechSucceeds(bool withDialogRequestId)
     return conditionVariable.wait_for(lock, TEST_TIMEOUT, [&done] { return done; });
 }
 
-bool AudioInputProcessorTest::testExpectSpeechWaits(bool withDialogRequestId, bool verifyTimeout) {
+bool AudioInputProcessorTest::testExpectSpeechWaits(
+    bool withDialogRequestId,
+    bool verifyTimeout,
+    avsCommon::avs::AgentId::IdType agentId) {
     std::mutex mutex;
     std::condition_variable conditionVariable;
     bool done = false;
 
-    auto avsDirective = createAVSDirective(EXPECT_SPEECH, withDialogRequestId);
+    auto avsDirective = createAVSDirective(EXPECT_SPEECH, withDialogRequestId, agentId);
     auto result = avsCommon::utils::memory::make_unique<avsCommon::sdkInterfaces::test::MockDirectiveHandlerResult>();
     std::shared_ptr<avsCommon::sdkInterfaces::DirectiveHandlerInterface> directiveHandler = m_audioInputProcessor;
 
@@ -1507,9 +1756,9 @@ bool AudioInputProcessorTest::testExpectSpeechWaits(bool withDialogRequestId, bo
         EXPECT_CALL(*result, setCompleted());
     }
     if (verifyTimeout) {
-        EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::EXPECTING_SPEECH));
+        EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::EXPECTING_SPEECH));
         EXPECT_CALL(*m_mockMessageSender, sendMessage(_)).WillOnce(Invoke(&verifyExpectSpeechTimedOut));
-        EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::IDLE))
+        EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::IDLE))
             .WillOnce(InvokeWithoutArgs([&] {
                 std::lock_guard<std::mutex> lock(mutex);
                 done = true;
@@ -1518,7 +1767,7 @@ bool AudioInputProcessorTest::testExpectSpeechWaits(bool withDialogRequestId, bo
         EXPECT_CALL(*m_mockPowerResourceManager, acquire(IsSamePowerResource(COMPONENT_NAME), _)).Times(AtLeast(1));
         EXPECT_CALL(*m_mockPowerResourceManager, release(IsSamePowerResource(COMPONENT_NAME))).Times(AtLeast(1));
     } else {
-        EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::EXPECTING_SPEECH))
+        EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::EXPECTING_SPEECH))
             .WillOnce(InvokeWithoutArgs([&] {
                 std::lock_guard<std::mutex> lock(mutex);
                 done = true;
@@ -1538,33 +1787,35 @@ bool AudioInputProcessorTest::testExpectSpeechWaits(bool withDialogRequestId, bo
     return conditionVariable.wait_for(lock, TEST_TIMEOUT, [&done] { return done; });
 }
 
-bool AudioInputProcessorTest::testExpectSpeechExternalHandling(bool notifyBackOfTimeout) {
+bool AudioInputProcessorTest::testExpectSpeechExternalHandling(
+    bool notifyBackOfTimeout,
+    avsCommon::avs::AgentId::IdType agentId) {
     std::mutex mutex;
     std::condition_variable conditionVariable;
     bool done = false;
 
-    auto avsDirective = createAVSDirective(EXPECT_SPEECH, true);
+    auto avsDirective = createAVSDirective(EXPECT_SPEECH, true, agentId);
     auto result = avsCommon::utils::memory::make_unique<avsCommon::sdkInterfaces::test::MockDirectiveHandlerResult>();
     std::shared_ptr<avsCommon::sdkInterfaces::DirectiveHandlerInterface> directiveHandler = m_audioInputProcessor;
 
     EXPECT_CALL(*result, setCompleted());
 
     if (notifyBackOfTimeout) {
-        EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::EXPECTING_SPEECH));
+        EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::EXPECTING_SPEECH));
         EXPECT_CALL(
             *m_mockExpectSpeechTimeoutHandler,
             handleExpectSpeechTimeout(std::chrono::milliseconds(EXPECT_SPEECH_TIMEOUT_IN_MILLISECONDS), _))
             // invoke func passed in
             .WillOnce(DoAll(IgnoreResult(InvokeArgument<1>()), Return(true)));
         EXPECT_CALL(*m_mockMessageSender, sendMessage(_)).WillOnce(Invoke(&verifyExpectSpeechTimedOut));
-        EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::IDLE))
+        EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::IDLE))
             .WillOnce(InvokeWithoutArgs([&] {
                 std::lock_guard<std::mutex> lock(mutex);
                 done = true;
                 conditionVariable.notify_one();
             }));
     } else {
-        EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::EXPECTING_SPEECH))
+        EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::EXPECTING_SPEECH))
             .WillOnce(InvokeWithoutArgs([&] {
                 std::lock_guard<std::mutex> lock(mutex);
                 done = true;
@@ -1580,12 +1831,12 @@ bool AudioInputProcessorTest::testExpectSpeechExternalHandling(bool notifyBackOf
     return conditionVariable.wait_for(lock, TEST_TIMEOUT, [&done] { return done; });
 }
 
-bool AudioInputProcessorTest::testExpectSpeechFails(bool withDialogRequestId) {
+bool AudioInputProcessorTest::testExpectSpeechFails(bool withDialogRequestId, avsCommon::avs::AgentId::IdType agentId) {
     std::mutex mutex;
     std::condition_variable conditionVariable;
     bool done = false;
 
-    auto avsDirective = createAVSDirective(EXPECT_SPEECH, withDialogRequestId);
+    auto avsDirective = createAVSDirective(EXPECT_SPEECH, withDialogRequestId, agentId);
     auto result = avsCommon::utils::memory::make_unique<avsCommon::sdkInterfaces::test::MockDirectiveHandlerResult>();
     if (withDialogRequestId) {
         EXPECT_CALL(*result, setFailed(_)).WillOnce(InvokeWithoutArgs([&] {
@@ -1653,10 +1904,10 @@ bool AudioInputProcessorTest::testRecognizeWithExpectSpeechInitiator(bool withIn
 
     // Check for successful Directive handling.
     EXPECT_CALL(*result, setCompleted());
-    EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::EXPECTING_SPEECH));
-    EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING));
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::EXPECTING_SPEECH));
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::RECOGNIZING));
     EXPECT_CALL(*m_mockUserInactivityMonitor, onUserActive()).Times(2);
-    EXPECT_CALL(*m_mockContextManager, getContextWithoutReportableStateProperties(_, _, _))
+    EXPECT_CALL(*m_mockContextManager, getContextWithoutReportableStateProperties(_, _, _, _))
         .WillOnce(Return(CONTEXT_REQUEST_TOKEN));
     EXPECT_CALL(*m_mockPowerResourceManager, acquire(IsSamePowerResource(COMPONENT_NAME), _)).Times(AtLeast(1));
 
@@ -1680,6 +1931,15 @@ std::shared_ptr<avsCommon::avs::AVSDirective> AudioInputProcessorTest::createAVS
     const avsCommon::avs::NamespaceAndName& directive,
     bool withDialogRequestId,
     bool withInitiator) {
+    return createAVSDirective(
+        directive, withDialogRequestId, avsCommon::avs::AgentId::getAlexaAgentId(), withInitiator);
+}
+
+std::shared_ptr<avsCommon::avs::AVSDirective> AudioInputProcessorTest::createAVSDirective(
+    const avsCommon::avs::NamespaceAndName& directive,
+    bool withDialogRequestId,
+    avsCommon::avs::AgentId::IdType agentId,
+    bool withInitiator) {
     rapidjson::Document document(rapidjson::kObjectType);
     rapidjson::Value payloadJson(rapidjson::kObjectType);
 
@@ -1695,12 +1955,13 @@ std::shared_ptr<avsCommon::avs::AVSDirective> AudioInputProcessorTest::createAVS
         }
     }
 
-    return createAVSDirective(directive, withDialogRequestId, withInitiator, document, payloadJson);
+    return createAVSDirective(directive, withDialogRequestId, agentId, withInitiator, document, payloadJson);
 }
 
 std::shared_ptr<avsCommon::avs::AVSDirective> AudioInputProcessorTest::createAVSDirective(
     const avsCommon::avs::NamespaceAndName& directive,
     bool withDialogRequestId,
+    avsCommon::avs::AgentId::IdType agentId,
     bool withInitiator,
     rapidjson::Document& document,
     rapidjson::Value& payloadJson) {
@@ -1736,7 +1997,7 @@ std::shared_ptr<avsCommon::avs::AVSDirective> AudioInputProcessorTest::createAVS
 
     auto mockAttachmentManager = std::make_shared<avsCommon::avs::attachment::test::MockAttachmentManager>();
     return avsCommon::avs::AVSDirective::create(
-        documentBuffer.GetString(), header, payloadBuffer.GetString(), mockAttachmentManager, "");
+        agentId, documentBuffer.GetString(), header, payloadBuffer.GetString(), mockAttachmentManager, "");
 }
 
 void AudioInputProcessorTest::verifyExpectSpeechTimedOut(std::shared_ptr<avsCommon::avs::MessageRequest> request) {
@@ -1776,7 +2037,9 @@ void AudioInputProcessorTest::removeDefaultAudioProvider() {
         nullptr,
         AudioProvider::null(),
         m_mockPowerResourceManager,
-        m_metricRecorder);
+        m_metricRecorder,
+        nullptr,
+        m_mockAgentManager);
     EXPECT_NE(m_audioInputProcessor, nullptr);
     m_audioInputProcessor->addObserver(m_mockObserver);
     m_audioInputProcessor->addObserver(m_dialogUXStateAggregator);
@@ -1802,7 +2065,9 @@ void AudioInputProcessorTest::makeDefaultAudioProviderNotAlwaysReadable() {
         nullptr,
         *m_audioProvider,
         m_mockPowerResourceManager,
-        m_metricRecorder);
+        m_metricRecorder,
+        nullptr,
+        m_mockAgentManager);
     EXPECT_NE(m_audioInputProcessor, nullptr);
     m_audioInputProcessor->addObserver(m_mockObserver);
     m_audioInputProcessor->addObserver(m_dialogUXStateAggregator);
@@ -1828,7 +2093,8 @@ void AudioInputProcessorTest::addExpectSpeechTimeoutHandler() {
         *m_audioProvider,
         m_mockPowerResourceManager,
         m_metricRecorder,
-        m_mockExpectSpeechTimeoutHandler);
+        m_mockExpectSpeechTimeoutHandler,
+        m_mockAgentManager);
     EXPECT_NE(m_audioInputProcessor, nullptr);
     m_audioInputProcessor->addObserver(m_mockObserver);
     m_audioInputProcessor->addObserver(m_dialogUXStateAggregator);
@@ -1841,7 +2107,7 @@ bool AudioInputProcessorTest::testFocusChange(
     std::condition_variable conditionVariable;
     bool done = false;
 
-    bool recognizeSucceeded = testRecognizeSucceeds(*m_audioProvider, Initiator::TAP);
+    bool recognizeSucceeded = testRecognizeSucceeds(*m_audioProvider, AgentInitiator::TAP);
     EXPECT_TRUE(recognizeSucceeded);
     if (!recognizeSucceeded) {
         return false;
@@ -1849,7 +2115,7 @@ bool AudioInputProcessorTest::testFocusChange(
     if (state != avsCommon::avs::FocusState::NONE) {
         EXPECT_CALL(*m_mockFocusManager, releaseChannel(CHANNEL_NAME, _));
     }
-    EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::IDLE))
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::IDLE))
         .WillOnce(InvokeWithoutArgs([&] {
             std::lock_guard<std::mutex> lock(mutex);
             done = true;
@@ -1867,17 +2133,26 @@ void AudioInputProcessorTest::testAIPStateTransitionOnEventResponse(
     AudioInputProcessorObserverInterface::State expectedAIPFinalState,
     bool expectFocusReleased,
     bool closeRequest) {
+    bool done = false;
+    std::mutex mutex;
+    std::condition_variable conditionVariable;
     // Simulate tap to talk and start recognizing.
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
+    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::TAP, 0));
 
     // Expect some AIP transient states.
-    EXPECT_CALL(*m_mockObserver, onStateChanged(_)).Times(AtLeast(0));
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, _)).Times(AtLeast(0));
 
     // Expected final state.  If the expected state is RECOGNIZING, that means we expect no state transition.
     if (AudioInputProcessorObserverInterface::State::RECOGNIZING == expectedAIPFinalState) {
-        EXPECT_CALL(*m_mockObserver, onStateChanged(expectedAIPFinalState)).Times(0);
+        EXPECT_CALL(*m_mockObserver, onStateChanged(_, expectedAIPFinalState)).Times(0);
     } else {
-        EXPECT_CALL(*m_mockObserver, onStateChanged(expectedAIPFinalState)).Times(1);
+        EXPECT_CALL(*m_mockObserver, onStateChanged(_, expectedAIPFinalState))
+            .WillOnce(Invoke([&](avsCommon::avs::AgentId::IdType agentId,
+                                 avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface::State state) {
+                std::lock_guard<std::mutex> lock(mutex);
+                done = true;
+                conditionVariable.notify_one();
+            }));
     }
 
     if (expectFocusReleased) {
@@ -1906,8 +2181,21 @@ void AudioInputProcessorTest::testAIPStateTransitionOnEventResponse(
     if (StopCaptureDirectiveSchedule::AFTER_EVENT_STREAM_CLOSE == stopCaptureSchedule) {
         m_audioInputProcessor->handleDirectiveImmediately(avsDirective);
     }
+
+    if (AudioInputProcessorObserverInterface::State::RECOGNIZING != expectedAIPFinalState) {
+        std::unique_lock<std::mutex> lock(mutex);
+        auto setCompletedResult = conditionVariable.wait_for(lock, TEST_TIMEOUT, [&done] { return done; });
+        EXPECT_TRUE(setCompletedResult);
+    }
 }
 
+INSTANTIATE_TEST_CASE_P(
+    Parameterized,
+    AudioInputProcessorTest,
+    ::testing::Values(
+        AudioInputProcessorTestData(KEYWORD_TEXT, avsCommon::avs::AgentId::IdType(AGENT_ID_ALEXA_WAKEWORD)),
+        AudioInputProcessorTestData(FOO_KEYWORD_TEXT, avsCommon::avs::AgentId::IdType(AGENT_ID_FOO_WAKEWORD))));
+
 /// Function to verify that @c AudioInputProcessor::create() errors out with an invalid @c DirectiveSequencerInterface.
 TEST_F(AudioInputProcessorTest, test_createWithoutDirectiveSequencer) {
     auto aip = AudioInputProcessor::create(
@@ -2210,7 +2498,7 @@ TEST_F(AudioInputProcessorTest, test_addRemoveObserver) {
 
 /// This function verifies that @c AudioInputProcessor::recognize() fails when given a null @c AudioProvider.
 TEST_F(AudioInputProcessorTest, test_recognizeNullStream) {
-    auto result = m_audioInputProcessor->recognize(AudioProvider::null(), Initiator::PRESS_AND_HOLD);
+    auto result = m_audioInputProcessor->recognize(AudioProvider::null(), AgentInitiator::PRESS_AND_HOLD);
     ASSERT_TRUE(result.valid());
     ASSERT_FALSE(result.get());
 }
@@ -2219,39 +2507,40 @@ TEST_F(AudioInputProcessorTest, test_recognizeNullStream) {
 TEST_F(AudioInputProcessorTest, test_recognizeInvalidAudioFormat) {
     AudioProvider audioProvider = *m_audioProvider;
     audioProvider.format.endianness = avsCommon::utils::AudioFormat::Endianness::BIG;
-    EXPECT_FALSE(m_audioInputProcessor->recognize(audioProvider, Initiator::PRESS_AND_HOLD).get());
+    EXPECT_FALSE(m_audioInputProcessor->recognize(audioProvider, AgentInitiator::PRESS_AND_HOLD).get());
 
     audioProvider = *m_audioProvider;
     audioProvider.format.sampleRateHz = 0;
-    EXPECT_FALSE(m_audioInputProcessor->recognize(audioProvider, Initiator::PRESS_AND_HOLD).get());
+    EXPECT_FALSE(m_audioInputProcessor->recognize(audioProvider, AgentInitiator::PRESS_AND_HOLD).get());
 
     audioProvider = *m_audioProvider;
     audioProvider.format.sampleSizeInBits = 0;
-    EXPECT_FALSE(m_audioInputProcessor->recognize(audioProvider, Initiator::PRESS_AND_HOLD).get());
+    EXPECT_FALSE(m_audioInputProcessor->recognize(audioProvider, AgentInitiator::PRESS_AND_HOLD).get());
 
     audioProvider = *m_audioProvider;
     audioProvider.format.numChannels = 0;
-    EXPECT_FALSE(m_audioInputProcessor->recognize(audioProvider, Initiator::PRESS_AND_HOLD).get());
+    EXPECT_FALSE(m_audioInputProcessor->recognize(audioProvider, AgentInitiator::PRESS_AND_HOLD).get());
 }
 
-/// This function verifies that @c AudioInputProcessor::recognize() works with @c Initiator::PRESS_AND_HOLD.
+/// This function verifies that @c AudioInputProcessor::recognize() works with @c AgentInitiator::PRESS_AND_HOLD.
 TEST_F(AudioInputProcessorTest, test_recognizePressAndHold) {
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::PRESS_AND_HOLD));
+    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::PRESS_AND_HOLD));
 }
 
-/// This function verifies that @c AudioInputProcessor::recognize() works with @c Initiator::TAP.
+/// This function verifies that @c AudioInputProcessor::recognize() works with @c AgentInitiator::TAP.
 TEST_F(AudioInputProcessorTest, test_recognizeTap) {
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP));
+    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::TAP));
 }
 
-/// This function verifies that @c AudioInputProcessor::recognize() fails with @c Initiator::WAKEWORD and no keyword.
+/// This function verifies that @c AudioInputProcessor::recognize() fails with @c AgentInitiator::WAKEWORD and no
+/// keyword.
 TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithoutKeyword) {
-    EXPECT_TRUE(testRecognizeFails(*m_audioProvider, Initiator::WAKEWORD));
+    EXPECT_TRUE(testRecognizeFails(*m_audioProvider, AgentInitiator::WAKEWORD));
 }
 
 /**
- * This function verifies that @c AudioInputProcessor::recognize() fails with @c Initiator::WAKEWORD and invalid begin
- * index.
+ * This function verifies that @c AudioInputProcessor::recognize() fails with @c AgentInitiator::WAKEWORD and invalid
+ * begin index.
  */
 TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithBadBegin) {
     // Write data until the sds wraps, which will make 0 an invalid index.
@@ -2260,52 +2549,58 @@ TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithBadBegin) {
     }
     avsCommon::avs::AudioInputStream::Index begin = 0;
     auto end = AudioInputProcessor::INVALID_INDEX;
-    EXPECT_TRUE(testRecognizeFails(*m_audioProvider, Initiator::WAKEWORD, begin, end, KEYWORD_TEXT));
+    EXPECT_TRUE(testRecognizeFails(*m_audioProvider, AgentInitiator::WAKEWORD, begin, end, KEYWORD_TEXT));
 }
 
-/// This function verifies that @c AudioInputProcessor::recognize() works with @c Initiator::WAKEWORD and keyword.
-TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithKeyword) {
+/// This function verifies that @c AudioInputProcessor::recognize() works with @c AgentInitiator::WAKEWORD and keyword.
+TEST_P(AudioInputProcessorTest, test_recognizeWakewordWithKeyword) {
     auto begin = AudioInputProcessor::INVALID_INDEX;
     auto end = AudioInputProcessor::INVALID_INDEX;
-    EXPECT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::WAKEWORD, begin, end, KEYWORD_TEXT));
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    EXPECT_TRUE(testRecognizeSucceeds(
+        *m_audioProvider, AgentInitiator::WAKEWORD, begin, end, audioInputProcessorTestData.m_wakeword));
 }
 
-/// This function verifies that @c AudioInputProcessor::recognize() works with @c Initiator::WAKEWORD valid begin.
-TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithGoodBegin) {
+/// This function verifies that @c AudioInputProcessor::recognize() works with @c AgentInitiator::WAKEWORD valid begin.
+TEST_P(AudioInputProcessorTest, test_recognizeWakewordWithGoodBegin) {
     avsCommon::avs::AudioInputStream::Index begin = 0;
     auto end = AudioInputProcessor::INVALID_INDEX;
-    EXPECT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::WAKEWORD, begin, end, KEYWORD_TEXT));
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    EXPECT_TRUE(testRecognizeSucceeds(
+        *m_audioProvider, AgentInitiator::WAKEWORD, begin, end, audioInputProcessorTestData.m_wakeword));
 }
 
 /**
- * This function verifies that @c AudioInputProcessor::recognize() works with @c Initiator::WAKEWORD valid begin and
- * end indices.
+ * This function verifies that @c AudioInputProcessor::recognize() works with @c AgentInitiator::WAKEWORD valid begin
+ * and end indices.
  */
-TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithGoodBeginAndEnd) {
+TEST_P(AudioInputProcessorTest, test_recognizeWakewordWithGoodBeginAndEnd) {
     avsCommon::avs::AudioInputStream::Index begin = PREROLL_WORDS;
     avsCommon::avs::AudioInputStream::Index end = PREROLL_WORDS + WAKEWORD_WORDS;
-    EXPECT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::WAKEWORD, begin, end, KEYWORD_TEXT));
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    EXPECT_TRUE(testRecognizeSucceeds(
+        *m_audioProvider, AgentInitiator::WAKEWORD, begin, end, audioInputProcessorTestData.m_wakeword));
 }
 
 /// This function verifies that @c AudioInputProcessor::recognize() works with @c ASRProfile::CLOSE_TALK.
 TEST_F(AudioInputProcessorTest, test_recognizeCloseTalk) {
     auto audioProvider = *m_audioProvider;
     audioProvider.profile = ASRProfile::CLOSE_TALK;
-    ASSERT_TRUE(testRecognizeSucceeds(audioProvider, Initiator::PRESS_AND_HOLD));
+    ASSERT_TRUE(testRecognizeSucceeds(audioProvider, AgentInitiator::PRESS_AND_HOLD));
 }
 
 /// This function verifies that @c AudioInputProcessor::recognize() works with @c ASRProfile::NEAR_FIELD.
 TEST_F(AudioInputProcessorTest, test_recognizeNearField) {
     auto audioProvider = *m_audioProvider;
     audioProvider.profile = ASRProfile::NEAR_FIELD;
-    ASSERT_TRUE(testRecognizeSucceeds(audioProvider, Initiator::TAP));
+    ASSERT_TRUE(testRecognizeSucceeds(audioProvider, AgentInitiator::TAP));
 }
 
 /// This function verifies that @c AudioInputProcessor::recognize() works with @c ASRProfile::FAR_FIELD.
 TEST_F(AudioInputProcessorTest, test_recognizeFarField) {
     auto audioProvider = *m_audioProvider;
     audioProvider.profile = ASRProfile::FAR_FIELD;
-    ASSERT_TRUE(testRecognizeSucceeds(audioProvider, Initiator::TAP));
+    ASSERT_TRUE(testRecognizeSucceeds(audioProvider, AgentInitiator::TAP));
 }
 
 /// Test if  @c AudioInputProcessor::recognize() works with an audio encoder
@@ -2315,10 +2610,11 @@ TEST_F(AudioInputProcessorTest, test_recognizeFarFieldWithEncoder) {
     audioProvider.profile = ASRProfile::FAR_FIELD;
     ASSERT_TRUE(testRecognizeSucceeds(
         audioProvider,
-        Initiator::TAP,
+        AgentInitiator::TAP,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
         "",
+        avsCommon::avs::AgentId::getAlexaAgentId(),
         RecognizeStopPoint::NONE,
         nullptr,
         nullptr,
@@ -2333,10 +2629,11 @@ TEST_F(AudioInputProcessorTest, test_recognizeFarFieldWithEncoderDisabled) {
     m_audioInputProcessor->setEncodingAudioFormat(avsCommon::utils::AudioFormat::Encoding::LPCM);
     ASSERT_TRUE(testRecognizeSucceeds(
         audioProvider,
-        Initiator::TAP,
+        AgentInitiator::TAP,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
         "",
+        avsCommon::avs::AgentId::getAlexaAgentId(),
         RecognizeStopPoint::NONE,
         nullptr,
         nullptr,
@@ -2352,10 +2649,11 @@ TEST_F(AudioInputProcessorTest, test_recognizeFarFieldWithEncoderReEnabled) {
     m_audioInputProcessor->setEncodingAudioFormat(avsCommon::utils::AudioFormat::Encoding::LPCM);
     ASSERT_TRUE(testRecognizeSucceeds(
         audioProvider,
-        Initiator::TAP,
+        AgentInitiator::TAP,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
         "",
+        avsCommon::avs::AgentId::getAlexaAgentId(),
         RecognizeStopPoint::NONE,
         nullptr,
         nullptr,
@@ -2364,27 +2662,113 @@ TEST_F(AudioInputProcessorTest, test_recognizeFarFieldWithEncoderReEnabled) {
     m_audioInputProcessor->setEncodingAudioFormat(avsCommon::utils::AudioFormat::Encoding::OPUS);
     ASSERT_TRUE(testRecognizeSucceeds(
         audioProvider,
-        Initiator::TAP,
+        AgentInitiator::TAP,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
         "",
+        avsCommon::avs::AgentId::getAlexaAgentId(),
         RecognizeStopPoint::NONE,
         nullptr,
         nullptr,
         AUDIO_FORMAT_OPUS));
 }
 
+/// This function verifies that @c AudioInputProcessor::recognize() succeeds when agent is disabled after context
+TEST_P(AudioInputProcessorTest, test_recognizeWhenAgentDisabled_afterContext) {
+    avsCommon::avs::AudioInputStream::Index begin = PREROLL_WORDS;
+    avsCommon::avs::AudioInputStream::Index end = PREROLL_WORDS + WAKEWORD_WORDS;
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    ASSERT_TRUE(testRecognizeSucceeds(
+        *m_audioProvider,
+        AgentInitiator::WAKEWORD,
+        begin,
+        end,
+        audioInputProcessorTestData.m_wakeword,
+        audioInputProcessorTestData.m_agentId,
+        RecognizeStopPoint::NONE,
+        nullptr,
+        nullptr,
+        "",
+        {},
+        RecognizeAgentDisablePoint::AFTER_CONTEXT));
+}
+
+/// This function verifies that @c AudioInputProcessor::recognize() succeeds when agent is disabled after focus
+TEST_P(AudioInputProcessorTest, test_recognizeWhenAgentDisabled_afterFocus) {
+    avsCommon::avs::AudioInputStream::Index begin = PREROLL_WORDS;
+    avsCommon::avs::AudioInputStream::Index end = PREROLL_WORDS + WAKEWORD_WORDS;
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    ASSERT_TRUE(testRecognizeSucceeds(
+        *m_audioProvider,
+        AgentInitiator::WAKEWORD,
+        begin,
+        end,
+        audioInputProcessorTestData.m_wakeword,
+        audioInputProcessorTestData.m_agentId,
+        RecognizeStopPoint::NONE,
+        nullptr,
+        nullptr,
+        "",
+        {},
+        RecognizeAgentDisablePoint::AFTER_FOCUS));
+}
+
+/// This function verifies that @c AudioInputProcessor::recognize() works with @c AgentInitiator::WAKEWORD and keyword
+/// while changing SpeechConfirmation Alexa AIP setting
+TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithKeyword_And_SpeechConfirmation_AfterContext) {
+    auto begin = AudioInputProcessor::INVALID_INDEX;
+    auto end = AudioInputProcessor::INVALID_INDEX;
+    EXPECT_TRUE(testRecognizeSucceeds(
+        *m_audioProvider,
+        AgentInitiator::WAKEWORD,
+        begin,
+        end,
+        FOO_KEYWORD_TEXT,
+        avsCommon::avs::AgentId::IdType(AGENT_ID_FOO_WAKEWORD),
+        RecognizeStopPoint::NONE,
+        nullptr,
+        nullptr,
+        "",
+        {},
+        RecognizeAgentDisablePoint::NONE,
+        RecognizeSpeechConfirmationPoint::AFTER_CONTEXT));
+}
+
+/// This function verifies that @c AudioInputProcessor::recognize() works with @c AgentInitiator::WAKEWORD and keyword
+/// while changing SpeechConfirmation Alexa AIP setting
+TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithKeyword_And_SpeechConfirmation_AfterFocus) {
+    auto begin = AudioInputProcessor::INVALID_INDEX;
+    auto end = AudioInputProcessor::INVALID_INDEX;
+    EXPECT_TRUE(testRecognizeSucceeds(
+        *m_audioProvider,
+        AgentInitiator::WAKEWORD,
+        begin,
+        end,
+        FOO_KEYWORD_TEXT,
+        avsCommon::avs::AgentId::IdType(AGENT_ID_FOO_WAKEWORD),
+        RecognizeStopPoint::NONE,
+        nullptr,
+        nullptr,
+        "",
+        {},
+        RecognizeAgentDisablePoint::NONE,
+        RecognizeSpeechConfirmationPoint::AFTER_FOCUS));
+}
+
 /// This function verifies that @c AudioInputProcessor::recognize() works in @c State::EXPECTING_SPEECH.
-TEST_F(AudioInputProcessorTest, test_recognizeWhileExpectingSpeech) {
+TEST_P(AudioInputProcessorTest, test_recognizeWhileExpectingSpeech) {
     removeDefaultAudioProvider();
-    ASSERT_TRUE(testExpectSpeechWaits(WITH_DIALOG_REQUEST_ID, !VERIFY_TIMEOUT));
+    m_overrideGestures = true;
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    ASSERT_TRUE(testExpectSpeechWaits(WITH_DIALOG_REQUEST_ID, !VERIFY_TIMEOUT, audioInputProcessorTestData.m_agentId));
     // Recognize event after an ExpectSpeech results in the ExpectSpeech's initiator being passed back to AVS.
     ASSERT_TRUE(testRecognizeSucceeds(
         *m_audioProvider,
-        Initiator::PRESS_AND_HOLD,
+        AgentInitiator::PRESS_AND_HOLD,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
-        "",
+        audioInputProcessorTestData.m_wakeword,
+        audioInputProcessorTestData.m_agentId,
         RecognizeStopPoint::NONE,
         std::make_shared<std::string>(EXPECT_SPEECH_INITIATOR)));
 }
@@ -2398,10 +2782,11 @@ TEST_F(AudioInputProcessorTest, test_recognizeStopAfterRecognize) {
     audioProvider.profile = ASRProfile::CLOSE_TALK;
     ASSERT_TRUE(testRecognizeSucceeds(
         audioProvider,
-        Initiator::PRESS_AND_HOLD,
+        AgentInitiator::PRESS_AND_HOLD,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
         "",
+        avsCommon::avs::AgentId::AGENT_ID_NONE,
         RecognizeStopPoint::AFTER_RECOGNIZE));
 }
 
@@ -2414,10 +2799,11 @@ TEST_F(AudioInputProcessorTest, test_recognizeStopAfterContext) {
     audioProvider.profile = ASRProfile::CLOSE_TALK;
     ASSERT_TRUE(testRecognizeSucceeds(
         audioProvider,
-        Initiator::PRESS_AND_HOLD,
+        AgentInitiator::PRESS_AND_HOLD,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
         "",
+        avsCommon::avs::AgentId::AGENT_ID_NONE,
         RecognizeStopPoint::AFTER_CONTEXT));
 }
 
@@ -2430,10 +2816,11 @@ TEST_F(AudioInputProcessorTest, test_recognizeStopAfterFocus) {
     audioProvider.profile = ASRProfile::CLOSE_TALK;
     ASSERT_TRUE(testRecognizeSucceeds(
         audioProvider,
-        Initiator::PRESS_AND_HOLD,
+        AgentInitiator::PRESS_AND_HOLD,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
         "",
+        avsCommon::avs::AgentId::AGENT_ID_NONE,
         RecognizeStopPoint::AFTER_FOCUS));
 }
 
@@ -2446,10 +2833,11 @@ TEST_F(AudioInputProcessorTest, test_recognizeStopAfterSend) {
     audioProvider.profile = ASRProfile::CLOSE_TALK;
     ASSERT_TRUE(testRecognizeSucceeds(
         audioProvider,
-        Initiator::PRESS_AND_HOLD,
+        AgentInitiator::PRESS_AND_HOLD,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
         "",
+        avsCommon::avs::AgentId::AGENT_ID_NONE,
         RecognizeStopPoint::AFTER_SEND));
 }
 
@@ -2460,8 +2848,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeStopAfterSend) {
 TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingCloseTalk) {
     auto audioProvider = *m_audioProvider;
     audioProvider.profile = ASRProfile::CLOSE_TALK;
-    ASSERT_TRUE(testRecognizeSucceeds(audioProvider, Initiator::TAP));
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP));
+    ASSERT_TRUE(testRecognizeSucceeds(audioProvider, AgentInitiator::TAP));
+    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::TAP));
 }
 
 /**
@@ -2471,8 +2859,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingCloseTalk)
 TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingNearField) {
     auto audioProvider = *m_audioProvider;
     audioProvider.profile = ASRProfile::NEAR_FIELD;
-    ASSERT_TRUE(testRecognizeSucceeds(audioProvider, Initiator::TAP));
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP));
+    ASSERT_TRUE(testRecognizeSucceeds(audioProvider, AgentInitiator::TAP));
+    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::TAP));
 }
 
 /**
@@ -2482,8 +2870,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingNearField)
 TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingFarField) {
     auto audioProvider = *m_audioProvider;
     audioProvider.profile = ASRProfile::FAR_FIELD;
-    ASSERT_TRUE(testRecognizeSucceeds(audioProvider, Initiator::TAP));
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP));
+    ASSERT_TRUE(testRecognizeSucceeds(audioProvider, AgentInitiator::TAP));
+    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::TAP));
 }
 
 /**
@@ -2491,10 +2879,10 @@ TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingFarField) {
  * @c AudioProvider can't override.
  */
 TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingCantOverride) {
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP));
+    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::TAP));
     auto audioProvider = *m_audioProvider;
     audioProvider.canOverride = false;
-    ASSERT_TRUE(testRecognizeFails(audioProvider, Initiator::TAP));
+    ASSERT_TRUE(testRecognizeFails(audioProvider, AgentInitiator::TAP));
 }
 
 /**
@@ -2504,8 +2892,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingCantOverrid
 TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingCantBeOverridden) {
     auto audioProvider = *m_audioProvider;
     audioProvider.canBeOverridden = false;
-    ASSERT_TRUE(testRecognizeSucceeds(audioProvider, Initiator::TAP));
-    ASSERT_TRUE(testRecognizeFails(*m_audioProvider, Initiator::TAP));
+    ASSERT_TRUE(testRecognizeSucceeds(audioProvider, AgentInitiator::TAP));
+    ASSERT_TRUE(testRecognizeFails(*m_audioProvider, AgentInitiator::TAP));
 }
 
 /// This function verifies that @c AudioInputProcessor::stopCapture() fails in @c State::IDLE.
@@ -2514,15 +2902,16 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureWhenIdle) {
 }
 
 /// This function verifies that @c AudioInputProcessor::stopCapture() fails in @c State::EXPECTING_SPEECH.
-TEST_F(AudioInputProcessorTest, test_stopCaptureWhenExpectingSpeech) {
+TEST_P(AudioInputProcessorTest, test_stopCaptureWhenExpectingSpeech) {
     removeDefaultAudioProvider();
-    ASSERT_TRUE(testExpectSpeechWaits(WITH_DIALOG_REQUEST_ID, !VERIFY_TIMEOUT));
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    ASSERT_TRUE(testExpectSpeechWaits(WITH_DIALOG_REQUEST_ID, !VERIFY_TIMEOUT, audioInputProcessorTestData.m_agentId));
     ASSERT_FALSE(m_audioInputProcessor->stopCapture().get());
 }
 
 /// This function verifies that @c AudioInputProcessor::stopCapture() works in @c State::RECOGNIZING.
 TEST_F(AudioInputProcessorTest, test_stopCaptureWhenRecognizing) {
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
+    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::TAP, 0));
     ASSERT_TRUE(testStopCaptureSucceeds());
 
     for (auto& namedReader : m_recognizeEvent->getNamedReaders()) {
@@ -2538,7 +2927,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureWhenRecognizing) {
  * subsequent StopCapture directive will be ignored.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureWhenRecognizingFollowByStopCaptureDirective) {
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
+    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::TAP, 0));
     ASSERT_TRUE(testStopCaptureSucceeds());
 
     for (auto& namedReader : m_recognizeEvent->getNamedReaders()) {
@@ -2575,19 +2964,20 @@ TEST_F(AudioInputProcessorTest, test_resetStateWhenIdle) {
 }
 
 /// This function verifies that @c AudioInputProcessor::resetState() works in @c State::EXPECTING_SPEECH.
-TEST_F(AudioInputProcessorTest, test_resetStateWhenExpectingSpeech) {
+TEST_P(AudioInputProcessorTest, test_resetStateWhenExpectingSpeech) {
     removeDefaultAudioProvider();
-    ASSERT_TRUE(testExpectSpeechWaits(WITH_DIALOG_REQUEST_ID, !VERIFY_TIMEOUT));
-    EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::IDLE));
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    ASSERT_TRUE(testExpectSpeechWaits(WITH_DIALOG_REQUEST_ID, !VERIFY_TIMEOUT, audioInputProcessorTestData.m_agentId));
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::IDLE));
     m_audioInputProcessor->resetState().get();
 }
 
 /// This function verifies that @c AudioInputProcessor::resetState() works in @c State::RECOGNIZING.
 TEST_F(AudioInputProcessorTest, test_resetStateWhenRecognizing) {
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
+    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::TAP, 0));
 
     EXPECT_CALL(*m_mockFocusManager, releaseChannel(CHANNEL_NAME, _));
-    EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::IDLE));
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::IDLE));
     m_audioInputProcessor->resetState().get();
 }
 
@@ -2608,62 +2998,93 @@ TEST_F(AudioInputProcessorTest, test_contextFailureBuildContextError) {
 }
 
 /// This function verifies that StopCapture directives fail in @c State::IDLE.
-TEST_F(AudioInputProcessorTest, test_preHandleAndHandleDirectiveStopCaptureWhenIdle) {
-    ASSERT_TRUE(testStopCaptureDirectiveFails(WITH_DIALOG_REQUEST_ID));
+TEST_P(AudioInputProcessorTest, test_preHandleAndHandleDirectiveStopCaptureWhenIdle) {
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    ASSERT_TRUE(testStopCaptureDirectiveFails(WITH_DIALOG_REQUEST_ID, audioInputProcessorTestData.m_agentId));
 }
 
 /// This function verifies that StopCapture directives with dialog request ID work in @c State::RECOGNIZING.
-TEST_F(AudioInputProcessorTest, test_preHandleAndHandleDirectiveStopCaptureWhenRecognizing) {
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
-    ASSERT_TRUE(testStopCaptureDirectiveSucceeds(WITH_DIALOG_REQUEST_ID));
+TEST_P(AudioInputProcessorTest, test_preHandleAndHandleDirectiveStopCaptureWhenRecognizing) {
+    m_overrideGestures = true;
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    ASSERT_TRUE(testRecognizeSucceeds(
+        *m_audioProvider,
+        AgentInitiator::TAP,
+        0,
+        AudioInputProcessor::INVALID_INDEX,
+        "",
+        audioInputProcessorTestData.m_agentId));
+    ASSERT_TRUE(testStopCaptureDirectiveSucceeds(WITH_DIALOG_REQUEST_ID, audioInputProcessorTestData.m_agentId));
 }
 
 /// This function verifies that StopCapture directives fail in @c State::EXPECTING_SPEECH.
-TEST_F(AudioInputProcessorTest, test_preHandleAndHandleDirectiveStopCaptureWhenExpectingSpeech) {
+TEST_P(AudioInputProcessorTest, test_preHandleAndHandleDirectiveStopCaptureWhenExpectingSpeech) {
     removeDefaultAudioProvider();
-    ASSERT_TRUE(testExpectSpeechWaits(WITH_DIALOG_REQUEST_ID, !VERIFY_TIMEOUT));
-    ASSERT_TRUE(testStopCaptureDirectiveFails(WITH_DIALOG_REQUEST_ID));
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    ASSERT_TRUE(testExpectSpeechWaits(WITH_DIALOG_REQUEST_ID, !VERIFY_TIMEOUT, audioInputProcessorTestData.m_agentId));
+    ASSERT_TRUE(testStopCaptureDirectiveFails(WITH_DIALOG_REQUEST_ID, audioInputProcessorTestData.m_agentId));
 }
 
 /// This function verifies that StopCapture directives without dialog request ID work in @c State::RECOGNIZING.
-TEST_F(AudioInputProcessorTest, test_handleDirectiveImmediatelyStopCaptureWhenRecognizing) {
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
-    ASSERT_TRUE(testStopCaptureDirectiveSucceeds(!WITH_DIALOG_REQUEST_ID));
+TEST_P(AudioInputProcessorTest, test_handleDirectiveImmediatelyStopCaptureWhenRecognizing) {
+    m_overrideGestures = true;
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    ASSERT_TRUE(testRecognizeSucceeds(
+        *m_audioProvider,
+        AgentInitiator::TAP,
+        0,
+        AudioInputProcessor::INVALID_INDEX,
+        "",
+        audioInputProcessorTestData.m_agentId));
+    ASSERT_TRUE(testStopCaptureDirectiveSucceeds(!WITH_DIALOG_REQUEST_ID, audioInputProcessorTestData.m_agentId));
 }
 
 /// This function verifies that ExpectSpeech directives with dialog request ID work in @c State::IDLE.
-TEST_F(AudioInputProcessorTest, test_preHandleAndHandleDirectiveExpectSpeechWhenIdle) {
-    ASSERT_TRUE(testExpectSpeechSucceeds(WITH_DIALOG_REQUEST_ID));
+TEST_P(AudioInputProcessorTest, test_preHandleAndHandleDirectiveExpectSpeechWhenIdle) {
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    ASSERT_TRUE(testExpectSpeechSucceeds(WITH_DIALOG_REQUEST_ID, audioInputProcessorTestData.m_agentId));
 }
 
 /// This function verifies that ExpectSpeech directives without dialog request ID work in @c State::IDLE.
-TEST_F(AudioInputProcessorTest, test_handleDirectiveImmediatelyExpectSpeechWhenIdle) {
-    ASSERT_TRUE(testExpectSpeechSucceeds(!WITH_DIALOG_REQUEST_ID));
+TEST_P(AudioInputProcessorTest, test_handleDirectiveImmediatelyExpectSpeechWhenIdle) {
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    ASSERT_TRUE(testExpectSpeechSucceeds(!WITH_DIALOG_REQUEST_ID, audioInputProcessorTestData.m_agentId));
 }
 
 /// This function verifies that ExpectSpeech directives fail in @c State::RECOGNIZING.
-TEST_F(AudioInputProcessorTest, test_preHandleAndHandleDirectiveExpectSpeechWhenRecognizing) {
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
-    ASSERT_TRUE(testExpectSpeechFails(WITH_DIALOG_REQUEST_ID));
+TEST_P(AudioInputProcessorTest, test_preHandleAndHandleDirectiveExpectSpeechWhenRecognizing) {
+    m_overrideGestures = true;
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    ASSERT_TRUE(testRecognizeSucceeds(
+        *m_audioProvider,
+        AgentInitiator::TAP,
+        0,
+        AudioInputProcessor::INVALID_INDEX,
+        "",
+        audioInputProcessorTestData.m_agentId));
+    ASSERT_TRUE(testExpectSpeechFails(WITH_DIALOG_REQUEST_ID, audioInputProcessorTestData.m_agentId));
 }
 
 /// This function verifies that ExpectSpeech directives fail in @c State::EXPECTING_SPEECH.
-TEST_F(AudioInputProcessorTest, test_preHandleAndHandleDirectiveExpectSpeechWhenExpectingSpeech) {
+TEST_P(AudioInputProcessorTest, test_preHandleAndHandleDirectiveExpectSpeechWhenExpectingSpeech) {
     removeDefaultAudioProvider();
-    ASSERT_TRUE(testExpectSpeechWaits(WITH_DIALOG_REQUEST_ID, !VERIFY_TIMEOUT));
-    ASSERT_TRUE(testExpectSpeechFails(WITH_DIALOG_REQUEST_ID));
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    ASSERT_TRUE(testExpectSpeechWaits(WITH_DIALOG_REQUEST_ID, !VERIFY_TIMEOUT, audioInputProcessorTestData.m_agentId));
+    ASSERT_TRUE(testExpectSpeechFails(WITH_DIALOG_REQUEST_ID, audioInputProcessorTestData.m_agentId));
 }
 
 /// This function verifies that ExpectSpeech directives wait with no default and no previous @c AudioProvider.
-TEST_F(AudioInputProcessorTest, test_expectSpeechNoDefaultNoPrevious) {
+TEST_P(AudioInputProcessorTest, test_expectSpeechNoDefaultNoPrevious) {
     removeDefaultAudioProvider();
-    ASSERT_TRUE(testExpectSpeechWaits(WITH_DIALOG_REQUEST_ID, VERIFY_TIMEOUT));
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    ASSERT_TRUE(testExpectSpeechWaits(WITH_DIALOG_REQUEST_ID, VERIFY_TIMEOUT, audioInputProcessorTestData.m_agentId));
 }
 
 /// This function verifies that ExpectSpeech directives wait with unreadable default and no previous @c AudioProvider.
-TEST_F(AudioInputProcessorTest, test_expectSpeechUnreadableDefaultNoPrevious) {
+TEST_P(AudioInputProcessorTest, test_expectSpeechUnreadableDefaultNoPrevious) {
     makeDefaultAudioProviderNotAlwaysReadable();
-    ASSERT_TRUE(testExpectSpeechWaits(WITH_DIALOG_REQUEST_ID, VERIFY_TIMEOUT));
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    ASSERT_TRUE(testExpectSpeechWaits(WITH_DIALOG_REQUEST_ID, VERIFY_TIMEOUT, audioInputProcessorTestData.m_agentId));
 }
 
 /**
@@ -2672,17 +3093,25 @@ TEST_F(AudioInputProcessorTest, test_expectSpeechUnreadableDefaultNoPrevious) {
  */
 TEST_F(AudioInputProcessorTest, test_expectSpeechUnreadableDefaultUnreadablePrevious) {
     makeDefaultAudioProviderNotAlwaysReadable();
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::PRESS_AND_HOLD, 0));
+    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::PRESS_AND_HOLD, 0));
     ASSERT_TRUE(testStopCaptureSucceeds());
     ASSERT_TRUE(testExpectSpeechWaits(WITH_DIALOG_REQUEST_ID, VERIFY_TIMEOUT));
 }
 
 /// This function verifies that ExpectSpeech directives work with no default and readable previous @c AudioProvider.
-TEST_F(AudioInputProcessorTest, test_expectSpeechNoDefaultReadablePrevious) {
+TEST_P(AudioInputProcessorTest, test_expectSpeechNoDefaultReadablePrevious) {
     removeDefaultAudioProvider();
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::PRESS_AND_HOLD, 0));
+    m_overrideGestures = true;
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    ASSERT_TRUE(testRecognizeSucceeds(
+        *m_audioProvider,
+        AgentInitiator::PRESS_AND_HOLD,
+        0,
+        AudioInputProcessor::INVALID_INDEX,
+        "",
+        audioInputProcessorTestData.m_agentId));
     ASSERT_TRUE(testStopCaptureSucceeds());
-    ASSERT_TRUE(testExpectSpeechSucceeds(WITH_DIALOG_REQUEST_ID));
+    ASSERT_TRUE(testExpectSpeechSucceeds(WITH_DIALOG_REQUEST_ID, audioInputProcessorTestData.m_agentId));
 }
 
 /// This function verifies that the initiator from an ExpectSpeech is passed to a subsequent Recognize.
@@ -2705,17 +3134,18 @@ TEST_F(AudioInputProcessorTest, test_expectSpeechWithNoInitiator) {
 TEST_F(AudioInputProcessorTest, test_expectSpeechWithInitiatorTimedOut) {
     removeDefaultAudioProvider();
     ASSERT_TRUE(testExpectSpeechWaits(WITH_DIALOG_REQUEST_ID, VERIFY_TIMEOUT));
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP));
+    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::TAP));
 }
 
 /**
  * This function verifies that ExpectSpeech directives can be handled externally and that AIP may be notified back of
  * an ExpectSpeech timeout with an @c AudioProvider that is not always readable.
  */
-TEST_F(AudioInputProcessorTest, handleExpectSpeechTimeoutExternallyWithTimeout) {
+TEST_P(AudioInputProcessorTest, handleExpectSpeechTimeoutExternallyWithTimeout) {
     m_audioProvider->alwaysReadable = false;
     addExpectSpeechTimeoutHandler();
-    ASSERT_TRUE(testExpectSpeechExternalHandling(true));
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    ASSERT_TRUE(testExpectSpeechExternalHandling(true, audioInputProcessorTestData.m_agentId));
 }
 
 /**
@@ -2723,32 +3153,37 @@ TEST_F(AudioInputProcessorTest, handleExpectSpeechTimeoutExternallyWithTimeout)
  * EXPECTING_SPEECH state if no call is made back to AIP to notify of an ExpectSpeech timeout with an @c AudioProvider
  * that is not always readable.
  */
-TEST_F(AudioInputProcessorTest, handleExpectSpeechTimeoutExternallyWithoutTimeout) {
+TEST_P(AudioInputProcessorTest, handleExpectSpeechTimeoutExternallyWithoutTimeout) {
     m_audioProvider->alwaysReadable = false;
     addExpectSpeechTimeoutHandler();
-    ASSERT_TRUE(testExpectSpeechExternalHandling(false));
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    EXPECT_CALL(*m_mockPowerResourceManager, acquire(IsSamePowerResource(COMPONENT_NAME), _)).Times(AtLeast(1));
+    EXPECT_CALL(*m_mockPowerResourceManager, release(IsSamePowerResource(COMPONENT_NAME))).Times(AtLeast(1));
+    ASSERT_TRUE(testExpectSpeechExternalHandling(false, audioInputProcessorTestData.m_agentId));
 }
 
 /**
  * This function verifies that ExpectSpeech directives that are not handled externally with an always readable @c
  * AudioProvider will result in an automatic transition to RECOGNIZING.
  */
-TEST_F(AudioInputProcessorTest, handleExpectSpeechTimeoutInternallyWithAlwaysReadableAudioProviderResultsInRecognize) {
+TEST_P(AudioInputProcessorTest, handleExpectSpeechTimeoutInternallyWithAlwaysReadableAudioProviderResultsInRecognize) {
     m_audioProvider->alwaysReadable = true;
     addExpectSpeechTimeoutHandler();
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
     EXPECT_CALL(*m_mockExpectSpeechTimeoutHandler, handleExpectSpeechTimeout(_, _)).WillOnce(Return(false));
-    ASSERT_TRUE(testExpectSpeechSucceeds(WITH_DIALOG_REQUEST_ID));
+    ASSERT_TRUE(testExpectSpeechSucceeds(WITH_DIALOG_REQUEST_ID, audioInputProcessorTestData.m_agentId));
 }
 
 /**
  * This function verifies that ExpectSpeech directives that are handled externally with an always readable @c
  * AudioProvider will result in an automatic transition to RECOGNIZING.
  */
-TEST_F(AudioInputProcessorTest, handleExpectSpeechTimeoutExternallyWithAlwaysReadableAudioProviderResultsInRecognize) {
+TEST_P(AudioInputProcessorTest, handleExpectSpeechTimeoutExternallyWithAlwaysReadableAudioProviderResultsInRecognize) {
     m_audioProvider->alwaysReadable = true;
     addExpectSpeechTimeoutHandler();
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
     EXPECT_CALL(*m_mockExpectSpeechTimeoutHandler, handleExpectSpeechTimeout(_, _)).WillOnce(Return(true));
-    ASSERT_TRUE(testExpectSpeechSucceeds(WITH_DIALOG_REQUEST_ID));
+    ASSERT_TRUE(testExpectSpeechSucceeds(WITH_DIALOG_REQUEST_ID, audioInputProcessorTestData.m_agentId));
 }
 
 /// This function verifies that a focus change to @c FocusState::BACKGROUND causes the @c AudioInputProcessor to
@@ -2766,81 +3201,116 @@ TEST_F(AudioInputProcessorTest, test_focusChangedNone) {
 /// Test that the @c AudioInputProcessor correctly transitions to @c State::IDLE
 /// if @c Status::TIMEDOUT is received
 TEST_F(AudioInputProcessorTest, test_resetStateOnTimeOut) {
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
-
-    EXPECT_CALL(*m_mockFocusManager, releaseChannel(CHANNEL_NAME, _));
-    EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::IDLE));
+    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::TAP, 0));
+    bool done = false;
+    std::mutex mutex;
+    std::condition_variable conditionVariable;
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::IDLE))
+        .WillOnce(Invoke([&](avsCommon::avs::AgentId::IdType agentId,
+                             avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface::State state) {
+            std::lock_guard<std::mutex> lock(mutex);
+            done = true;
+            conditionVariable.notify_one();
+        }));
+    EXPECT_CALL(*m_mockPowerResourceManager, release(IsSamePowerResource(COMPONENT_NAME))).Times(AtLeast(1));
     m_audioInputProcessor->onSendCompleted(avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status::TIMEDOUT);
+    std::unique_lock<std::mutex> lock(mutex);
+    auto setCompletedResult = conditionVariable.wait_for(lock, TEST_TIMEOUT, [&done] { return done; });
+    EXPECT_TRUE(setCompletedResult);
 }
 
 /*
- * This function verifies that @c AudioInputProcessor::recognize() works with @c Initiator::WAKEWORD and keyword
+ * This function verifies that @c AudioInputProcessor::recognize() works with @c AgentInitiator::WAKEWORD and keyword
  */
-TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithESPWithKeyword) {
+TEST_P(AudioInputProcessorTest, test_recognizeWakewordWithESPWithKeyword) {
     auto begin = AudioInputProcessor::INVALID_INDEX;
     auto end = AudioInputProcessor::INVALID_INDEX;
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
     // note that we are just using a integer instead of a float number, this is to help with JSON verification.
     EXPECT_TRUE(testRecognizeSucceeds(
-        *m_audioProvider, Initiator::WAKEWORD, begin, end, KEYWORD_TEXT, RecognizeStopPoint::NONE, nullptr));
+        *m_audioProvider,
+        AgentInitiator::WAKEWORD,
+        begin,
+        end,
+        audioInputProcessorTestData.m_wakeword,
+        avsCommon::avs::AgentId::AGENT_ID_NONE,
+        RecognizeStopPoint::NONE,
+        nullptr));
 }
 
 /*
- * This function verifies that @c AudioInputProcessor::recognize() works with @c Initiator::WAKEWORD and keyword
+ * This function verifies that @c AudioInputProcessor::recognize() works with @c AgentInitiator::WAKEWORD and keyword
  * The ReportEchoSpatialPerceptionData event will not be sent but the Recognize event should still be
  * sent.
  */
-TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithInvalidESPWithKeyword) {
+TEST_P(AudioInputProcessorTest, test_recognizeWakewordWithInvalidESPWithKeyword) {
     auto begin = AudioInputProcessor::INVALID_INDEX;
     auto end = AudioInputProcessor::INVALID_INDEX;
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
     EXPECT_TRUE(testRecognizeSucceeds(
-        *m_audioProvider, Initiator::WAKEWORD, begin, end, KEYWORD_TEXT, RecognizeStopPoint::NONE, nullptr));
+        *m_audioProvider,
+        AgentInitiator::WAKEWORD,
+        begin,
+        end,
+        audioInputProcessorTestData.m_wakeword,
+        avsCommon::avs::AgentId::AGENT_ID_NONE,
+        RecognizeStopPoint::NONE,
+        nullptr));
 }
 
 /*
  * This function verifies that @c AudioInputProcessor::recognize() works with OPUS encoding used with
- * @c Initiator::TAP.
+ * @c AgentInitiator::TAP.
  */
 TEST_F(AudioInputProcessorTest, test_recognizeOPUSWithTap) {
     m_audioProvider->format.encoding = avsCommon::utils::AudioFormat::Encoding::OPUS;
     m_audioProvider->format.sampleRateHz = 32000;
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP));
+    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::TAP));
 }
 
 /*
  * This function verifies that @c AudioInputProcessor::recognize() works with OPUS encoding used with
- * @c Initiator::PRESS_AND_HOLD.
+ * @c AgentInitiator::PRESS_AND_HOLD.
  */
 TEST_F(AudioInputProcessorTest, test_recognizeOPUSWithPressAndHold) {
     m_audioProvider->format.encoding = avsCommon::utils::AudioFormat::Encoding::OPUS;
     m_audioProvider->format.sampleRateHz = 32000;
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::PRESS_AND_HOLD));
+    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::PRESS_AND_HOLD));
 }
 
 /**
  * This function verifies that @c AudioInputProcessor::recognize() works with OPUS encoding used with
- * @c Initiator::WAKEWORD valid begin and end indices.
+ * @c AgentInitiator::WAKEWORD valid begin and end indices.
  */
 TEST_F(AudioInputProcessorTest, test_recognizeOPUSWithWakeWord) {
     avsCommon::avs::AudioInputStream::Index begin = 0;
     avsCommon::avs::AudioInputStream::Index end = AudioInputProcessor::INVALID_INDEX;
     m_audioProvider->format.encoding = avsCommon::utils::AudioFormat::Encoding::OPUS;
     m_audioProvider->format.sampleRateHz = 32000;
-    EXPECT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::WAKEWORD, begin, end, KEYWORD_TEXT));
+    EXPECT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::WAKEWORD, begin, end, KEYWORD_TEXT));
 }
 
 /**
  * This function verifies that @c AudioInputProcessor::recognize() creates a @c MessageRequest with KWDMetadata
  * When metadata has been received
  */
-TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithKWDMetadata) {
+TEST_P(AudioInputProcessorTest, test_recognizeWakewordWithKWDMetadata) {
     auto begin = AudioInputProcessor::INVALID_INDEX;
     auto end = AudioInputProcessor::INVALID_INDEX;
 
     auto metadata = std::make_shared<std::vector<char>>();
     metadata->assign(KWD_METADATA_EXAMPLE.data(), KWD_METADATA_EXAMPLE.data() + KWD_METADATA_EXAMPLE.length());
-
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
     EXPECT_TRUE(testRecognizeSucceeds(
-        *m_audioProvider, Initiator::WAKEWORD, begin, end, KEYWORD_TEXT, RecognizeStopPoint::NONE, nullptr, metadata));
+        *m_audioProvider,
+        AgentInitiator::WAKEWORD,
+        begin,
+        end,
+        audioInputProcessorTestData.m_wakeword,
+        avsCommon::avs::AgentId::AGENT_ID_NONE,
+        RecognizeStopPoint::NONE,
+        nullptr,
+        metadata));
 }
 
 /**
@@ -2850,8 +3320,8 @@ TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithKWDMetadata) {
 TEST_F(AudioInputProcessorTest, test_recognizeInvalidWakeWord) {
     avsCommon::avs::AudioInputStream::Index begin = PREROLL_WORDS;
     avsCommon::avs::AudioInputStream::Index end = PREROLL_WORDS + WAKEWORD_WORDS;
-    EXPECT_TRUE(
-        testRecognizeFails(*m_audioProvider, Initiator::WAKEWORD, begin, end, AudioInputProcessor::KEYWORD_TEXT_STOP));
+    EXPECT_TRUE(testRecognizeFails(
+        *m_audioProvider, AgentInitiator::WAKEWORD, begin, end, AudioInputProcessor::KEYWORD_TEXT_STOP));
 }
 
 /**
@@ -3224,14 +3694,23 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessAndDirectiveBefor
  * directive.
  */
 TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessAndDirective) {
+    bool done = false;
+    std::mutex mutex;
+    std::condition_variable conditionVariable;
     // Simulate tap to talk and start recognizing.
-    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::TAP, 0));
+    ASSERT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::TAP, 0));
 
     // Expect some AIP transient states.
-    EXPECT_CALL(*m_mockObserver, onStateChanged(_)).Times(AtLeast(0));
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, _)).Times(AtLeast(0));
 
     // Expect final state to be IDLE.
-    EXPECT_CALL(*m_mockObserver, onStateChanged(AudioInputProcessorObserverInterface::State::IDLE)).Times(1);
+    EXPECT_CALL(*m_mockObserver, onStateChanged(_, AudioInputProcessorObserverInterface::State::IDLE))
+        .WillOnce(Invoke([&](avsCommon::avs::AgentId::IdType agentId,
+                             avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface::State state) {
+            std::lock_guard<std::mutex> lock(mutex);
+            done = true;
+            conditionVariable.notify_one();
+        }));
 
     // Expect channel to be released
     EXPECT_CALL(*m_mockFocusManager, releaseChannel(CHANNEL_NAME, _));
@@ -3249,6 +3728,10 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamSuccessAndDirective) {
 
     m_audioInputProcessor->CapabilityAgent::preHandleDirective(avsDirective, std::move(result));
     m_audioInputProcessor->CapabilityAgent::handleDirective(m_messageId);
+
+    std::unique_lock<std::mutex> lock(mutex);
+    auto setCompletedResult = conditionVariable.wait_for(lock, TEST_TIMEOUT, [&done] { return done; });
+    EXPECT_TRUE(setCompletedResult);
 }
 
 /**
@@ -3398,7 +3881,7 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureOnStreamUnknownServerErrorAndDir
 /*
  * This function verifies that the SET_END_OF_SPEECH_OFFSET directive is handled properly in the successful case
  */
-TEST_F(AudioInputProcessorTest, test_handleSetEndOfSpeechOffsetSuccess) {
+TEST_P(AudioInputProcessorTest, test_handleSetEndOfSpeechOffsetSuccess) {
     rapidjson::Document document(rapidjson::kObjectType);
     rapidjson::Value payloadJson(rapidjson::kObjectType);
     rapidjson::Value endOfSpeechOffsetMilliseconds(END_OF_SPEECH_OFFSET_IN_MILLISECONDS);
@@ -3407,7 +3890,9 @@ TEST_F(AudioInputProcessorTest, test_handleSetEndOfSpeechOffsetSuccess) {
         rapidjson::StringRef(START_OF_SPEECH_TIMESTAMP_FIELD_NAME), startOfSpeechTimestamp, document.GetAllocator());
     payloadJson.AddMember(
         rapidjson::StringRef(END_OF_SPEECH_OFFSET_FIELD_NAME), endOfSpeechOffsetMilliseconds, document.GetAllocator());
-    auto avsDirective = createAVSDirective(SET_END_OF_SPEECH_OFFSET, true, true, document, payloadJson);
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    auto avsDirective = createAVSDirective(
+        SET_END_OF_SPEECH_OFFSET, true, audioInputProcessorTestData.m_agentId, true, document, payloadJson);
     std::shared_ptr<avsCommon::sdkInterfaces::DirectiveHandlerInterface> directiveHandler = m_audioInputProcessor;
     auto result = avsCommon::utils::memory::make_unique<avsCommon::sdkInterfaces::test::MockDirectiveHandlerResult>();
     EXPECT_CALL(*result, setCompleted());
@@ -3418,12 +3903,14 @@ TEST_F(AudioInputProcessorTest, test_handleSetEndOfSpeechOffsetSuccess) {
 /**
  * This function verifies that the SET_END_OF_SPEECH_OFFSET directive gracefully handles invalid offset values
  */
-TEST_F(AudioInputProcessorTest, test_handleSetEndOfSpeechOffsetFailureInvalid) {
+TEST_P(AudioInputProcessorTest, test_handleSetEndOfSpeechOffsetFailureInvalid) {
     rapidjson::Document document(rapidjson::kObjectType);
     rapidjson::Value payloadJson(rapidjson::kObjectType);
     rapidjson::Value badValue("foobar");
     payloadJson.AddMember(rapidjson::StringRef(END_OF_SPEECH_OFFSET_FIELD_NAME), badValue, document.GetAllocator());
-    auto avsDirective = createAVSDirective(SET_END_OF_SPEECH_OFFSET, true, true, document, payloadJson);
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    auto avsDirective = createAVSDirective(
+        SET_END_OF_SPEECH_OFFSET, true, audioInputProcessorTestData.m_agentId, true, document, payloadJson);
     std::shared_ptr<avsCommon::sdkInterfaces::DirectiveHandlerInterface> directiveHandler = m_audioInputProcessor;
     auto result = avsCommon::utils::memory::make_unique<avsCommon::sdkInterfaces::test::MockDirectiveHandlerResult>();
     EXPECT_CALL(*result, setFailed(_));
@@ -3434,10 +3921,12 @@ TEST_F(AudioInputProcessorTest, test_handleSetEndOfSpeechOffsetFailureInvalid) {
 /**
  * This function verifies that the SET_END_OF_SPEECH_OFFSET directive gracefully handles missing offset values
  */
-TEST_F(AudioInputProcessorTest, test_handleSetEndOfSpeechOffsetFailureMissing) {
+TEST_P(AudioInputProcessorTest, test_handleSetEndOfSpeechOffsetFailureMissing) {
     rapidjson::Document document(rapidjson::kObjectType);
     rapidjson::Value payloadJson(rapidjson::kObjectType);
-    auto avsDirective = createAVSDirective(SET_END_OF_SPEECH_OFFSET, true, true, document, payloadJson);
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    auto avsDirective = createAVSDirective(
+        SET_END_OF_SPEECH_OFFSET, true, audioInputProcessorTestData.m_agentId, true, document, payloadJson);
     std::shared_ptr<avsCommon::sdkInterfaces::DirectiveHandlerInterface> directiveHandler = m_audioInputProcessor;
     auto result = avsCommon::utils::memory::make_unique<avsCommon::sdkInterfaces::test::MockDirectiveHandlerResult>();
     EXPECT_CALL(*result, setFailed(_));
@@ -3448,7 +3937,7 @@ TEST_F(AudioInputProcessorTest, test_handleSetEndOfSpeechOffsetFailureMissing) {
 /**
  * This function verifies that the SetWakeWordConfirmation directive can be handled successfully.
  */
-TEST_F(AudioInputProcessorTest, test_handleSetWakeWordConfirmation) {
+TEST_P(AudioInputProcessorTest, test_handleSetWakeWordConfirmation) {
     rapidjson::Document document(rapidjson::kObjectType);
     rapidjson::Value payloadJson(rapidjson::kObjectType);
 
@@ -3465,8 +3954,9 @@ TEST_F(AudioInputProcessorTest, test_handleSetWakeWordConfirmation) {
             waitEvent.wakeUp();
             return true;
         }));
-
-    auto avsDirective = createAVSDirective(SET_WAKE_WORD_CONFIRMATION, true, true, document, payloadJson);
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    auto avsDirective = createAVSDirective(
+        SET_WAKE_WORD_CONFIRMATION, true, audioInputProcessorTestData.m_agentId, true, document, payloadJson);
     std::shared_ptr<avsCommon::sdkInterfaces::DirectiveHandlerInterface> directiveHandler = m_audioInputProcessor;
     directiveHandler->handleDirectiveImmediately(avsDirective);
 
@@ -3477,7 +3967,7 @@ TEST_F(AudioInputProcessorTest, test_handleSetWakeWordConfirmation) {
 /**
  * This function verifies that the SetSpeechConfirmation directive can be handled successfully.
  */
-TEST_F(AudioInputProcessorTest, test_setSpeechConfirmation) {
+TEST_P(AudioInputProcessorTest, test_setSpeechConfirmation) {
     rapidjson::Document document(rapidjson::kObjectType);
     rapidjson::Value payloadJson(rapidjson::kObjectType);
 
@@ -3495,7 +3985,9 @@ TEST_F(AudioInputProcessorTest, test_setSpeechConfirmation) {
             return true;
         }));
 
-    auto avsDirective = createAVSDirective(SET_SPEECH_CONFIRMATION, true, true, document, payloadJson);
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
+    auto avsDirective = createAVSDirective(
+        SET_SPEECH_CONFIRMATION, true, audioInputProcessorTestData.m_agentId, true, document, payloadJson);
     std::shared_ptr<avsCommon::sdkInterfaces::DirectiveHandlerInterface> directiveHandler = m_audioInputProcessor;
     directiveHandler->handleDirectiveImmediately(avsDirective);
 
@@ -3506,7 +3998,7 @@ TEST_F(AudioInputProcessorTest, test_setSpeechConfirmation) {
 /**
  * Test if SetWakeWords directive is handled correctly.
  */
-TEST_F(AudioInputProcessorTest, test_setWakeWordsDirectiveSuccess) {
+TEST_P(AudioInputProcessorTest, test_setWakeWordsDirectiveSuccess) {
     // Prepare the directive JSON:
     // "directive": {
     //     "header": {
@@ -3539,9 +4031,10 @@ TEST_F(AudioInputProcessorTest, test_setWakeWordsDirectiveSuccess) {
             waitEvent.wakeUp();
             return true;
         }));
-
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
     // Handle the directive
-    auto avsDirective = createAVSDirective(SET_WAKE_WORDS, true, true, document, payloadJson);
+    auto avsDirective =
+        createAVSDirective(SET_WAKE_WORDS, true, audioInputProcessorTestData.m_agentId, true, document, payloadJson);
     std::shared_ptr<avsCommon::sdkInterfaces::DirectiveHandlerInterface> directiveHandler = m_audioInputProcessor;
     directiveHandler->handleDirectiveImmediately(avsDirective);
 
@@ -3674,17 +4167,19 @@ TEST_F(AudioInputProcessorTest, test_requestEncodingAudioFormatsFails) {
     EXPECT_EQ(m_audioInputProcessor->getEncodingAudioFormats(), expectedRsp);
 }
 
-/// This function verifies that @c AudioInputProcessor::recognize() works with @c Initiator::WAKEWORD and keyword for
-/// multiple audio streams
-TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithKeywordForMultiStreams) {
+/// This function verifies that @c AudioInputProcessor::recognize() works with @c AgentInitiator::WAKEWORD and keyword
+/// for multiple audio streams
+TEST_P(AudioInputProcessorTest, test_recognizeWakewordWithKeywordForMultiStreams) {
     setupEncoderTest();
     testRequestEncodingAudioFormatsSucceeds();
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
     ASSERT_TRUE(testRecognizeSucceeds(
         *m_audioProvider,
-        Initiator::WAKEWORD,
+        AgentInitiator::WAKEWORD,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
-        KEYWORD_TEXT,
+        audioInputProcessorTestData.m_wakeword,
+        avsCommon::avs::AgentId::AGENT_ID_NONE,
         RecognizeStopPoint::NONE,
         nullptr,
         nullptr,
@@ -3693,18 +4188,20 @@ TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithKeywordForMultiStreams
 }
 
 /// This function verifies that recognize() works with KWD metadata for multiple audio streams
-TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithMetadataForMultipleAudioStreams) {
+TEST_P(AudioInputProcessorTest, test_recognizeWakewordWithMetadataForMultipleAudioStreams) {
     setupEncoderTest();
     testRequestEncodingAudioFormatsSucceeds();
 
     auto metadata = std::make_shared<std::vector<char>>();
     metadata->assign(KWD_METADATA_EXAMPLE.data(), KWD_METADATA_EXAMPLE.data() + KWD_METADATA_EXAMPLE.length());
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
     ASSERT_TRUE(testRecognizeSucceeds(
         *m_audioProvider,
-        Initiator::WAKEWORD,
+        AgentInitiator::WAKEWORD,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
-        KEYWORD_TEXT,
+        audioInputProcessorTestData.m_wakeword,
+        avsCommon::avs::AgentId::AGENT_ID_NONE,
         RecognizeStopPoint::NONE,
         nullptr,
         metadata,
@@ -3714,18 +4211,20 @@ TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithMetadataForMultipleAud
 
 /// This function verifies that recognize() works for multiple audio streams when stopCapture is called after message is
 /// sent
-TEST_F(AudioInputProcessorTest, test_recognizeWakewordStopAfterSendForMultiStreams) {
+TEST_P(AudioInputProcessorTest, test_recognizeWakewordStopAfterSendForMultiStreams) {
     setupEncoderTest();
     testRequestEncodingAudioFormatsSucceeds();
 
     auto metadata = std::make_shared<std::vector<char>>();
     metadata->assign(KWD_METADATA_EXAMPLE.data(), KWD_METADATA_EXAMPLE.data() + KWD_METADATA_EXAMPLE.length());
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
     ASSERT_TRUE(testRecognizeSucceeds(
         *m_audioProvider,
-        Initiator::WAKEWORD,
+        AgentInitiator::WAKEWORD,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
-        KEYWORD_TEXT,
+        audioInputProcessorTestData.m_wakeword,
+        avsCommon::avs::AgentId::AGENT_ID_NONE,
         RecognizeStopPoint::AFTER_SEND,
         nullptr,
         metadata,
@@ -3735,18 +4234,20 @@ TEST_F(AudioInputProcessorTest, test_recognizeWakewordStopAfterSendForMultiStrea
 
 /// This function verifies that recognize() works for multiple audio streams when stopCapture is called immediately
 /// after recognize() is called.
-TEST_F(AudioInputProcessorTest, test_recognizeWakewordStopAfterRecognizeForMultiStreams) {
+TEST_P(AudioInputProcessorTest, test_recognizeWakewordStopAfterRecognizeForMultiStreams) {
     setupEncoderTest();
     testRequestEncodingAudioFormatsSucceeds();
 
     auto metadata = std::make_shared<std::vector<char>>();
     metadata->assign(KWD_METADATA_EXAMPLE.data(), KWD_METADATA_EXAMPLE.data() + KWD_METADATA_EXAMPLE.length());
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
     ASSERT_TRUE(testRecognizeSucceeds(
         *m_audioProvider,
-        Initiator::WAKEWORD,
+        AgentInitiator::WAKEWORD,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
-        KEYWORD_TEXT,
+        audioInputProcessorTestData.m_wakeword,
+        avsCommon::avs::AgentId::AGENT_ID_NONE,
         RecognizeStopPoint::AFTER_RECOGNIZE,
         nullptr,
         metadata,
@@ -3756,18 +4257,20 @@ TEST_F(AudioInputProcessorTest, test_recognizeWakewordStopAfterRecognizeForMulti
 
 /// This function verifies that recognize() works for multiple audio streams when stopCapture is called immediately
 /// after onContextAvailable() called.
-TEST_F(AudioInputProcessorTest, test_recognizeWakewordStopAfterContextForMultiStreams) {
+TEST_P(AudioInputProcessorTest, test_recognizeWakewordStopAfterContextForMultiStreams) {
     setupEncoderTest();
     testRequestEncodingAudioFormatsSucceeds();
 
     auto metadata = std::make_shared<std::vector<char>>();
     metadata->assign(KWD_METADATA_EXAMPLE.data(), KWD_METADATA_EXAMPLE.data() + KWD_METADATA_EXAMPLE.length());
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
     ASSERT_TRUE(testRecognizeSucceeds(
         *m_audioProvider,
-        Initiator::WAKEWORD,
+        AgentInitiator::WAKEWORD,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
-        KEYWORD_TEXT,
+        audioInputProcessorTestData.m_wakeword,
+        avsCommon::avs::AgentId::AGENT_ID_NONE,
         RecognizeStopPoint::AFTER_CONTEXT,
         nullptr,
         metadata,
@@ -3777,18 +4280,20 @@ TEST_F(AudioInputProcessorTest, test_recognizeWakewordStopAfterContextForMultiSt
 
 /// This function verifies that recognize() works for multiple audio streams when stopCapture() is called after
 /// onFocusChanged() called.
-TEST_F(AudioInputProcessorTest, test_recognizeWakewordStopCaptureAfterFocusForMultiStreams) {
+TEST_P(AudioInputProcessorTest, test_recognizeWakewordStopCaptureAfterFocusForMultiStreams) {
     setupEncoderTest();
     testRequestEncodingAudioFormatsSucceeds();
 
     auto metadata = std::make_shared<std::vector<char>>();
     metadata->assign(KWD_METADATA_EXAMPLE.data(), KWD_METADATA_EXAMPLE.data() + KWD_METADATA_EXAMPLE.length());
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
     ASSERT_TRUE(testRecognizeSucceeds(
         *m_audioProvider,
-        Initiator::WAKEWORD,
+        AgentInitiator::WAKEWORD,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
-        KEYWORD_TEXT,
+        audioInputProcessorTestData.m_wakeword,
+        avsCommon::avs::AgentId::AGENT_ID_NONE,
         RecognizeStopPoint::AFTER_FOCUS,
         nullptr,
         metadata,
@@ -3799,7 +4304,7 @@ TEST_F(AudioInputProcessorTest, test_recognizeWakewordStopCaptureAfterFocusForMu
 /**
  * This function verifies that recognize() works for multiple streams when valid begin and end indices are provided.
  */
-TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithGoodBeginAndEndForMultiStreams) {
+TEST_P(AudioInputProcessorTest, test_recognizeWakewordWithGoodBeginAndEndForMultiStreams) {
     avsCommon::avs::AudioInputStream::Index begin = PREROLL_WORDS;
     avsCommon::avs::AudioInputStream::Index end = PREROLL_WORDS + WAKEWORD_WORDS;
 
@@ -3808,12 +4313,14 @@ TEST_F(AudioInputProcessorTest, test_recognizeWakewordWithGoodBeginAndEndForMult
 
     auto metadata = std::make_shared<std::vector<char>>();
     metadata->assign(KWD_METADATA_EXAMPLE.data(), KWD_METADATA_EXAMPLE.data() + KWD_METADATA_EXAMPLE.length());
+    AudioInputProcessorTestData audioInputProcessorTestData = GetParam();
     ASSERT_TRUE(testRecognizeSucceeds(
         *m_audioProvider,
-        Initiator::WAKEWORD,
+        AgentInitiator::WAKEWORD,
         begin,
         end,
-        KEYWORD_TEXT,
+        audioInputProcessorTestData.m_wakeword,
+        avsCommon::avs::AgentId::AGENT_ID_NONE,
         RecognizeStopPoint::NONE,
         nullptr,
         metadata,
@@ -3831,10 +4338,11 @@ TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingCloseTalkFo
 
     ASSERT_TRUE(testRecognizeSucceeds(
         audioProvider,
-        Initiator::TAP,
+        AgentInitiator::TAP,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
         "",
+        avsCommon::avs::AgentId::getAlexaAgentId(),
         RecognizeStopPoint::NONE,
         nullptr,
         nullptr,
@@ -3842,10 +4350,11 @@ TEST_F(AudioInputProcessorTest, test_recognizeBargeInWhileRecognizingCloseTalkFo
         EXPECTED_ENCODING_FORMATS));
     ASSERT_TRUE(testRecognizeSucceeds(
         *m_audioProvider,
-        Initiator::TAP,
+        AgentInitiator::TAP,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
         "",
+        avsCommon::avs::AgentId::getAlexaAgentId(),
         RecognizeStopPoint::NONE,
         nullptr,
         nullptr,
@@ -3861,10 +4370,11 @@ TEST_F(AudioInputProcessorTest, test_stopCaptureWhenRecognizingForMultiStreams)
 
     ASSERT_TRUE(testRecognizeSucceeds(
         *m_audioProvider,
-        Initiator::TAP,
+        AgentInitiator::TAP,
         AudioInputProcessor::INVALID_INDEX,
         AudioInputProcessor::INVALID_INDEX,
         "",
+        avsCommon::avs::AgentId::getAlexaAgentId(),
         RecognizeStopPoint::NONE,
         nullptr,
         nullptr,
@@ -3893,7 +4403,7 @@ TEST_F(AudioInputProcessorTest, test_recognizeWorksWithOneFormatInRequestEncodin
 
     auto begin = AudioInputProcessor::INVALID_INDEX;
     auto end = AudioInputProcessor::INVALID_INDEX;
-    EXPECT_TRUE(testRecognizeSucceeds(*m_audioProvider, Initiator::WAKEWORD, begin, end, KEYWORD_TEXT));
+    EXPECT_TRUE(testRecognizeSucceeds(*m_audioProvider, AgentInitiator::WAKEWORD, begin, end, KEYWORD_TEXT));
 }
 }  // namespace test
 }  // namespace aip
diff --git a/CapabilityAgents/AIP/test/CMakeLists.txt b/CapabilityAgents/AIP/test/CMakeLists.txt
index 640e5e0e..c438c102 100644
--- a/CapabilityAgents/AIP/test/CMakeLists.txt
+++ b/CapabilityAgents/AIP/test/CMakeLists.txt
@@ -5,4 +5,4 @@ set(INCLUDE_PATH
     "${AVSCommon_SOURCE_DIR}/AVS/test"
     "${DeviceSettings_SOURCE_DIR}/test")
 
-discover_unit_tests("${INCLUDE_PATH}" "AIP;UtilsCommonTestLib;CertifiedSenderCommonTestLib;AVSSystem;SDKInterfacesTests")
+discover_unit_tests("${INCLUDE_PATH}" "AIP;MultiAgentInterfaceTestUtils;UtilsCommonTestLib;CertifiedSenderCommonTestLib;AVSSystem;SDKInterfacesTests")
diff --git a/CapabilityAgents/AIP/test/MockObserver.h b/CapabilityAgents/AIP/test/MockObserver.h
index b5976408..76dbf988 100644
--- a/CapabilityAgents/AIP/test/MockObserver.h
+++ b/CapabilityAgents/AIP/test/MockObserver.h
@@ -28,7 +28,11 @@ namespace test {
 /// Mock class that implements the Observer.
 class MockObserver : public avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface {
 public:
-    MOCK_METHOD1(onStateChanged, void(avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface::State state));
+    MOCK_METHOD2(
+        onStateChanged,
+        void(
+            avsCommon::avs::AgentId::IdType agentId,
+            avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface::State state));
 };
 
 }  // namespace test
diff --git a/CapabilityAgents/CMakeLists.txt b/CapabilityAgents/CMakeLists.txt
index 013ad927..f2b5aa83 100644
--- a/CapabilityAgents/CMakeLists.txt
+++ b/CapabilityAgents/CMakeLists.txt
@@ -9,6 +9,7 @@ set(CAPABILITY_AGENTS
         "ApiGateway"
         "Equalizer"
         "InteractionModel"
+        "Messaging"
         "Notifications"
         "PlaybackController"
         "SoftwareComponentReporter"
diff --git a/CapabilityAgents/InteractionModel/acsdkInteractionModel/include/acsdkInteractionModel/InteractionModelFactory.h b/CapabilityAgents/InteractionModel/acsdkInteractionModel/include/acsdkInteractionModel/InteractionModelFactory.h
new file mode 100644
index 00000000..5c2ec7c0
--- /dev/null
+++ b/CapabilityAgents/InteractionModel/acsdkInteractionModel/include/acsdkInteractionModel/InteractionModelFactory.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_CAPABILITYAGENTS_INTERACTIONMODEL_ACSDKINTERACTIONMODEL_INCLUDE_ACSDKINTERACTIONMODEL_INTERACTIONMODELFACTORY_H_
+#define ALEXA_CLIENT_SDK_CAPABILITYAGENTS_INTERACTIONMODEL_ACSDKINTERACTIONMODEL_INCLUDE_ACSDKINTERACTIONMODEL_INTERACTIONMODELFACTORY_H_
+
+#include <memory>
+
+#include <acsdkInteractionModelInterfaces/InteractionModelNotifierInterface.h>
+#include <AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h>
+#include <AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h>
+#include <AVSCommon/SDKInterfaces/ExceptionEncounteredSenderInterface.h>
+#include <AVSCommon/Utils/Optional.h>
+
+namespace alexaClientSDK {
+namespace acsdkInteractionModel {
+
+/// This structure contains the interfaces to interact with the InputController Capability Agent.
+struct InteractionModelFactoryInterfaces {
+    /// Interface for handling @c AVSDirectives.
+    std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::DirectiveHandlerInterface> directiveHandler;
+
+    /// Interface providing CapabilitiesDelegate access to the version and configurations of the capabilities.
+    std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::CapabilityConfigurationInterface>
+        capabilityConfigurationInterface;
+
+    /// Interface for Notifier.
+    std::shared_ptr<acsdkInteractionModelInterfaces::InteractionModelNotifierInterface> notifier;
+};
+
+/**
+ * Creates a new InteractionModel Capability Agent
+ *
+ * @param directiveSequencer The Directive Sequencer responsible for processing AVS directives.
+ * @param exceptionEncounteredSender The object to use for sending AVS Exception messages.
+ * @return An @c Optional @c InputControllerFactoryInterfaces object.
+ */
+avsCommon::utils::Optional<InteractionModelFactoryInterfaces> createInteractionModelCA(
+    const std::shared_ptr<avsCommon::sdkInterfaces::DirectiveSequencerInterface>& directiveSequencer,
+    const std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>& exceptionEncounteredSender);
+
+}  // namespace acsdkInteractionModel
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_CAPABILITYAGENTS_INTERACTIONMODEL_ACSDKINTERACTIONMODEL_INCLUDE_ACSDKINTERACTIONMODEL_INTERACTIONMODELFACTORY_H_
diff --git a/CapabilityAgents/InteractionModel/acsdkInteractionModel/privateInclude/acsdkInteractionModel/InteractionModelCapabilityAgent.h b/CapabilityAgents/InteractionModel/acsdkInteractionModel/privateInclude/acsdkInteractionModel/InteractionModelCapabilityAgent.h
index 3e32fbea..f5fe0fa2 100644
--- a/CapabilityAgents/InteractionModel/acsdkInteractionModel/privateInclude/acsdkInteractionModel/InteractionModelCapabilityAgent.h
+++ b/CapabilityAgents/InteractionModel/acsdkInteractionModel/privateInclude/acsdkInteractionModel/InteractionModelCapabilityAgent.h
@@ -54,6 +54,20 @@ public:
      * @param exceptionEncounteredSender The object to use for sending AVS Exception messages.
      * @param interactionModelNotifier The object to notify of RequestProcessing events, which relays the message
      * to registered observers.
+     */
+    static std::shared_ptr<InteractionModelCapabilityAgent> createLegacy(
+        std::shared_ptr<avsCommon::sdkInterfaces::DirectiveSequencerInterface> directiveSequencer,
+        std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
+        std::shared_ptr<acsdkInteractionModelInterfaces::InteractionModelNotifierInterface> interactionModelNotifier);
+
+    /**
+     * Creates an instance of the Interaction Model capability agent.  Using the endpointCapabilitiesRegistrar to self
+     * register.
+     *
+     * @param directiveSequencer The Directive Sequencer responsible for processing AVS directives.
+     * @param exceptionEncounteredSender The object to use for sending AVS Exception messages.
+     * @param interactionModelNotifier The object to notify of RequestProcessing events, which relays the message
+     * to registered observers.
      * @param endpointCapabilitiesRegistrar The object with which to register this CA's capabilities for the default
      * endpoint.
      */
diff --git a/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/CMakeLists.txt b/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/CMakeLists.txt
index 392766b0..09739676 100644
--- a/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/CMakeLists.txt
+++ b/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/CMakeLists.txt
@@ -3,6 +3,7 @@ add_definitions("-DACSDK_LOG_MODULE=interactionModel")
 add_library(acsdkInteractionModel
         InteractionModelCapabilityAgent.cpp
         InteractionModelComponent.cpp
+        InteractionModelFactory.cpp
         InteractionModelNotifier.cpp)
 
 target_include_directories(acsdkInteractionModel PRIVATE
diff --git a/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/InteractionModelCapabilityAgent.cpp b/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/InteractionModelCapabilityAgent.cpp
index 236d9e2d..757b3576 100644
--- a/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/InteractionModelCapabilityAgent.cpp
+++ b/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/InteractionModelCapabilityAgent.cpp
@@ -14,6 +14,7 @@
  */
 #include "acsdkInteractionModel/InteractionModelCapabilityAgent.h"
 
+#include <AVSCommon/AVS/AgentId.h>
 #include <AVSCommon/AVS/NamespaceAndName.h>
 #include <AVSCommon/Utils/JSON/JSONUtils.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
@@ -50,10 +51,10 @@ static const std::string NAMESPACE = "InteractionModel";
 static const NamespaceAndName NEW_DIALOG_REQUEST{NAMESPACE, "NewDialogRequest"};
 
 /// The RequestProcessingStarted (RPS) directive signature.
-static const NamespaceAndName REQUEST_PROCESS_STARTED{NAMESPACE, "RequestProcessingStarted"};
+static const NamespaceAndName REQUEST_PROCESS_STARTED{NAMESPACE, "RequestProcessingStarted", avsCommon::avs::AgentId::AGENT_ID_ALL};
 
 /// The RequestProcessingCompleted (RPC) directive signature.
-static const NamespaceAndName REQUEST_PROCESS_COMPLETED{NAMESPACE, "RequestProcessingCompleted"};
+static const NamespaceAndName REQUEST_PROCESS_COMPLETED{NAMESPACE, "RequestProcessingCompleted", avsCommon::avs::AgentId::AGENT_ID_ALL};
 
 /// Interaction Model capability constants
 /// Interaction Model interface type
@@ -82,34 +83,46 @@ static std::shared_ptr<CapabilityConfiguration> getInteractionModelCapabilityCon
     return std::make_shared<CapabilityConfiguration>(configMap);
 }
 
-std::shared_ptr<InteractionModelCapabilityAgent> InteractionModelCapabilityAgent::create(
+std::shared_ptr<InteractionModelCapabilityAgent> InteractionModelCapabilityAgent::createLegacy(
     std::shared_ptr<DirectiveSequencerInterface> directiveSequencer,
     std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
-    std::shared_ptr<InteractionModelNotifierInterface> interactionModelNotifier,
-    acsdkManufactory::Annotated<
-        avsCommon::sdkInterfaces::endpoints::DefaultEndpointAnnotation,
-        avsCommon::sdkInterfaces::endpoints::EndpointCapabilitiesRegistrarInterface> endpointCapabilitiesRegistrar) {
+    std::shared_ptr<InteractionModelNotifierInterface> interactionModelNotifier) {
     if (!directiveSequencer) {
-        ACSDK_ERROR(LX("createFailed").d("reason", "nullDirectiveSequencer"));
+        ACSDK_ERROR(LX("createLegacyFailed").d("reason", "nullDirectiveSequencer"));
         return nullptr;
     }
     if (!exceptionEncounteredSender) {
-        ACSDK_ERROR(LX("createFailed").d("reason", "nullExceptionEncounteredSender"));
+        ACSDK_ERROR(LX("createLegacyFailed").d("reason", "nullExceptionEncounteredSender"));
         return nullptr;
     }
     if (!interactionModelNotifier) {
-        ACSDK_ERROR(LX("createFailed").d("reason", "nullInteractionModelNotifier"));
+        ACSDK_ERROR(LX("createLegacyFailed").d("reason", "nullInteractionModelNotifier"));
         return nullptr;
     }
+
+    auto interactionModelCapabilityAgent = std::shared_ptr<InteractionModelCapabilityAgent>(
+        new InteractionModelCapabilityAgent(directiveSequencer, exceptionEncounteredSender, interactionModelNotifier));
+
+    return interactionModelCapabilityAgent;
+}
+
+std::shared_ptr<InteractionModelCapabilityAgent> InteractionModelCapabilityAgent::create(
+    std::shared_ptr<DirectiveSequencerInterface> directiveSequencer,
+    std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
+    std::shared_ptr<InteractionModelNotifierInterface> interactionModelNotifier,
+    acsdkManufactory::Annotated<
+        avsCommon::sdkInterfaces::endpoints::DefaultEndpointAnnotation,
+        avsCommon::sdkInterfaces::endpoints::EndpointCapabilitiesRegistrarInterface> endpointCapabilitiesRegistrar) {
     if (!endpointCapabilitiesRegistrar) {
         ACSDK_ERROR(LX("createFailed").d("reason", "nullEndpointCapabilitiesRegistrar"));
         return nullptr;
     }
 
-    auto interactionModelCapabilityAgent = std::shared_ptr<InteractionModelCapabilityAgent>(
-        new InteractionModelCapabilityAgent(directiveSequencer, exceptionEncounteredSender, interactionModelNotifier));
-
-    endpointCapabilitiesRegistrar->withCapability(interactionModelCapabilityAgent, interactionModelCapabilityAgent);
+    auto interactionModelCapabilityAgent =
+        createLegacy(directiveSequencer, exceptionEncounteredSender, interactionModelNotifier);
+    if (interactionModelCapabilityAgent) {
+        endpointCapabilitiesRegistrar->withCapability(interactionModelCapabilityAgent, interactionModelCapabilityAgent);
+    }
 
     return interactionModelCapabilityAgent;
 }
@@ -205,13 +218,13 @@ bool InteractionModelCapabilityAgent::handleDirectiveHelper(
         }
     } else if (REQUEST_PROCESS_STARTED.name == directiveName) {
         m_interactionModelNotifier->notifyObservers(
-            [](std::shared_ptr<acsdkInteractionModelInterfaces::InteractionModelRequestProcessingObserverInterface>
-                   observer) { observer->onRequestProcessingStarted(); });
+            [info](std::shared_ptr<acsdkInteractionModelInterfaces::InteractionModelRequestProcessingObserverInterface>
+                       observer) { observer->onRequestProcessingStarted(info->directive->getAgentId()); });
         return true;
     } else if (REQUEST_PROCESS_COMPLETED.name == directiveName) {
         m_interactionModelNotifier->notifyObservers(
-            [](std::shared_ptr<acsdkInteractionModelInterfaces::InteractionModelRequestProcessingObserverInterface>
-                   observer) { observer->onRequestProcessingCompleted(); });
+            [info](std::shared_ptr<acsdkInteractionModelInterfaces::InteractionModelRequestProcessingObserverInterface>
+                       observer) { observer->onRequestProcessingCompleted(info->directive->getAgentId()); });
         return true;
     } else {
         *errMessage = directiveName + " not supported";
diff --git a/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/InteractionModelFactory.cpp b/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/InteractionModelFactory.cpp
new file mode 100644
index 00000000..a4362997
--- /dev/null
+++ b/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/InteractionModelFactory.cpp
@@ -0,0 +1,47 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include "acsdkInteractionModel/InteractionModelCapabilityAgent.h"
+#include "acsdkInteractionModel/InteractionModelFactory.h"
+#include "acsdkInteractionModel/InteractionModelNotifier.h"
+
+namespace alexaClientSDK {
+namespace acsdkInteractionModel {
+
+using namespace avsCommon::utils;
+
+Optional<InteractionModelFactoryInterfaces> createInteractionModelCA(
+    const std::shared_ptr<avsCommon::sdkInterfaces::DirectiveSequencerInterface>& directiveSequencer,
+    const std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>& exceptionEncounteredSender) {
+    auto notifier = InteractionModelNotifier::createInteractionModelNotifierInterface();
+    if (!notifier) {
+        return Optional<InteractionModelFactoryInterfaces>();
+    }
+
+    auto interactionModelCA =
+        InteractionModelCapabilityAgent::createLegacy(directiveSequencer, exceptionEncounteredSender, notifier);
+    if (!interactionModelCA) {
+        return Optional<InteractionModelFactoryInterfaces>();
+    }
+
+    InteractionModelFactoryInterfaces interfaces;
+    interfaces.notifier = notifier;
+    interfaces.capabilityConfigurationInterface = interactionModelCA;
+    interfaces.directiveHandler = interactionModelCA;
+    return Optional<InteractionModelFactoryInterfaces>(interfaces);
+}
+
+}  // namespace acsdkInteractionModel
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/CapabilityAgents/InteractionModel/acsdkInteractionModel/test/InteractionModelCapabilityAgentTest.cpp b/CapabilityAgents/InteractionModel/acsdkInteractionModel/test/InteractionModelCapabilityAgentTest.cpp
index 14e1e660..740e4d2e 100644
--- a/CapabilityAgents/InteractionModel/acsdkInteractionModel/test/InteractionModelCapabilityAgentTest.cpp
+++ b/CapabilityAgents/InteractionModel/acsdkInteractionModel/test/InteractionModelCapabilityAgentTest.cpp
@@ -175,8 +175,8 @@ class MockObserver : public InteractionModelRequestProcessingObserverInterface {
 public:
     /// @name InteractionModelRequestProcessingObserverInterface Functions
     /// @{
-    void onRequestProcessingStarted() override;
-    void onRequestProcessingCompleted() override;
+    void onRequestProcessingStarted(avsCommon::avs::AgentId::IdType agentId) override;
+    void onRequestProcessingCompleted(avsCommon::avs::AgentId::IdType agentId) override;
     /// @}
 
     /**
@@ -193,21 +193,47 @@ public:
      */
     bool waitOnRPC();
 
+    /**
+     * Returns the agent id stored by the observer from the RPS notification.
+     *
+     * @return The agent id notified to the observer.
+     */
+    avsCommon::avs::AgentId::IdType getRpsAgentId();
+
+    /**
+     * Returns the agent id stored by the observer from the RPC notification.
+     *
+     * @return The agent id notified to the observer.
+     */
+    avsCommon::avs::AgentId::IdType getRpcAgentId();
+
 protected:
     std::mutex m_mutex;
     std::condition_variable m_cond;
     bool m_rpcCalled;
     bool m_rpsCalled;
+    avsCommon::avs::AgentId::IdType m_rpsAgentId;
+    avsCommon::avs::AgentId::IdType m_rpcAgentId;
 };
 
-void MockObserver::onRequestProcessingStarted() {
+avsCommon::avs::AgentId::IdType MockObserver::getRpsAgentId() {
+    return m_rpsAgentId;
+}
+
+avsCommon::avs::AgentId::IdType MockObserver::getRpcAgentId() {
+    return m_rpcAgentId;
+}
+
+void MockObserver::onRequestProcessingStarted(avsCommon::avs::AgentId::IdType agentId) {
     std::lock_guard<std::mutex> lock(m_mutex);
+    m_rpsAgentId = agentId;
     m_rpsCalled = true;
     m_cond.notify_all();
 }
 
-void MockObserver::onRequestProcessingCompleted() {
+void MockObserver::onRequestProcessingCompleted(avsCommon::avs::AgentId::IdType agentId) {
     std::lock_guard<std::mutex> lock(m_mutex);
+    m_rpcAgentId = agentId;
     m_rpcCalled = true;
     m_cond.notify_all();
 }
@@ -395,6 +421,38 @@ TEST_F(InteractionModelCapabilityAgentTest, test_removeObserver) {
     EXPECT_FALSE(observer->waitOnRPC());
 }
 
+/**
+ * Test add an observer succeeds, receives RPS directives, RPS notifies the correct agent id.
+ */
+TEST_F(InteractionModelCapabilityAgentTest, test_processRPSAgentId) {
+    const auto someOtherAgent = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+    std::shared_ptr<MockObserver> observer = std::make_shared<MockObserver>();
+    m_interactionModelNotifier->addObserver(observer);
+
+    // Create a dummy AVSDirective.
+    auto directivePair = AVSDirective::create(someOtherAgent, RPS_DIRECTIVE_JSON_STRING, nullptr, "");
+    std::shared_ptr<AVSDirective> directive = std::move(directivePair.first);
+
+    m_interactionModelCA->handleDirectiveImmediately(directive);
+    ASSERT_EQ(observer->getRpsAgentId(), someOtherAgent);
+}
+
+/**
+ * Test add an observer succeeds, receives RPC directives, RPC notifies the correct agent id.
+ */
+TEST_F(InteractionModelCapabilityAgentTest, test_processRPCAgentId) {
+    const auto someOtherAgent = avsCommon::avs::AgentId::getAlexaAgentId() + 2;
+    std::shared_ptr<MockObserver> observer = std::make_shared<MockObserver>();
+    m_interactionModelNotifier->addObserver(observer);
+
+    // Create a dummy AVSDirective.
+    auto directivePair = AVSDirective::create(someOtherAgent, RPC_DIRECTIVE_JSON_STRING, nullptr, "");
+    std::shared_ptr<AVSDirective> directive = std::move(directivePair.first);
+
+    m_interactionModelCA->handleDirectiveImmediately(directive);
+    ASSERT_EQ(observer->getRpcAgentId(), someOtherAgent);
+}
+
 }  // namespace test
 }  // namespace acsdkInteractionModel
 }  // namespace alexaClientSDK
diff --git a/CapabilityAgents/InteractionModel/acsdkInteractionModelInterfaces/include/acsdkInteractionModelInterfaces/InteractionModelRequestProcessingObserverInterface.h b/CapabilityAgents/InteractionModel/acsdkInteractionModelInterfaces/include/acsdkInteractionModelInterfaces/InteractionModelRequestProcessingObserverInterface.h
index cfe23d8c..8d4dc0fd 100644
--- a/CapabilityAgents/InteractionModel/acsdkInteractionModelInterfaces/include/acsdkInteractionModelInterfaces/InteractionModelRequestProcessingObserverInterface.h
+++ b/CapabilityAgents/InteractionModel/acsdkInteractionModelInterfaces/include/acsdkInteractionModelInterfaces/InteractionModelRequestProcessingObserverInterface.h
@@ -16,6 +16,8 @@
 #ifndef ALEXA_CLIENT_SDK_CAPABILITYAGENTS_INTERACTIONMODEL_ACSDKINTERACTIONMODELINTERFACES_INCLUDE_ACSDKINTERACTIONMODELINTERFACES_INTERACTIONMODELREQUESTPROCESSINGOBSERVERINTERFACE_H_
 #define ALEXA_CLIENT_SDK_CAPABILITYAGENTS_INTERACTIONMODEL_ACSDKINTERACTIONMODELINTERFACES_INCLUDE_ACSDKINTERACTIONMODELINTERFACES_INTERACTIONMODELREQUESTPROCESSINGOBSERVERINTERFACE_H_
 
+#include <AVSCommon/AVS/AgentId.h>
+
 namespace alexaClientSDK {
 namespace acsdkInteractionModelInterfaces {
 
@@ -28,12 +30,12 @@ public:
     /**
      * Used to notify the observer that a Request Processing Started was received.
      */
-    virtual void onRequestProcessingStarted() = 0;
+    virtual void onRequestProcessingStarted(avsCommon::avs::AgentId::IdType agentId) = 0;
 
     /**
      * Used to notify the observer that a Request Processing Completed was received.
      */
-    virtual void onRequestProcessingCompleted() = 0;
+    virtual void onRequestProcessingCompleted(avsCommon::avs::AgentId::IdType agentId) = 0;
 };
 
 }  // namespace acsdkInteractionModelInterfaces
diff --git a/CapabilityAgents/Messaging/CMakeLists.txt b/CapabilityAgents/Messaging/CMakeLists.txt
new file mode 100644
index 00000000..3450990e
--- /dev/null
+++ b/CapabilityAgents/Messaging/CMakeLists.txt
@@ -0,0 +1,5 @@
+cmake_minimum_required(VERSION 3.0)
+project(Messaging LANGUAGES CXX)
+
+add_subdirectory("src")
+add_subdirectory("test")
diff --git a/CapabilityAgents/Messaging/include/Messaging/MessagingCapabilityAgent.h b/CapabilityAgents/Messaging/include/Messaging/MessagingCapabilityAgent.h
new file mode 100644
index 00000000..56d420a9
--- /dev/null
+++ b/CapabilityAgents/Messaging/include/Messaging/MessagingCapabilityAgent.h
@@ -0,0 +1,513 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_CAPABILITYAGENTS_MESSAGING_INCLUDE_MESSAGING_MESSAGINGCAPABILITYAGENT_H_
+#define ALEXA_CLIENT_SDK_CAPABILITYAGENTS_MESSAGING_INCLUDE_MESSAGING_MESSAGINGCAPABILITYAGENT_H_
+
+#include <memory>
+#include <unordered_set>
+#include <unordered_map>
+
+#include <AVSCommon/AVS/CapabilityAgent.h>
+#include <AVSCommon/AVS/CapabilityConfiguration.h>
+#include <AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h>
+#include <AVSCommon/SDKInterfaces/ContextManagerInterface.h>
+#include <AVSCommon/SDKInterfaces/ExceptionEncounteredSenderInterface.h>
+#include <AVSCommon/SDKInterfaces/MessageSenderInterface.h>
+#include <AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h>
+#include <AVSCommon/SDKInterfaces/StateProviderInterface.h>
+#include <AVSCommon/Utils/RequiresShutdown.h>
+#include <AVSCommon/Utils/Threading/Executor.h>
+#include <AVSCommon/Utils/UUIDGeneration/UUIDGeneration.h>
+
+namespace alexaClientSDK {
+namespace capabilityAgents {
+namespace messaging {
+
+/**
+ * This class implements the @c MessagingController capability agent.
+ *
+ * @see https://developer.amazon.com/docs/alexa-voice-service/
+ *
+ * @note For instances of this class to be cleaned up correctly, @c shutdown() must be called.
+ * @note This class makes use of a global configuration to a database file, meaning that it is best used
+ * as a singleton.
+ */
+class MessagingCapabilityAgent
+        : public avsCommon::avs::CapabilityAgent
+        , public avsCommon::sdkInterfaces::CapabilityConfigurationInterface
+        , public avsCommon::utils::RequiresShutdown
+        , public std::enable_shared_from_this<MessagingCapabilityAgent> {
+public:
+    /**
+     * Messaging endpoint reference.
+     */
+    using MessagingEndpoint = avsCommon::sdkInterfaces::messaging::MessagingObserverInterface::MessagingEndpoint;
+
+    /**
+     * An enum representing the status error codes.
+     */
+    enum class StatusErrorCode {
+        /// Generic failure occurred during request processing.
+        GENERIC_FAILURE,
+
+        /// No connection was found during request processing.
+        NO_CONNECTIVITY,
+
+        /// Messaging endpoint does not have needed permissions.
+        NO_PERMISSION
+    };
+
+    /**
+     * An enum representing the @c UploadMode.
+     */
+    enum class UploadMode {
+        /// Existing messages should be deleted and replaced with uploaded ones.
+        DELETE_ALL_AND_STORE
+    };
+
+    /**
+     * An enum representing the @c ConnectionState.
+     */
+    enum class ConnectionState {
+        /// Messaging endpoint is disconnected.
+        DISCONNECTED,
+
+        /// Messaging endpoint is connected.
+        CONNECTED
+    };
+
+    /**
+     * An enum representing the @c Permission for @sa ConversationsReport.
+     */
+    enum class PermissionState {
+        /// Permission is turned off.
+        OFF,
+
+        /// Permission is turned on.
+        ON
+    };
+
+    /*
+     *  Defines a container for the messaging endpoint state.
+     */
+    struct MessagingEndpointState {
+        /*
+         * Constructor. Initializes the configuration to default.
+         */
+        MessagingEndpointState() :
+                connection{ConnectionState::DISCONNECTED},
+                sendPermission{PermissionState::OFF},
+                readPermission{PermissionState::OFF} {};
+
+        /**
+         * Constructor for initializing with specified states.
+         * @param connectionIn The state of the connection.
+         * @param sendPermission The state of the send permission.
+         * @param readPermission The state of the read permission.
+         */
+        MessagingEndpointState(
+            ConnectionState connectionIn,
+            PermissionState sendPermissionIn,
+            PermissionState readPermissionIn) :
+                connection{connectionIn}, sendPermission{sendPermissionIn}, readPermission{readPermissionIn} {
+        }
+
+        /// Connection state
+        ConnectionState connection;
+
+        /// Send permission state.
+        PermissionState sendPermission;
+
+        /// Read permission state.
+        PermissionState readPermission;
+    };
+
+    /**
+     * Destructor.
+     */
+    virtual ~MessagingCapabilityAgent() = default;
+
+    /**
+     * Factory method to create a @c MessagingCapabilityAgent instance.
+     *
+     * @param exceptionSender Interface to report exceptions to AVS.
+     * @param contextManager Interface to provide messaging state to AVS.
+     * @param messageSender Interface to send events to AVS.
+     * @return A new instance of @c MessagingCapabilityAgent on success, @c nullptr otherwise.
+     */
+    static std::shared_ptr<MessagingCapabilityAgent> create(
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+
+    /// @name CapabilityAgent Functions
+    /// @{
+    alexaClientSDK::avsCommon::avs::DirectiveHandlerConfiguration getConfiguration() const override;
+    void handleDirectiveImmediately(std::shared_ptr<alexaClientSDK::avsCommon::avs::AVSDirective> directive) override;
+    void preHandleDirective(
+        std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    void handleDirective(std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    void cancelDirective(std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    /// @}
+
+    /// @name CapabilityConfigurationInterface method
+    /// @{
+    std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> getCapabilityConfigurations() override;
+    /// @}
+
+    /// @name RequiresShutdown method
+    /// @{
+    void doShutdown() override;
+    /// @}
+
+    /// @name StateProviderInterface Functions
+    /// @{
+    void provideState(
+        const avsCommon::avs::CapabilityTag& stateProviderName,
+        const avsCommon::sdkInterfaces::ContextRequestToken contextRequestToken) override;
+    /// @}
+
+    /**
+     * Adds an observer to @c MessagingCapabilityAgent so that it will get notified for all
+     * messaging related directives.
+     *
+     * @param observer The @c MessagingObserverInterface to add.
+     */
+    void addObserver(std::shared_ptr<avsCommon::sdkInterfaces::messaging::MessagingObserverInterface> observer);
+
+    /**
+     * Removes an observer from @c MessagingCapabilityAgent so that it will no longer be
+     * notified of messaging related directives.
+     *
+     * @param observer The @c MessagingObserverInterface
+     */
+    void removeObserver(std::shared_ptr<avsCommon::sdkInterfaces::messaging::MessagingObserverInterface> observer);
+
+    /**
+     * Sends an event to notify AVS of new messages available on the device.
+     *
+     * @note This method should be called when the device is connected.
+     * @note If this is called in response to an @c UploadConversations directive, then the token
+     * received in @c UploadConversations should be passed back. Otherwise, an empty string should be sent.
+     *
+     * @param The token received from @c uploadConversations, otherwise an empty string.
+     * @param conversations A JSON array representing the unread messages of the messaging endpoint.
+     * @code{.json}
+     * [
+     *     {
+     *         "id": "{{STRING}}",
+     *         "otherParticipants": [
+     *             {
+     *                 "address":"{{STRING}}",
+     *                 "addressType":"PhoneNumberAddress"
+     *             }
+     *         ],
+     *         "messages": [
+     *             {
+     *                 "id":"{{STRING}}",
+     *                 "payload": {
+     *                     "@type":"text",
+     *                     "text":"{{STRING}}"
+     *                 },
+     *                 "status":"unread",
+     *                 "createdTime":"{{STRING}}",
+     *                 "sender": {
+     *                     "address":"{{STRING}}",
+     *                     "addressType":"PhoneNumberAddress"
+     *                 }
+     *             }
+     *         ],
+     *         "unreadMessageCount":1
+     *     }
+     * ]
+     * @endcode
+     * @li id A unique identifier generated by the application for the conversation.
+     * @li otherParticipants Optional recipients if messages are part of a group conversation, otherwise empty JSON
+     * array.
+     * @li otherParticipants.address The phone number of the recipient.
+     * @li otherParticipants.addressType Hard coded string "PhoneNumberAddress" indicating the value of the @c address
+     * field.
+     * @li messages.id A unique identifier generated by the application for the message.
+     * @li messages.payload.@type Hard coded string "text" indicating the value of the @c text field.
+     * @li messages.text The text for the message.
+     * @li messages.createdTime (optional) The ISO 8601 timestamp of when the message was created on the device.
+     * @li messages.sender.address The phone number of the sender.
+     * @li messages.sender.addressType Hard coded string "PhoneNumberAddress" indicating the value of the @c address
+     * field.
+     * @li unreadMessageCount The total number of unread messages in this conversation..
+     */
+    void conversationsReport(
+        const std::string& token,
+        const std::string& conversations,
+        UploadMode mode = UploadMode::DELETE_ALL_AND_STORE,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * Sends an event to notify AVS that the message was sent successfully.
+     *
+     * @param token The token corresponding to the @c MessagingObserverInterface::sendMessage request.
+     * @param messagingEndpoint The messaging endpoint that sent the message successfully.
+     */
+    void sendMessageSucceeded(
+        const std::string& token,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * Sends an event to notify AVS that the message failed to be sent.
+     *
+     * @param token The token corresponding to the @c MessagingObserverInterface::sendMessage request.
+     * @param code The @c StatusErrorCode describing why the request failed.
+     * @param message The reason for the failure or empty string.
+     * @param messagingEndpoint The messaging endpoint that failed to send the message.
+     */
+    void sendMessageFailed(
+        const std::string& token,
+        StatusErrorCode code,
+        const std::string& message,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * Sends an event to notify AVS that the message status request was successful.
+     *
+     * @param token The token corresponding to the @c MessagingObserverInterface::updateMessagesStatus request.
+     * @param messagingEndpoint The messaging endpoint that update status successfully.
+     */
+    void updateMessagesStatusSucceeded(
+        const std::string& token,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * Sends an event to notify AVS that the message status request failed.
+     *
+     * @param token The token corresponding to the @c MessagingObserverInterface::sendMessage request.
+     * @param code The @c StatusErrorCode describing why the request failed.
+     * @param message The reason for the failure or empty string.
+     * @param messagingEndpoint The messaging endpoint that failed to update status.
+     */
+    void updateMessagesStatusFailed(
+        const std::string& token,
+        StatusErrorCode code,
+        const std::string& message,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * This function updates the @c MessagingCapabilityAgent context.
+     *
+     * @param messagingEndpointState The current state of the messaging endpoint.
+     * @param messagingEndpoint The messaging endpoint whose state will be updated.
+     */
+    void updateMessagingEndpointState(
+        MessagingEndpointState messagingEndpointState,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+private:
+    /**
+     * Constructor.
+     *
+     * @param exceptionSender Interface to report exceptions to AVS.
+     * @param contextManager Interface to provide state to AVS.
+     * @param messageSender Interface to send events to AVS
+     */
+    MessagingCapabilityAgent(
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+
+    /**
+     * Initializes the object.
+     */
+    bool initialize();
+
+    /**
+     * Prepares MessagingController Interface DCF configuration and keeps it internally.
+     */
+    void generateCapabilityConfiguration();
+
+    /**
+     * Builds JSON string for the device capabilities reported.
+     */
+    std::string buildMessagingEndpointConfigurationJson();
+
+    /**
+     * Remove a directive from the map of message IDs to DirectiveInfo instances.
+     *
+     * @param info The @c DirectiveInfo containing the @c AVSDirective whose message ID is to be removed.
+     */
+    void removeDirective(std::shared_ptr<DirectiveInfo> info);
+
+    /**
+     * Marks the directive as completed.
+     *
+     * @param info The directive currently being handled.
+     */
+    void executeSetHandlingCompleted(std::shared_ptr<DirectiveInfo> info);
+
+    /**
+     * Handles the @c SendMessage AVS Directive.
+     *
+     * @param info The @c DirectiveInfo containing the @c AVSDirective and the @c DirectiveHandlerResultInterface.
+     * @param payload A @c rapidjson::Document holding the parsed directive payload.
+     * @return @c true if operation succeeds and could be reported as such to AVS, @c false if an error occurred. False
+     * implies that exception has been reported to AVS and directive is already processed.
+     */
+    bool executeSendMessageDirective(std::shared_ptr<DirectiveInfo> info, rapidjson::Document& payload);
+
+    /**
+     * Handles the @c UpdateMessagesStatus AVS Directive.
+     *
+     * @param info The @c DirectiveInfo containing the @c AVSDirective and the @c DirectiveHandlerResultInterface.
+     * @param payload A @c rapidjson::Document holding the parsed directive payload.
+     * @return @c true if operation succeeds and could be reported as such to AVS, @c false if an error occurred. False
+     * implies that exception has been reported to AVS and directive is already processed.
+     */
+    bool executeUpdateMessagesStatusDirective(std::shared_ptr<DirectiveInfo> info, rapidjson::Document& payload);
+
+    /**
+     * Handles the @c UploadConversations AVS Directive.
+     *
+     * @param info The @c DirectiveInfo containing the @c AVSDirective and the @c DirectiveHandlerResultInterface.
+     * @param payload A @c rapidjson::Document holding the parsed directive payload*
+     */
+    bool executeUploadConversationsDirective(std::shared_ptr<DirectiveInfo> info, rapidjson::Document& payload);
+
+    /**
+     * This function updates the context for the @c MessagingCapabilityAgent.
+     */
+    void executeUpdateMessagingEndpointContext();
+
+    /**
+     * Gets the current state of the messaging endpoint and notifies @c ContextManager
+     *
+     * @param stateProviderName Provides the property name and used in the @c ContextManager methods.
+     * @param contextRequestToken The token to be used when providing the response to @c ContextManager
+     */
+    void executeProvideState(
+        const avsCommon::avs::CapabilityTag& stateProviderName,
+        const avsCommon::sdkInterfaces::ContextRequestToken contextRequestToken);
+
+    /// The ContextManager object.
+    std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> m_contextManager;
+
+    /// The regular MessageSender object.
+    std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> m_messageSender;
+
+    /// Set of capability configurations that will get published using DCF
+    std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> m_capabilityConfigurations;
+
+    /// Set of observers of MessagingObserverInterface.
+    std::unordered_set<std::shared_ptr<avsCommon::sdkInterfaces::messaging::MessagingObserverInterface>> m_observers;
+
+    /// Map of messaging endpoint to state
+    std::unordered_map<std::string, MessagingEndpointState> m_messagingEndpointsState;
+
+    /// The current context for the messaging capability agent
+    std::string m_messagingContext;
+
+    /// Mutex to guard access of m_observers.
+    std::mutex m_observerMutex;
+
+    /// An executor used for serializing requests.
+    avsCommon::utils::threading::Executor m_executor;
+};
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param messagingEndpoint The @c MessagingEndpoint value.
+ * @return The string form of the enum.
+ */
+inline std::string messagingEndpointToString(MessagingCapabilityAgent::MessagingEndpoint messagingEndpoint) {
+    switch (messagingEndpoint) {
+        case MessagingCapabilityAgent::MessagingEndpoint::DEFAULT:
+            return "DEFAULT";
+    }
+
+    return "UNKNOWN";
+}
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param code The @c StatusErrorCode.
+ * @return The string form of the enum.
+ */
+inline std::string statusErrorCodeToString(MessagingCapabilityAgent::StatusErrorCode code) {
+    switch (code) {
+        case MessagingCapabilityAgent::StatusErrorCode::GENERIC_FAILURE:
+            return "GENERIC_FAILURE";
+        case MessagingCapabilityAgent::StatusErrorCode::NO_CONNECTIVITY:
+            return "NO_CONNECTIVITY";
+        case MessagingCapabilityAgent::StatusErrorCode::NO_PERMISSION:
+            return "NO_PERMISSION";
+    }
+
+    return "UNKNOWN";
+}
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param code The @c UploadMode.
+ * @return The string form of the enum.
+ */
+inline std::string uploadModeToString(MessagingCapabilityAgent::UploadMode mode) {
+    switch (mode) {
+        case MessagingCapabilityAgent::UploadMode::DELETE_ALL_AND_STORE:
+            return "DELETE_ALL_AND_STORE";
+    }
+
+    return "UNKNOWN";
+}
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param code The @c ConnectionState.
+ * @return The string form of the enum.
+ */
+inline std::string connectionStateToString(MessagingCapabilityAgent::ConnectionState connection) {
+    switch (connection) {
+        case MessagingCapabilityAgent::ConnectionState::CONNECTED:
+            return "CONNECTED";
+        case MessagingCapabilityAgent::ConnectionState::DISCONNECTED:
+            return "DISCONNECTED";
+    }
+
+    return "UNKNOWN";
+}
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param code The @c PermissionState.
+ * @return The string form of the enum.
+ */
+inline std::string permissionStateToString(MessagingCapabilityAgent::PermissionState permission) {
+    switch (permission) {
+        case MessagingCapabilityAgent::PermissionState::ON:
+            return "ON";
+        case MessagingCapabilityAgent::PermissionState::OFF:
+            return "OFF";
+    }
+
+    return "UNKNOWN";
+}
+
+}  // namespace messaging
+}  // namespace capabilityAgents
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_CAPABILITYAGENTS_MESSAGING_INCLUDE_MESSAGING_MESSAGINGCAPABILITYAGENT_H_
\ No newline at end of file
diff --git a/CapabilityAgents/Messaging/src/CMakeLists.txt b/CapabilityAgents/Messaging/src/CMakeLists.txt
new file mode 100644
index 00000000..ad7b3555
--- /dev/null
+++ b/CapabilityAgents/Messaging/src/CMakeLists.txt
@@ -0,0 +1,13 @@
+add_definitions("-DACSDK_LOG_MODULE=messaging")
+
+add_library(Messaging SHARED
+        MessagingCapabilityAgent.cpp)
+
+target_include_directories(Messaging PUBLIC
+        "${Messaging_SOURCE_DIR}/include"
+        "${AVSCommon_INCLUDE_DIRS}")
+
+target_link_libraries(Messaging AVSCommon)
+
+# install target
+asdk_install()
diff --git a/CapabilityAgents/Messaging/src/MessagingCapabilityAgent.cpp b/CapabilityAgents/Messaging/src/MessagingCapabilityAgent.cpp
new file mode 100644
index 00000000..188016ba
--- /dev/null
+++ b/CapabilityAgents/Messaging/src/MessagingCapabilityAgent.cpp
@@ -0,0 +1,697 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <rapidjson/document.h>
+#include <rapidjson/error/en.h>
+#include <rapidjson/stringbuffer.h>
+#include <rapidjson/writer.h>
+
+#include <AVSCommon/AVS/CapabilityConfiguration.h>
+#include <AVSCommon/AVS/MessageRequest.h>
+#include <AVSCommon/SDKInterfaces/ContextManagerInterface.h>
+#include <AVSCommon/Utils/JSON/JSONGenerator.h>
+#include <AVSCommon/Utils/JSON/JSONUtils.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+#include "Messaging/MessagingCapabilityAgent.h"
+
+namespace alexaClientSDK {
+namespace capabilityAgents {
+namespace messaging {
+
+using namespace avsCommon::avs;
+using namespace avsCommon::sdkInterfaces;
+using namespace avsCommon::sdkInterfaces::messaging;
+using namespace avsCommon::utils::json::jsonUtils;
+using namespace avsCommon::utils::json;
+using namespace avsCommon::utils::logger;
+using namespace rapidjson;
+
+// ==== Messaging Capability Agent constants ===
+
+/// String to identify log entries originating from this file.
+static const std::string TAG{"Messaging"};
+
+/// The MessagingController interface namespace.
+static const std::string NAMESPACE{"Alexa.Comms.MessagingController"};
+
+/// MessagingController interface type.
+static const std::string MESSAGING_CAPABILITY_INTERFACE_TYPE = "AlexaInterface";
+
+/// MessagingController interface version.
+static const std::string MESSAGING_CAPABILITY_INTERFACE_VERSION = "1.0";
+
+/// The MessagingController context namespace.
+static const NamespaceAndName CONTEXT_MANAGER_MESSAGING_STATE{NAMESPACE, "MessagingControllerState"};
+
+// ==== Directives ===
+
+/// The @c SendMessage directive identifier.
+static const NamespaceAndName SEND_MESSAGE{NAMESPACE, "SendMessage"};
+
+/// The @c UpdateMessagesStatus directive identifier.
+static const NamespaceAndName UPDATE_MESSAGES_STATUS{NAMESPACE, "UpdateMessagesStatus"};
+
+/// The @c UploadConversations directive identifier.
+static const NamespaceAndName UPLOAD_CONVERSATIONS{NAMESPACE, "UploadConversations"};
+
+// ==== Events ===
+
+/// The @c SendMessageSucceeded event identifier.
+static const std::string SEND_MESSAGE_SUCCEEDED = "SendMessageSucceeded";
+
+/// The @c SendMessageFailed event identifier.
+static const std::string SEND_MESSAGE_FAILED = "SendMessageFailed";
+
+/// The @c UpdateMessagesStatusSucceeded event identifier.
+static const std::string UPDATE_MESSAGES_STATUS_SUCCEEDED = "UpdateMessagesStatusSucceeded";
+
+/// The @c UpdateMessagesStatusFailed event identifier.
+static const std::string UPDATE_MESSAGES_STATUS_FAILED = "UpdateMessagesStatusFailed";
+
+/// The @c ConversationsReport event identifier.
+static const std::string CONVERSATIONS_REPORT = "ConversationsReport";
+
+// ==== JSON constants ===
+
+/// Name for "token" JSON key.
+static constexpr char JSON_KEY_TOKEN[] = "token";
+
+/// Name for "conversationId" JSON key.
+static constexpr char JSON_KEY_CONVERSATION_ID[] = "conversationId";
+
+/// Name for "statusMap" JSON key.
+static constexpr char JSON_KEY_STATUS_MAP[] = "statusMap";
+
+/// Name for "messagingEndpoints" JSON key.
+static constexpr char JSON_KEY_MESSAGING_ENDPOINTS[] = "messagingEndpoints";
+
+/// Name for "messagingEndpointInfo" JSON key.
+static constexpr char JSON_KEY_MESSAGING_ENDPOINT_INFO[] = "messagingEndpointInfo";
+
+/// Name for "name" JSON key.
+static constexpr char JSON_KEY_MESSAGING_ENDPOINT_NAME[] = "name";
+
+/// Name for "messagingEndpointStates" JSON key.
+static constexpr char JSON_KEY_MESSAGING_ENDPOINT_STATES[] = "messagingEndpointStates";
+
+/// Name for "permissions" JSON key.
+static constexpr char JSON_KEY_MESSAGING_PERMISSIONS[] = "permissions";
+
+/// Name for "sendPermissions" JSON key.
+static constexpr char JSON_KEY_MESSAGING_SEND_PERMISSION[] = "sendPermission";
+
+/// Name for "readPermissions" JSON key.
+static constexpr char JSON_KEY_MESSAGING_READ_PERMISSION[] = "readPermission";
+
+/// Name for "connectionState" JSON key.
+static constexpr char JSON_KEY_CONNECTION_STATE[] = "connectionState";
+
+/// Name for "status" JSON value.
+static constexpr char JSON_KEY_STATUS[] = "status";
+
+/// Name for "uploadMode" JSON value.
+static constexpr char JSON_KEY_UPLOAD_MODE[] = "uploadMode";
+
+/// Name for "code" JSON key.
+static constexpr char JSON_KEY_STATUS_CODE[] = "code";
+
+/// Name for "message" JSON key.
+static constexpr char JSON_KEY_STATUS_MESSAGE[] = "message";
+
+/// Name for "conversations" JSON key.
+static constexpr char JSON_KEY_CONVERSATIONS[] = "conversations";
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+std::shared_ptr<MessagingCapabilityAgent> MessagingCapabilityAgent::create(
+    std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
+    std::shared_ptr<ContextManagerInterface> contextManager,
+    std::shared_ptr<MessageSenderInterface> messageSender) {
+    if (!contextManager) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullContextManager"));
+        return nullptr;
+    }
+
+    if (!exceptionSender) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullExceptionSender"));
+        return nullptr;
+    }
+
+    if (!messageSender) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullMessageSender"));
+        return nullptr;
+    }
+
+    // Create instance of capability agent
+    auto messagingCapabilityAgent = std::shared_ptr<MessagingCapabilityAgent>(
+        new MessagingCapabilityAgent(exceptionSender, contextManager, messageSender));
+
+    messagingCapabilityAgent->initialize();
+
+    return messagingCapabilityAgent;
+}
+
+MessagingCapabilityAgent::MessagingCapabilityAgent(
+    std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
+    std::shared_ptr<ContextManagerInterface> contextManager,
+    std::shared_ptr<MessageSenderInterface> messageSender) :
+        CapabilityAgent{NAMESPACE, exceptionSender},
+        avsCommon::utils::RequiresShutdown{"MessagingCapabilityAgent"},
+        m_contextManager{contextManager},
+        m_messageSender{messageSender} {
+}
+
+bool MessagingCapabilityAgent::initialize() {
+    ACSDK_INFO(LX(__func__));
+    // Initialize endpoint state values. One per defined messaging endpoint.
+    m_messagingEndpointsState.emplace(messagingEndpointToString(MessagingEndpoint::DEFAULT), MessagingEndpointState{});
+    // Generate the device capability configuration
+    generateCapabilityConfiguration();
+    // Register with the context manager
+    m_contextManager->addStateProvider(CONTEXT_MANAGER_MESSAGING_STATE, shared_from_this());
+    // Initialize the context
+    executeUpdateMessagingEndpointContext();
+
+    return true;
+}
+
+void MessagingCapabilityAgent::generateCapabilityConfiguration() {
+    std::unordered_map<std::string, std::string> configMap;
+
+    configMap.insert({CAPABILITY_INTERFACE_TYPE_KEY, MESSAGING_CAPABILITY_INTERFACE_TYPE});
+    configMap.insert({CAPABILITY_INTERFACE_NAME_KEY, NAMESPACE});
+    configMap.insert({CAPABILITY_INTERFACE_VERSION_KEY, MESSAGING_CAPABILITY_INTERFACE_VERSION});
+    configMap.insert({CAPABILITY_INTERFACE_CONFIGURATIONS_KEY, buildMessagingEndpointConfigurationJson()});
+
+    m_capabilityConfigurations.insert(std::make_shared<CapabilityConfiguration>(configMap));
+}
+
+std::string MessagingCapabilityAgent::buildMessagingEndpointConfigurationJson() {
+    avsCommon::utils::json::JsonGenerator jsonGenerator;
+    jsonGenerator.startArray(JSON_KEY_MESSAGING_ENDPOINTS);
+    jsonGenerator.startArrayElement();
+    jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+    jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(MessagingEndpoint::DEFAULT));
+    jsonGenerator.finishObject();
+    jsonGenerator.finishArrayElement();
+    jsonGenerator.finishArray();
+
+    ACSDK_DEBUG5(LX(__func__).sensitive("configuration", jsonGenerator.toString()));
+    return jsonGenerator.toString();
+}
+
+DirectiveHandlerConfiguration MessagingCapabilityAgent::getConfiguration() const {
+    DirectiveHandlerConfiguration configuration;
+    auto noneNonBlockingPolicy = BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false);
+
+    configuration[SEND_MESSAGE] = noneNonBlockingPolicy;
+    configuration[UPDATE_MESSAGES_STATUS] = noneNonBlockingPolicy;
+    configuration[UPLOAD_CONVERSATIONS] = noneNonBlockingPolicy;
+
+    return configuration;
+}
+
+void MessagingCapabilityAgent::provideState(
+    const CapabilityTag& stateProviderName,
+    const ContextRequestToken contextRequestToken) {
+    ACSDK_DEBUG5(
+        LX(__func__).d("contextRequestToken", contextRequestToken).sensitive("stateProviderName", stateProviderName));
+
+    m_executor.submit([this, stateProviderName, contextRequestToken] {
+        ACSDK_DEBUG5(LX("provideStateInExecutor"));
+        executeProvideState(stateProviderName, contextRequestToken);
+    });
+    return;
+}
+
+void MessagingCapabilityAgent::handleDirectiveImmediately(std::shared_ptr<AVSDirective> directive) {
+    ACSDK_DEBUG5(LX(__func__));
+    handleDirective(std::make_shared<DirectiveInfo>(directive, nullptr));
+}
+
+void MessagingCapabilityAgent::preHandleDirective(std::shared_ptr<DirectiveInfo> info) {
+    // No-op
+}
+
+/**
+ * Parses a directive payload JSON and returns a parsed document object.
+ *
+ * @param payload JSON string to parse.
+ * @param[out] document Pointer to a parsed document.
+ * @return True if parsing was successful, false otherwise.
+ */
+static bool parseDirectivePayload(const std::string& payload, Document* document) {
+    ACSDK_DEBUG5(LX(__func__));
+    if (!document) {
+        ACSDK_ERROR(LX("parseDirectivePayloadFailed").d("reason", "nullDocument"));
+        return false;
+    }
+
+    ParseResult result = document->Parse(payload);
+    if (!result) {
+        ACSDK_ERROR(LX("parseDirectivePayloadFailed")
+                        .d("reason", "parseFailed")
+                        .d("error", GetParseError_En(result.Code()))
+                        .d("offset", result.Offset()));
+        return false;
+    }
+
+    return true;
+}
+
+void MessagingCapabilityAgent::handleDirective(std::shared_ptr<DirectiveInfo> info) {
+    ACSDK_DEBUG5(LX(__func__));
+    if (!info) {
+        ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "nullDirectiveInfo"));
+        return;
+    }
+
+    m_executor.submit([this, info] {
+        const std::string directiveName = info->directive->getName();
+
+        Document payload(kObjectType);
+        if (!parseDirectivePayload(info->directive->getPayload(), &payload)) {
+            sendExceptionEncounteredAndReportFailed(
+                info, "Unable to parse payload", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+            return;
+        }
+
+        if (directiveName == SEND_MESSAGE.name) {
+            if (!executeSendMessageDirective(info, payload)) {
+                return;
+            }
+        } else if (directiveName == UPDATE_MESSAGES_STATUS.name) {
+            if (!executeUpdateMessagesStatusDirective(info, payload)) {
+                return;
+            }
+        } else if (directiveName == UPLOAD_CONVERSATIONS.name) {
+            if (!executeUploadConversationsDirective(info, payload)) {
+                return;
+            }
+        } else {
+            sendExceptionEncounteredAndReportFailed(
+                info, "Unexpected Directive", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+            return;
+        }
+
+        executeSetHandlingCompleted(info);
+    });
+}
+
+void MessagingCapabilityAgent::cancelDirective(std::shared_ptr<DirectiveInfo> info) {
+    removeDirective(info);
+}
+
+void MessagingCapabilityAgent::addObserver(std::shared_ptr<MessagingObserverInterface> observer) {
+    if (!observer) {
+        ACSDK_ERROR(LX("addObserverFailed").d("reason", "nullObserver"));
+        return;
+    }
+
+    std::lock_guard<std::mutex> lock{m_observerMutex};
+    m_observers.insert(observer);
+}
+
+void MessagingCapabilityAgent::removeObserver(std::shared_ptr<MessagingObserverInterface> observer) {
+    if (!observer) {
+        ACSDK_ERROR(LX("removeObserverFailed").d("reason", "nullObserver"));
+        return;
+    }
+
+    std::lock_guard<std::mutex> lock{m_observerMutex};
+    m_observers.erase(observer);
+}
+
+void MessagingCapabilityAgent::removeDirective(std::shared_ptr<DirectiveInfo> info) {
+    if (info->directive && info->result) {
+        CapabilityAgent::removeDirective(info->directive->getMessageId());
+    }
+}
+
+void MessagingCapabilityAgent::executeSetHandlingCompleted(std::shared_ptr<DirectiveInfo> info) {
+    ACSDK_DEBUG5(LX(__func__));
+    if (info && info->directive && info->result) {
+        info->result->setCompleted();
+    }
+    removeDirective(info);
+}
+
+bool MessagingCapabilityAgent::executeSendMessageDirective(
+    std::shared_ptr<DirectiveInfo> info,
+    rapidjson::Document& payload) {
+    rapidjson::Value::ConstMemberIterator it, it2;
+    rapidjson::Value endpointInfo;
+    std::string token, name;
+
+    // Validate token field
+    if (!findNode(payload, JSON_KEY_TOKEN, &it) || !retrieveValue(payload, JSON_KEY_TOKEN, &token) || token.empty()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'token' is not found or empty.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate messaging endpoint { "messagingEndpointInfo" : { "name" : "DEFAULT"} }
+    if (!findNode(payload, JSON_KEY_MESSAGING_ENDPOINT_INFO, &it) || !it->value.IsObject() ||
+        !findNode(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &it2) ||
+        !retrieveValue(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &name)) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'messagingEndpointInfo' is not found.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    MessagingEndpoint endpoint;
+    // Validate against known endpoint values
+    if (name == "DEFAULT") {
+        endpoint = MessagingEndpoint::DEFAULT;
+    } else {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'name' value is invalid.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    std::unique_lock<std::mutex> lock{m_observerMutex};
+    auto observers = m_observers;
+    lock.unlock();
+
+    for (auto observer : observers) {
+        if (observer) {
+            observer->sendMessage(token, endpoint, info->directive->getPayload());
+        }
+    }
+
+    return true;
+}
+
+bool MessagingCapabilityAgent::executeUpdateMessagesStatusDirective(
+    std::shared_ptr<DirectiveInfo> info,
+    rapidjson::Document& payload) {
+    rapidjson::Value::ConstMemberIterator it, it2;
+    rapidjson::Value endpointInfo;
+    std::string token, name, conversationId;
+
+    // Validate token field
+    if (!findNode(payload, JSON_KEY_TOKEN, &it) || !retrieveValue(payload, JSON_KEY_TOKEN, &token) || token.empty()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'token' is not found or empty.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate messaging endpoint { "messagingEndpointInfo" : { "name" : "DEFAULT"} }
+    if (!findNode(payload, JSON_KEY_MESSAGING_ENDPOINT_INFO, &it) || !it->value.IsObject() ||
+        !findNode(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &it2) ||
+        !retrieveValue(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &name)) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'messagingEndpointInfo' is not found.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    MessagingEndpoint endpoint;
+    // Validate against known endpoint values
+    if (name == "DEFAULT") {
+        endpoint = MessagingEndpoint::DEFAULT;
+    } else {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'name' value is invalid.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate conversationId field
+    if (!findNode(payload, JSON_KEY_CONVERSATION_ID, &it) ||
+        !retrieveValue(payload, JSON_KEY_CONVERSATION_ID, &conversationId) || conversationId.empty()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'conversationId' is not found or empty.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate statusMap field
+    if (!findNode(payload, JSON_KEY_STATUS_MAP, &it) || !it->value.IsObject()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'statusMap' is not found.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    std::unique_lock<std::mutex> lock{m_observerMutex};
+    auto observers = m_observers;
+    lock.unlock();
+
+    for (auto observer : observers) {
+        if (observer) {
+            observer->updateMessagesStatus(token, endpoint, info->directive->getPayload());
+        }
+    }
+
+    return true;
+}
+
+bool MessagingCapabilityAgent::executeUploadConversationsDirective(
+    std::shared_ptr<DirectiveInfo> info,
+    rapidjson::Document& payload) {
+    rapidjson::Value::ConstMemberIterator it, it2;
+    std::string token, name;
+
+    // Validate token field
+    if (!findNode(payload, JSON_KEY_TOKEN, &it) || !retrieveValue(payload, JSON_KEY_TOKEN, &token) || token.empty()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'token' is not found or empty.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate messaging endpoint { "messagingEndpointInfo" : { "name" : "DEFAULT"} }
+    if (!findNode(payload, JSON_KEY_MESSAGING_ENDPOINT_INFO, &it) || !it->value.IsObject() ||
+        !findNode(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &it2) ||
+        !retrieveValue(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &name)) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'messagingEndpointInfo' is not found.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    MessagingEndpoint endpoint;
+    // Validate against known endpoint values
+    if (name == "DEFAULT") {
+        endpoint = MessagingEndpoint::DEFAULT;
+    } else {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'name' value is invalid.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    std::unique_lock<std::mutex> lock{m_observerMutex};
+    auto observers = m_observers;
+    lock.unlock();
+
+    for (auto observer : observers) {
+        if (observer) {
+            observer->uploadConversations(token, endpoint, info->directive->getPayload());
+        }
+    }
+
+    return true;
+}
+
+std::unordered_set<std::shared_ptr<CapabilityConfiguration>> MessagingCapabilityAgent::getCapabilityConfigurations() {
+    return m_capabilityConfigurations;
+}
+
+void MessagingCapabilityAgent::doShutdown() {
+    m_executor.shutdown();
+    m_messageSender.reset();
+    // Remove state provider
+    m_contextManager->removeStateProvider(CONTEXT_MANAGER_MESSAGING_STATE);
+    m_contextManager.reset();
+}
+
+void MessagingCapabilityAgent::sendMessageSucceeded(const std::string& token, MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+
+        // Build event
+        auto event = buildJsonEventString(SEND_MESSAGE_SUCCEEDED, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::sendMessageFailed(
+    const std::string& token,
+    StatusErrorCode code,
+    const std::string& message,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+        jsonGenerator.startObject(JSON_KEY_STATUS);
+        jsonGenerator.addMember(JSON_KEY_STATUS_CODE, statusErrorCodeToString(code));
+        jsonGenerator.addMember(JSON_KEY_STATUS_MESSAGE, message);
+        jsonGenerator.finishObject();
+
+        // Build event
+        auto event = buildJsonEventString(SEND_MESSAGE_FAILED, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::updateMessagesStatusSucceeded(
+    const std::string& token,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+
+        // Build event
+        auto event = buildJsonEventString(UPDATE_MESSAGES_STATUS_SUCCEEDED, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::updateMessagesStatusFailed(
+    const std::string& token,
+    StatusErrorCode code,
+    const std::string& message,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+        jsonGenerator.startObject(JSON_KEY_STATUS);
+        jsonGenerator.addMember(JSON_KEY_STATUS_CODE, statusErrorCodeToString(code));
+        jsonGenerator.addMember(JSON_KEY_STATUS_MESSAGE, message);
+        jsonGenerator.finishObject();
+
+        // Build event
+        auto event = buildJsonEventString(UPDATE_MESSAGES_STATUS_FAILED, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::conversationsReport(
+    const std::string& token,
+    const std::string& conversations,
+    UploadMode mode,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+        jsonGenerator.addRawJsonMember(JSON_KEY_CONVERSATIONS, conversations);
+        jsonGenerator.addMember(JSON_KEY_UPLOAD_MODE, uploadModeToString(mode));
+
+        // Build event
+        auto event = buildJsonEventString(CONVERSATIONS_REPORT, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::updateMessagingEndpointState(
+    MessagingEndpointState messagingEndpointState,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        // Update map
+        m_messagingEndpointsState[messagingEndpointToString(messagingEndpoint)] = messagingEndpointState;
+        executeUpdateMessagingEndpointContext();
+    });
+}
+
+void MessagingCapabilityAgent::executeUpdateMessagingEndpointContext() {
+    // Update context
+    avsCommon::utils::json::JsonGenerator jsonGenerator;
+    jsonGenerator.startArray(JSON_KEY_MESSAGING_ENDPOINT_STATES);
+
+    for (auto entry : m_messagingEndpointsState) {
+        jsonGenerator.startArrayElement();
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, entry.first);
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_CONNECTION_STATE, connectionStateToString(entry.second.connection));
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_PERMISSIONS);
+        jsonGenerator.addMember(
+            JSON_KEY_MESSAGING_SEND_PERMISSION, permissionStateToString(entry.second.sendPermission));
+        jsonGenerator.addMember(
+            JSON_KEY_MESSAGING_READ_PERMISSION, permissionStateToString(entry.second.readPermission));
+        jsonGenerator.finishObject();
+        jsonGenerator.finishArrayElement();
+    }
+
+    jsonGenerator.finishArray();
+
+    // Save new context
+    m_messagingContext = jsonGenerator.toString();
+
+    ACSDK_DEBUG5(LX(__func__).sensitive("context", m_messagingContext));
+    m_contextManager->reportStateChange(
+        CONTEXT_MANAGER_MESSAGING_STATE,
+        CapabilityState{m_messagingContext},
+        AlexaStateChangeCauseType::APP_INTERACTION);
+}
+
+void MessagingCapabilityAgent::executeProvideState(
+    const CapabilityTag& stateProviderName,
+    const ContextRequestToken contextRequestToken) {
+    ACSDK_DEBUG5(LX(__func__).sensitive("context", m_messagingContext));
+    CapabilityState state{m_messagingContext};
+    m_contextManager->provideStateResponse(stateProviderName, CapabilityState{m_messagingContext}, contextRequestToken);
+}
+
+}  // namespace messaging
+}  // namespace capabilityAgents
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/CapabilityAgents/Messaging/test/CMakeLists.txt b/CapabilityAgents/Messaging/test/CMakeLists.txt
new file mode 100644
index 00000000..030a1271
--- /dev/null
+++ b/CapabilityAgents/Messaging/test/CMakeLists.txt
@@ -0,0 +1,8 @@
+cmake_minimum_required(VERSION 3.1 FATAL_ERROR)
+
+set(INCLUDE_PATH
+        "${Messaging_INCLUDE_DIRS}"
+        "${AVSCommon_SOURCE_DIR}/SDKInterfaces/test"
+        )
+
+discover_unit_tests("${INCLUDE_PATH}" "Messaging")
diff --git a/CapabilityAgents/SpeakerManager/include/SpeakerManager/SpeakerManagerConstants.h b/CapabilityAgents/SpeakerManager/include/SpeakerManager/SpeakerManagerConstants.h
index cba1e3fb..ccd2c8e8 100644
--- a/CapabilityAgents/SpeakerManager/include/SpeakerManager/SpeakerManagerConstants.h
+++ b/CapabilityAgents/SpeakerManager/include/SpeakerManager/SpeakerManagerConstants.h
@@ -20,6 +20,7 @@
 #define ALEXA_CLIENT_SDK_CAPABILITYAGENTS_SPEAKERMANAGER_INCLUDE_SPEAKERMANAGER_SPEAKERMANAGERCONSTANTS_H_
 
 #include "AVSCommon/AVS/NamespaceAndName.h"
+#include "AVSCommon/AVS/AgentId.h"
 
 namespace alexaClientSDK {
 namespace capabilityAgents {
@@ -29,16 +30,16 @@ namespace speakerManager {
 const std::string NAMESPACE = "Speaker";
 
 /// The @c SetVolume directive identifier.
-const avsCommon::avs::NamespaceAndName SET_VOLUME{NAMESPACE, "SetVolume"};
+const avsCommon::avs::NamespaceAndName SET_VOLUME{NAMESPACE, "SetVolume", avsCommon::avs::AgentId::AGENT_ID_ALL};
 
 /// The @c AdjustVolume directive identifier.
-const avsCommon::avs::NamespaceAndName ADJUST_VOLUME{NAMESPACE, "AdjustVolume"};
+const avsCommon::avs::NamespaceAndName ADJUST_VOLUME{NAMESPACE, "AdjustVolume", avsCommon::avs::AgentId::AGENT_ID_ALL};
 
 /// The @c SetMute directive directive identifier.
-const avsCommon::avs::NamespaceAndName SET_MUTE{NAMESPACE, "SetMute"};
+const avsCommon::avs::NamespaceAndName SET_MUTE{NAMESPACE, "SetMute", avsCommon::avs::AgentId::AGENT_ID_ALL};
 
 /// The @c Volume State for use with the context.
-const avsCommon::avs::NamespaceAndName VOLUME_STATE{NAMESPACE, "VolumeState"};
+const avsCommon::avs::NamespaceAndName VOLUME_STATE{NAMESPACE, "VolumeState", avsCommon::avs::AgentId::AGENT_ID_ALL};
 
 /// The @c Volume Key in AVS Directives and Events.
 const char VOLUME_KEY[] = "volume";
diff --git a/CapabilityAgents/SpeechSynthesizer/include/SpeechSynthesizer/SpeechSynthesizer.h b/CapabilityAgents/SpeechSynthesizer/include/SpeechSynthesizer/SpeechSynthesizer.h
index 8270a008..81a82394 100644
--- a/CapabilityAgents/SpeechSynthesizer/include/SpeechSynthesizer/SpeechSynthesizer.h
+++ b/CapabilityAgents/SpeechSynthesizer/include/SpeechSynthesizer/SpeechSynthesizer.h
@@ -19,9 +19,11 @@
 #include <memory>
 #include <mutex>
 #include <string>
+#include <unordered_map>
 #include <unordered_set>
 #include <deque>
 
+#include <acsdk/MultiAgentInterface/AgentManagerInterface.h>
 #include <acsdkApplicationAudioPipelineFactoryInterfaces/ApplicationAudioPipelineFactoryInterface.h>
 #include <AVSCommon/AVS/AVSDirective.h>
 #include <AVSCommon/AVS/PlayBehavior.h>
@@ -60,6 +62,7 @@ static const constexpr char* SPEAK_MEDIA_PLAYER_NAME = "SpeakMediaPlayer";
  */
 class SpeechSynthesizer
         : public avsCommon::avs::CapabilityAgent
+        , public multiAgentInterface::observer::AgentEnablementObserverInterface
         , public avsCommon::sdkInterfaces::DialogUXStateObserverInterface
         , public avsCommon::sdkInterfaces::CapabilityConfigurationInterface
         , public avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface
@@ -83,20 +86,22 @@ public:
      * when a directive cannot be processed.
      * @param captionManager The optional @c CaptionManagerInterface instance to use for handling captions.
      * @param powerResourceManager Power Resource Manager.
+     * @param agentManager The instance of the @c AgentManagerInterface to use for getting agent related information.
      *
      * @return Returns a new @c SpeechSynthesizer, or @c nullptr if the operation failed.
      */
     static std::shared_ptr<SpeechSynthesizer> createSpeechSynthesizer(
-        std::shared_ptr<acsdkApplicationAudioPipelineFactoryInterfaces::ApplicationAudioPipelineFactoryInterface>
+        const std::shared_ptr<acsdkApplicationAudioPipelineFactoryInterfaces::ApplicationAudioPipelineFactoryInterface>&
             audioPipelineFactory,
-        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
-        std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface> focusManager,
-        std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
-        std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
-        std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder,
-        std::shared_ptr<avsCommon::avs::DialogUXStateAggregator> dialogUXStateAggregator,
-        std::shared_ptr<captions::CaptionManagerInterface> captionManager = nullptr,
-        std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface> powerResourceManager = nullptr);
+        const std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface>& messageSender,
+        const std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface>& focusManager,
+        const std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface>& contextManager,
+        const std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>& exceptionSender,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
+        const std::shared_ptr<avsCommon::avs::DialogUXStateAggregator>& dialogUXStateAggregator,
+        const std::shared_ptr<captions::CaptionManagerInterface>& captionManager = nullptr,
+        const std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface>& powerResourceManager = nullptr,
+        const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager = nullptr);
 
     /**
      * Create a new @c SpeechSynthesizer instance.
@@ -111,21 +116,21 @@ public:
      * when a directive cannot be processed.
      * @param captionManager The optional @c CaptionManagerInterface instance to use for handling captions.
      * @param powerResourceManager Power Resource Manager.
+     * @param agentManager The instance of the @c AgentManagerInterface to use for getting agent related information.
      *
      * @return Returns a new @c SpeechSynthesizer, or @c nullptr if the operation failed.
      */
     static std::shared_ptr<SpeechSynthesizer> create(
-        std::shared_ptr<avsCommon::utils::mediaPlayer::MediaPlayerInterface> mediaPlayer,
-        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
-        std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface> focusManager,
-        std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
-        std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
-        std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder,
-        std::shared_ptr<avsCommon::avs::DialogUXStateAggregator> dialogUXStateAggregator,
-        std::shared_ptr<captions::CaptionManagerInterface> captionManager = nullptr,
-        std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface> powerResourceManager = nullptr);
-
-    void onDialogUXStateChanged(DialogUXState newState) override;
+        const std::shared_ptr<avsCommon::utils::mediaPlayer::MediaPlayerInterface>& mediaPlayer,
+        const std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface>& messageSender,
+        const std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface>& focusManager,
+        const std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface>& contextManager,
+        const std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>& exceptionSender,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
+        const std::shared_ptr<avsCommon::avs::DialogUXStateAggregator>& dialogUXStateAggregator,
+        const std::shared_ptr<captions::CaptionManagerInterface>& captionManager = nullptr,
+        const std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface>& powerResourceManager = nullptr,
+        const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager = nullptr);
 
     avsCommon::avs::DirectiveHandlerConfiguration getConfiguration() const override;
 
@@ -187,6 +192,17 @@ public:
     std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> getCapabilityConfigurations() override;
     /// @}
 
+    /// @name DialogUXStateObserverInterface Functions
+    /// @{
+    void onDialogUXStateChanged(avsCommon::avs::AgentId::IdType agentId, DialogUXState newState) override;
+    /// @}
+
+    /// @name AgentEnablementObserverInterface Functions
+    /// @{
+    void onEnabled(avsCommon::avs::AgentId::IdType id) override;
+    void onDisabled(avsCommon::avs::AgentId::IdType id) override;
+    /// @}
+
 private:
     /**
      * This class has all the data that is needed to process @c Speak directives.
@@ -258,16 +274,18 @@ private:
      * when a directive cannot be processed.
      * @param captionManager The optional @c CaptionManagerInterface instance to use for handling captions.
      * @param powerResourceManager Power Resource Manager.
+     * @param agentManager The instance of the @c AgentManagerInterface to use for getting agent related information.
      */
     SpeechSynthesizer(
-        std::shared_ptr<avsCommon::utils::mediaPlayer::MediaPlayerInterface> mediaPlayer,
-        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
-        std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface> focusManager,
-        std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
-        std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder,
-        std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
-        std::shared_ptr<captions::CaptionManagerInterface> captionManager = nullptr,
-        std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface> powerResourceManager = nullptr);
+        const std::shared_ptr<avsCommon::utils::mediaPlayer::MediaPlayerInterface>& mediaPlayer,
+        const std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface>& messageSender,
+        const std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface>& focusManager,
+        const std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface>& contextManager,
+        const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
+        const std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>& exceptionSender,
+        const std::shared_ptr<captions::CaptionManagerInterface>& captionManager,
+        const std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface>& powerResourceManager,
+        const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager);
 
     void doShutdown() override;
 
@@ -349,9 +367,10 @@ private:
      * Request to provide an update of the SpeechSynthesizer's state to the ContextManager (on the @c m_executor
      * thread).
      *
+     * @param agentId The @c AgentId of the context request.
      * @param stateRequestToken The token to pass through when setting the state.
      */
-    void executeProvideStateLocked(const unsigned int& stateRequestToken);
+    void executeProvideStateLocked(avsCommon::avs::AgentId::IdType agentId, const unsigned int& stateRequestToken);
 
     /**
      * Handle (on the @c m_executor thread) notification that speech playback has started.
@@ -406,18 +425,25 @@ private:
     /**
      * Builds the JSON state to be updated in the @c ContextManager.
      *
+     * @param speechSynthesizerState The state of @c SpeechSynthesizer
      * @param token The text to speech token sent in the @c Speak directive.
      * @param offsetInMilliseconds The current offset of text to speech in milliseconds.
      * @return The JSON state string.
      */
-    std::string buildState(std::string& token, int64_t offsetInMilliseconds) const;
+    std::string buildState(
+        SpeechSynthesizerObserverInterface::SpeechSynthesizerState speechSynthesizerState,
+        std::string& token,
+        int64_t offsetInMilliseconds) const;
 
     /**
      * Notify AVS of a state change.
      *
+     * @param agentId The agentId of the event of the message.
      * @param eventName The name of the event to send to AVS.
+     * @param payload The payload of the message.
      */
-    void sendEvent(const std::string& eventName, const std::string& payload) const;
+    void sendEvent(avsCommon::avs::AgentId::IdType agentId, const std::string& eventName, const std::string& payload)
+        const;
 
     /**
      * Builds a JSON payload string part of the event to be sent to AVS.
@@ -592,7 +618,7 @@ private:
      */
     avsCommon::utils::mediaPlayer::MediaPlayerInterface::SourceId m_mediaSourceId;
 
-    /// The last media player offset reportted. This is used to provide the interrupted state information.
+    /// The last media player offset reported. This is used to provide the interrupted state information.
     int64_t m_offsetInMilliseconds;
 
     /// MediaPlayerInterface instance to send audio attachments to
@@ -673,6 +699,15 @@ private:
     /// The power resource manager
     std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface> m_powerResourceManager;
 
+    /// The AgentManager
+    std::shared_ptr<multiAgentInterface::AgentManagerInterface> m_agentManager;
+
+    /// Context cache per agent
+    std::unordered_map<avsCommon::avs::AgentId::IdType, std::string> m_contextCache;
+
+    /// Enabled agents
+    std::unordered_set<avsCommon::avs::AgentId::IdType> m_enabledAgentIds;
+
     /**
      * @c Executor which queues up operations from asynchronous API calls.
      *
diff --git a/CapabilityAgents/SpeechSynthesizer/src/CMakeLists.txt b/CapabilityAgents/SpeechSynthesizer/src/CMakeLists.txt
index a4cc1d93..61f463ca 100644
--- a/CapabilityAgents/SpeechSynthesizer/src/CMakeLists.txt
+++ b/CapabilityAgents/SpeechSynthesizer/src/CMakeLists.txt
@@ -8,7 +8,7 @@ target_include_directories(SpeechSynthesizer PUBLIC
         "${Captions_INCLUDE_DIRS}"
         "${SpeechSynthesizer_SOURCE_DIR}/include")
 
-target_link_libraries(SpeechSynthesizer AVSCommon Captions acsdkApplicationAudioPipelineFactoryInterfaces)
+target_link_libraries(SpeechSynthesizer AVSCommon acsdkDUXSA MultiAgentInterface Captions acsdkApplicationAudioPipelineFactoryInterfaces)
 
 # install target
 asdk_install()
diff --git a/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp b/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
index dfb53ab5..9ac57be0 100644
--- a/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
+++ b/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
@@ -17,6 +17,7 @@
 #include <rapidjson/stringbuffer.h>
 #include <rapidjson/writer.h>
 
+#include <AVSCommon/AVS/AgentId.h>
 #include <AVSCommon/AVS/CapabilityConfiguration.h>
 #include <AVSCommon/Utils/JSON/JSONGenerator.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
@@ -174,16 +175,17 @@ static const std::string ENTRY_METRIC_NAME_STATE_CHANGE = "StateChange";
 static std::shared_ptr<avsCommon::avs::CapabilityConfiguration> getSpeechSynthesizerCapabilityConfiguration();
 
 std::shared_ptr<SpeechSynthesizer> SpeechSynthesizer::createSpeechSynthesizer(
-    std::shared_ptr<acsdkApplicationAudioPipelineFactoryInterfaces::ApplicationAudioPipelineFactoryInterface>
+    const std::shared_ptr<acsdkApplicationAudioPipelineFactoryInterfaces::ApplicationAudioPipelineFactoryInterface>&
         audioPipelineFactory,
-    std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
-    std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface> focusManager,
-    std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
-    std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
-    std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder,
-    std::shared_ptr<avsCommon::avs::DialogUXStateAggregator> dialogUXStateAggregator,
-    std::shared_ptr<captions::CaptionManagerInterface> captionManager,
-    std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface> powerResourceManager) {
+    const std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface>& messageSender,
+    const std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface>& focusManager,
+    const std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface>& contextManager,
+    const std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>& exceptionSender,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
+    const std::shared_ptr<avsCommon::avs::DialogUXStateAggregator>& dialogUXStateAggregator,
+    const std::shared_ptr<captions::CaptionManagerInterface>& captionManager,
+    const std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface>& powerResourceManager,
+    const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager) {
     if (!audioPipelineFactory) {
         ACSDK_ERROR(LX("SpeechSynthesizerCreationFailed").d("reason", "audioPipelineFactoryNullReference"));
         return nullptr;
@@ -204,19 +206,21 @@ std::shared_ptr<SpeechSynthesizer> SpeechSynthesizer::createSpeechSynthesizer(
         metricRecorder,
         dialogUXStateAggregator,
         captionManager,
-        powerResourceManager);
+        powerResourceManager,
+        agentManager);
 }
 
 std::shared_ptr<SpeechSynthesizer> SpeechSynthesizer::create(
-    std::shared_ptr<MediaPlayerInterface> mediaPlayer,
-    std::shared_ptr<MessageSenderInterface> messageSender,
-    std::shared_ptr<FocusManagerInterface> focusManager,
-    std::shared_ptr<ContextManagerInterface> contextManager,
-    std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
-    std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder,
-    std::shared_ptr<avsCommon::avs::DialogUXStateAggregator> dialogUXStateAggregator,
-    std::shared_ptr<captions::CaptionManagerInterface> captionManager,
-    std::shared_ptr<PowerResourceManagerInterface> powerResourceManager) {
+    const std::shared_ptr<MediaPlayerInterface>& mediaPlayer,
+    const std::shared_ptr<MessageSenderInterface>& messageSender,
+    const std::shared_ptr<FocusManagerInterface>& focusManager,
+    const std::shared_ptr<ContextManagerInterface>& contextManager,
+    const std::shared_ptr<ExceptionEncounteredSenderInterface>& exceptionSender,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
+    const std::shared_ptr<avsCommon::avs::DialogUXStateAggregator>& dialogUXStateAggregator,
+    const std::shared_ptr<captions::CaptionManagerInterface>& captionManager,
+    const std::shared_ptr<PowerResourceManagerInterface>& powerResourceManager,
+    const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager) {
     if (!mediaPlayer) {
         ACSDK_ERROR(LX("SpeechSynthesizerCreationFailed").d("reason", "mediaPlayerNullReference"));
         return nullptr;
@@ -245,7 +249,8 @@ std::shared_ptr<SpeechSynthesizer> SpeechSynthesizer::create(
         metricRecorder,
         exceptionSender,
         captionManager,
-        powerResourceManager));
+        powerResourceManager,
+        agentManager));
     speechSynthesizer->init();
 
     dialogUXStateAggregator->addObserver(speechSynthesizer);
@@ -255,7 +260,15 @@ std::shared_ptr<SpeechSynthesizer> SpeechSynthesizer::create(
 
 avsCommon::avs::DirectiveHandlerConfiguration SpeechSynthesizer::getConfiguration() const {
     DirectiveHandlerConfiguration configuration;
-    configuration[SPEAK] = BlockingPolicy(BlockingPolicy::MEDIUM_AUDIO, true);
+    if (!m_agentManager) {
+        configuration[SPEAK] = BlockingPolicy(BlockingPolicy::MEDIUM_AUDIO, true);
+    } else {
+        auto agents = m_agentManager->getAVSInterfaceEnabledAgentIds(SPEAK.nameSpace, SPEAK.name);
+        for (const auto& agent : agents) {
+            NamespaceAndName speakDirective{SPEAK.nameSpace, SPEAK.name, agent};
+            configuration[speakDirective] = BlockingPolicy(BlockingPolicy::MEDIUM_AUDIO, true);
+        }
+    }
     return configuration;
 }
 
@@ -377,9 +390,10 @@ void SpeechSynthesizer::provideState(
     const avsCommon::avs::NamespaceAndName& stateProviderName,
     const unsigned int stateRequestToken) {
     ACSDK_DEBUG9(LX("provideState").d("token", stateRequestToken));
-    m_executor.submit([this, stateRequestToken]() {
+    auto agentId = stateProviderName.getAgentId();
+    m_executor.submit([this, stateRequestToken, agentId]() {
         std::lock_guard<std::mutex> lock(m_mutex);
-        executeProvideStateLocked(stateRequestToken);
+        executeProvideStateLocked(agentId, stateRequestToken);
     });
 }
 
@@ -496,14 +510,15 @@ void SpeechSynthesizer::SpeakDirectiveInfo::clear() {
 }
 
 SpeechSynthesizer::SpeechSynthesizer(
-    std::shared_ptr<MediaPlayerInterface> mediaPlayer,
-    std::shared_ptr<MessageSenderInterface> messageSender,
-    std::shared_ptr<FocusManagerInterface> focusManager,
-    std::shared_ptr<ContextManagerInterface> contextManager,
-    std::shared_ptr<MetricRecorderInterface> metricRecorder,
-    std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
-    std::shared_ptr<captions::CaptionManagerInterface> captionManager,
-    std::shared_ptr<PowerResourceManagerInterface> powerResourceManager) :
+    const std::shared_ptr<MediaPlayerInterface>& mediaPlayer,
+    const std::shared_ptr<MessageSenderInterface>& messageSender,
+    const std::shared_ptr<FocusManagerInterface>& focusManager,
+    const std::shared_ptr<ContextManagerInterface>& contextManager,
+    const std::shared_ptr<MetricRecorderInterface>& metricRecorder,
+    const std::shared_ptr<ExceptionEncounteredSenderInterface>& exceptionSender,
+    const std::shared_ptr<captions::CaptionManagerInterface>& captionManager,
+    const std::shared_ptr<PowerResourceManagerInterface>& powerResourceManager,
+    const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager) :
         CapabilityAgent{NAMESPACE, exceptionSender},
         RequiresShutdown{"SpeechSynthesizer"},
         m_mediaSourceId{MediaPlayerInterface::ERROR},
@@ -519,7 +534,8 @@ SpeechSynthesizer::SpeechSynthesizer(
         m_currentFocus{FocusState::NONE},
         m_isShuttingDown{false},
         m_initialDialogUXStateReceived{false},
-        m_powerResourceManager{powerResourceManager} {
+        m_powerResourceManager{powerResourceManager},
+        m_agentManager{agentManager} {
     m_capabilityConfigurations.insert(getSpeechSynthesizerCapabilityConfiguration());
 
     if (m_powerResourceManager) {
@@ -546,11 +562,15 @@ void SpeechSynthesizer::doShutdown() {
         std::lock_guard<std::mutex> lock(m_speakInfoQueueMutex);
         m_isShuttingDown = true;
     }
-    m_contextManager->removeStateProvider(CONTEXT_MANAGER_SPEECH_STATE);
     m_executor.shutdown();  // Wait for any ongoing job and avoid new jobs being enqueued.
     m_speechPlayer->removeObserver(shared_from_this());
     {
         std::unique_lock<std::mutex> lock(m_mutex);
+        for (const auto& enabledAgentId : m_enabledAgentIds) {
+            const NamespaceAndName contextWithAgent{
+                CONTEXT_MANAGER_SPEECH_STATE.nameSpace, CONTEXT_MANAGER_SPEECH_STATE.name, enabledAgentId};
+            m_contextManager->removeStateProvider(contextWithAgent);
+        }
         if (SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING == m_currentState) {
             m_desiredState = SpeechSynthesizerObserverInterface::SpeechSynthesizerState::INTERRUPTED;
             if (m_currentInfo) {
@@ -584,7 +604,13 @@ void SpeechSynthesizer::doShutdown() {
     m_messageSender.reset();
     m_focusManager.reset();
     m_contextManager.reset();
+    m_captionManager.reset();
     m_observers.clear();
+    if (m_agentManager) {
+        m_agentManager->removeAgentEnablementObserverInterface(
+            avsCommon::avs::AgentId::AGENT_ID_ALL, shared_from_this());
+        m_agentManager.reset();
+    }
 
     if (m_powerResourceManager && m_powerResourceId) {
         m_powerResourceManager->close(m_powerResourceId);
@@ -595,7 +621,11 @@ void SpeechSynthesizer::doShutdown() {
 
 void SpeechSynthesizer::init() {
     m_speechPlayer->addObserver(shared_from_this());
-    m_contextManager->setStateProvider(CONTEXT_MANAGER_SPEECH_STATE, shared_from_this());
+    if (!m_agentManager) {
+        m_contextManager->setStateProvider(CONTEXT_MANAGER_SPEECH_STATE, shared_from_this());
+    } else {
+        m_agentManager->addAgentEnablementObserverInterface(avsCommon::avs::AgentId::AGENT_ID_ALL, shared_from_this());
+    }
 }
 
 void SpeechSynthesizer::executeHandleImmediately(std::shared_ptr<DirectiveInfo> info) {
@@ -935,26 +965,46 @@ void SpeechSynthesizer::executeStateChange(SpeechSynthesizerObserverInterface::S
     }
 }
 
-void SpeechSynthesizer::executeProvideStateLocked(const unsigned int& stateRequestToken) {
+void SpeechSynthesizer::executeProvideStateLocked(
+    avsCommon::avs::AgentId::IdType agentId,
+    const unsigned int& stateRequestToken) {
     ACSDK_DEBUG(LX("executeProvideState").d("stateRequestToken", stateRequestToken).d("state", m_currentState));
     StateRefreshPolicy refreshPolicy = StateRefreshPolicy::NEVER;
     std::string speakDirectiveToken;
-    if (m_currentInfo) {
+
+    if (m_currentInfo && (m_currentInfo->directive->getAgentId() == agentId)) {
         speakDirectiveToken = m_currentInfo->token;
-    }
 
-    if (SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING == m_currentState) {
-        m_offsetInMilliseconds =
-            std::chrono::duration_cast<std::chrono::milliseconds>(m_speechPlayer->getOffset(m_mediaSourceId)).count();
-        refreshPolicy = StateRefreshPolicy::ALWAYS;
+        if (SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING == m_currentState) {
+            m_offsetInMilliseconds =
+                std::chrono::duration_cast<std::chrono::milliseconds>(m_speechPlayer->getOffset(m_mediaSourceId))
+                    .count();
+            refreshPolicy = StateRefreshPolicy::ALWAYS;
+        }
+        auto jsonState = buildState(m_currentState, speakDirectiveToken, m_offsetInMilliseconds);
+        if (jsonState.empty()) {
+            ACSDK_ERROR(
+                LX("executeProvideStateFailed").d("reason", "buildStateFailed").d("token", speakDirectiveToken));
+            return;
+        }
+        m_contextCache[agentId] = jsonState;
+    } else {
+        if (0 == m_contextCache.count(agentId)) {
+            auto jsonState = buildState(
+                SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED, speakDirectiveToken, 0);
+            if (jsonState.empty()) {
+                ACSDK_ERROR(
+                    LX("executeProvideStateFailed").d("reason", "buildStateFailed").d("token", speakDirectiveToken));
+                return;
+            }
+            m_contextCache[agentId] = jsonState;
+        }
     }
 
-    auto jsonState = buildState(speakDirectiveToken, m_offsetInMilliseconds);
-    if (jsonState.empty()) {
-        ACSDK_ERROR(LX("executeProvideStateFailed").d("reason", "buildStateFailed").d("token", speakDirectiveToken));
-        return;
-    }
-    auto result = m_contextManager->setState(CONTEXT_MANAGER_SPEECH_STATE, jsonState, refreshPolicy, stateRequestToken);
+    const NamespaceAndName speechContextForAgent{
+        CONTEXT_MANAGER_SPEECH_STATE.nameSpace, CONTEXT_MANAGER_SPEECH_STATE.name, agentId};
+    auto result =
+        m_contextManager->setState(speechContextForAgent, m_contextCache[agentId], refreshPolicy, stateRequestToken);
     if (result != SetStateResult::SUCCESS) {
         ACSDK_ERROR(LX("executeProvideStateFailed")
                         .d("reason", "contextManagerSetStateFailed")
@@ -975,7 +1025,8 @@ void SpeechSynthesizer::executePlaybackStarted() {
     setDesiredState(SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED);
     m_waitOnStateChange.notify_one();
     if (m_currentInfo->sendPlaybackStartedMessage) {
-        sendEvent(SPEECH_STARTED_EVENT_NAME, buildPayload(m_currentInfo->token));
+        sendEvent(
+            m_currentInfo->directive->getAgentId(), SPEECH_STARTED_EVENT_NAME, buildPayload(m_currentInfo->token));
     }
 }
 
@@ -1005,7 +1056,7 @@ void SpeechSynthesizer::executePlaybackFinished() {
     ACSDK_DEBUG3(LX(__func__).d("reason", eventName));
     m_waitOnStateChange.notify_one();
     if (m_currentInfo->sendPlaybackFinishedMessage) {
-        sendEvent(eventName, payload);
+        sendEvent(m_currentInfo->directive->getAgentId(), eventName, payload);
     }
     if (m_currentInfo->sendCompletedMessage) {
         setHandlingCompleted();
@@ -1090,13 +1141,16 @@ void SpeechSynthesizer::executePlaybackError(const avsCommon::utils::mediaPlayer
     resetMediaSourceId();
 }
 
-std::string SpeechSynthesizer::buildState(std::string& token, int64_t offsetInMilliseconds) const {
+std::string SpeechSynthesizer::buildState(
+    SpeechSynthesizerObserverInterface::SpeechSynthesizerState speechSynthesizerState,
+    std::string& token,
+    int64_t offsetInMilliseconds) const {
     Document state(kObjectType);
     Document::AllocatorType& alloc = state.GetAllocator();
     state.AddMember(KEY_TOKEN, token, alloc);
     state.AddMember(KEY_OFFSET_IN_MILLISECONDS, offsetInMilliseconds, alloc);
 
-    switch (m_currentState) {
+    switch (speechSynthesizerState) {
         case SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING:
             state.AddMember(KEY_PLAYER_ACTIVITY, PLAYER_STATE_PLAYING, alloc);
             break;
@@ -1184,11 +1238,13 @@ void SpeechSynthesizer::setCurrentStateLocked(SpeechSynthesizerObserverInterface
 
     m_currentState = newState;
     managePowerResource(m_currentState);
+    const auto agentId =
+        m_currentInfo ? m_currentInfo->directive->getAgentId() : avsCommon::avs::AgentId::getAlexaAgentId();
     switch (newState) {
         case SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING:
         case SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED:
         case SpeechSynthesizerObserverInterface::SpeechSynthesizerState::INTERRUPTED:
-            executeProvideStateLocked(0);
+            executeProvideStateLocked(agentId, 0);
             break;
         case SpeechSynthesizerObserverInterface::SpeechSynthesizerState::LOSING_FOCUS:
         case SpeechSynthesizerObserverInterface::SpeechSynthesizerState::GAINING_FOCUS:
@@ -1201,8 +1257,8 @@ void SpeechSynthesizer::setCurrentStateLocked(SpeechSynthesizerObserverInterface
     }
 
     for (auto observer : m_observers) {
-        observer->onStateChanged(
-            m_currentState, m_mediaSourceId, m_speechPlayer->getMediaPlayerState(m_mediaSourceId), analyzersData);
+        auto mediaPlayerState = m_speechPlayer->getMediaPlayerState(m_mediaSourceId);
+        observer->onStateChanged(m_currentState, {m_mediaSourceId, mediaPlayerState, analyzersData, agentId});
     }
 }
 
@@ -1230,14 +1286,17 @@ void SpeechSynthesizer::setHandlingCompleted() {
     }
 }
 
-void SpeechSynthesizer::sendEvent(const std::string& eventName, const std::string& payload) const {
+void SpeechSynthesizer::sendEvent(
+    avsCommon::avs::AgentId::IdType agentId,
+    const std::string& eventName,
+    const std::string& payload) const {
     if (payload.empty()) {
         ACSDK_ERROR(LX("sendEventFailed").d("event", eventName).d("token", m_currentInfo->token));
         return;
     }
     auto msgIdAndJsonEvent = buildJsonEventString(eventName, "", payload);
 
-    auto request = std::make_shared<MessageRequest>(msgIdAndJsonEvent.second);
+    auto request = std::make_shared<MessageRequest>(agentId, msgIdAndJsonEvent.second);
     m_messageSender->sendMessage(request);
 }
 
@@ -1248,7 +1307,7 @@ void SpeechSynthesizer::sendExceptionEncounteredAndReportFailed(
     if (speakInfo) {
         if (speakInfo->directive) {
             m_exceptionEncounteredSender->sendExceptionEncountered(
-                speakInfo->directive->getUnparsedDirective(), type, message);
+                speakInfo->directive->getAgentId(), speakInfo->directive->getUnparsedDirective(), type, message);
             removeDirective(speakInfo->directive->getMessageId());
         } else {
             ACSDK_ERROR(LX("sendExceptionEncounteredAndReportFailed").d("reason", "speakInfoHasNoDirective"));
@@ -1398,7 +1457,9 @@ void SpeechSynthesizer::resetMediaSourceId() {
     m_mediaSourceId = MediaPlayerInterface::ERROR;
 }
 
-void SpeechSynthesizer::onDialogUXStateChanged(DialogUXStateObserverInterface::DialogUXState newState) {
+void SpeechSynthesizer::onDialogUXStateChanged(
+    avsCommon::avs::AgentId::IdType agentId,
+    DialogUXStateObserverInterface::DialogUXState newState) {
     m_executor.submit([this, newState]() { executeOnDialogUXStateChanged(newState); });
 }
 
@@ -1424,13 +1485,52 @@ std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> Spe
     return m_capabilityConfigurations;
 }
 
+void SpeechSynthesizer::onEnabled(avsCommon::avs::AgentId::IdType id) {
+    if (m_agentManager) {
+        auto supportedAgentIds = m_agentManager->getAVSInterfaceEnabledAgentIds(CONTEXT_MANAGER_SPEECH_STATE.nameSpace);
+        if (0 != supportedAgentIds.count(id)) {
+            std::unique_lock<std::mutex> lock(m_mutex);
+            if (0 == m_enabledAgentIds.count(id)) {
+                m_enabledAgentIds.insert(id);
+                lock.unlock();
+                m_contextManager->setStateProvider(
+                    NamespaceAndName{CONTEXT_MANAGER_SPEECH_STATE.nameSpace, CONTEXT_MANAGER_SPEECH_STATE.name, id},
+                    shared_from_this());
+            }
+        }
+    }
+}
+
+void SpeechSynthesizer::onDisabled(avsCommon::avs::AgentId::IdType id) {
+    if (m_agentManager) {
+        auto supportedAgentIds = m_agentManager->getAVSInterfaceEnabledAgentIds(CONTEXT_MANAGER_SPEECH_STATE.nameSpace);
+        if (0 != supportedAgentIds.count(id)) {
+            std::unique_lock<std::mutex> lock(m_mutex);
+            if (m_enabledAgentIds.count(id)) {
+                m_enabledAgentIds.erase(id);
+                lock.unlock();
+                m_contextManager->removeStateProvider(
+                    NamespaceAndName{CONTEXT_MANAGER_SPEECH_STATE.nameSpace, CONTEXT_MANAGER_SPEECH_STATE.name, id});
+            }
+        }
+    }
+
+    m_executor.submit([this, id]() {
+        if ((m_currentState != SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED) && m_currentInfo &&
+            (m_currentInfo->directive->getAgentId() == id)) {
+            executeCancel(m_currentInfo, true);
+        }
+        m_contextCache.erase(id);
+    });
+}
+
 void SpeechSynthesizer::submitMetric(MetricEventBuilder& metricEventBuilder) {
     if (!m_metricRecorder) {
         return;
     }
 
     if (m_currentInfo) {
-        auto metricEvent = metricEventBuilder
+        auto metricEvent = metricEventBuilder.setMetricContext(MetricContext{m_currentInfo->directive->getAgentId()})
                                .addDataPoint(DataPointStringBuilder{}
                                                  .setName("HTTP2_STREAM")
                                                  .setValue(m_currentInfo->directive->getAttachmentContextId())
@@ -1473,6 +1573,7 @@ void SpeechSynthesizer::submitInstanceEntryMetric(
         metricBuilder.addDataPoint(DataPointStringBuilder{}.setName(pair.first).setValue(pair.second).build());
     }
     if (m_currentInfo) {
+        metricBuilder.setMetricContext(MetricContext{m_currentInfo->directive->getAgentId()});
         metricBuilder.addDataPoint(DataPointStringBuilder{}
                                        .setName("DIRECTIVE_MESSAGE_ID")
                                        .setValue(m_currentInfo->directive->getMessageId())
diff --git a/CapabilityAgents/SpeechSynthesizer/test/CMakeLists.txt b/CapabilityAgents/SpeechSynthesizer/test/CMakeLists.txt
index 6a3a6237..9cfc8788 100644
--- a/CapabilityAgents/SpeechSynthesizer/test/CMakeLists.txt
+++ b/CapabilityAgents/SpeechSynthesizer/test/CMakeLists.txt
@@ -7,4 +7,4 @@ set(INCLUDE_PATH
 
 discover_unit_tests(
     "${INCLUDE_PATH}"
-    "SpeechSynthesizer;CaptionsTestLib;UtilsCommonTestLib;SDKInterfacesTests;ApplicationAudioPipelineFactoryTestLib")
\ No newline at end of file
+    "SpeechSynthesizer;MultiAgentInterfaceTestUtils;acsdkDUXSA;CaptionsTestLib;UtilsCommonTestLib;SDKInterfacesTests;ApplicationAudioPipelineFactoryTestLib")
diff --git a/CapabilityAgents/SpeechSynthesizer/test/SpeechSynthesizerTest.cpp b/CapabilityAgents/SpeechSynthesizer/test/SpeechSynthesizerTest.cpp
index 0234a6f2..e2ed033a 100644
--- a/CapabilityAgents/SpeechSynthesizer/test/SpeechSynthesizerTest.cpp
+++ b/CapabilityAgents/SpeechSynthesizer/test/SpeechSynthesizerTest.cpp
@@ -20,6 +20,7 @@
 #include <gmock/gmock.h>
 #include <gtest/gtest.h>
 
+#include <acsdk/MultiAgentInterface/MockAgentManager.h>
 #include <acsdkApplicationAudioPipelineFactoryInterfaces/MockApplicationAudioPipelineFactory.h>
 #include <AVSCommon/SDKInterfaces/MockExceptionEncounteredSender.h>
 #include <AVSCommon/AVS/Attachment/AttachmentManagerInterface.h>
@@ -42,6 +43,7 @@ namespace capabilityAgents {
 namespace speechSynthesizer {
 namespace test {
 
+using namespace multiAgentInterface;
 using namespace avsCommon::utils;
 using namespace avsCommon;
 using namespace avsCommon::avs;
@@ -229,6 +231,9 @@ static const unsigned int PROVIDE_STATE_TOKEN_TEST{1};
 /// Component name for power resource management.
 static const std::string COMPONENT_NAME("SpeechSynthesizer");
 
+/// Some other agent for testing
+static avsCommon::avs::AgentId::IdType SOME_OTHER_AGENT{12345};
+
 /**
  * Store useful information about a mock Speak Directive.
  */
@@ -269,13 +274,11 @@ static std::string generateInterruptedState(const SpeakTestInfo& info) {
 
 class MockSpeechSynthesizerObserver : public SpeechSynthesizerObserverInterface {
 public:
-    MOCK_METHOD4(
+    MOCK_METHOD2(
         onStateChanged,
         void(
             SpeechSynthesizerObserverInterface::SpeechSynthesizerState state,
-            const mediaPlayer::MediaPlayerInterface::SourceId mediaSourceId,
-            const Optional<mediaPlayer::MediaPlayerState>& mediaPlayerState,
-            const std::vector<audioAnalyzer::AudioAnalyzerState>& audioAnalyzerState));
+            const SpeechSynthesizerObserverInterface::Context& context));
 };
 
 class SpeechSynthesizerTest : public ::testing::Test {
@@ -411,23 +414,34 @@ public:
     std::shared_ptr<acsdkApplicationAudioPipelineFactoryInterfaces::test::MockApplicationAudioPipelineFactory>
         m_mockAudioPipelineFactory;
 
+    /// The mock @c AgentManager
+    std::shared_ptr<MockAgentManager> m_mockAgentManager;
+
     /**
      * Setup speech synthesizer to have a pending speech directive.
      *
      * @param resultHandler the result handler for the new speech directive.
      * @param info Information used to generate the new speech directive.
+     * @param agentId the avsCommon::avs::AgentId::IdType used to generate the new speech directive.
      * @return @c true if it succeed; @c false otherwise.
      */
-    bool setupPendingSpeech(std::unique_ptr<DirectiveHandlerResultInterface> resultHandler, const SpeakTestInfo& info);
+    bool setupPendingSpeech(
+        std::unique_ptr<DirectiveHandlerResultInterface> resultHandler,
+        const SpeakTestInfo& info,
+        avsCommon::avs::AgentId::IdType agentId = avsCommon::avs::AgentId::getAlexaAgentId());
 
     /**
      * Setup speech synthesizer to have an active speech directive.
      *
      * @param resultHandler the result handler for the new speech directive.
      * @param info Information used to generate and activate the new speech directive.
+     * @param agentId the AgentId used to generate the new speech directive.
      * @return @c true if it succeed; @c false otherwise.
      */
-    bool setupActiveSpeech(std::unique_ptr<DirectiveHandlerResultInterface> resultHandler, const SpeakTestInfo& info);
+    bool setupActiveSpeech(
+        std::unique_ptr<DirectiveHandlerResultInterface> resultHandler,
+        const SpeakTestInfo& info,
+        avsCommon::avs::AgentId::IdType agentId = avsCommon::avs::AgentId::getAlexaAgentId());
 };
 
 SpeechSynthesizerTest::SpeechSynthesizerTest() :
@@ -461,6 +475,7 @@ void SpeechSynthesizerTest::SetUp() {
     m_mockSpeechSynthesizerObserver = std::make_shared<MockSpeechSynthesizerObserver>();
     m_mockAudioPipelineFactory =
         std::make_shared<acsdkApplicationAudioPipelineFactoryInterfaces::test::MockApplicationAudioPipelineFactory>();
+    m_mockAgentManager = std::make_shared<NiceMock<MockAgentManager>>();
 
     EXPECT_CALL(
         *m_mockPowerResourceManager,
@@ -474,6 +489,19 @@ void SpeechSynthesizerTest::SetUp() {
                 resourceId);
         }));
 
+    EXPECT_CALL(*m_mockAgentManager, getAVSInterfaceEnabledAgentIds(NAMESPACE_AND_NAME_SPEECH_STATE.nameSpace, _, _))
+        .Times(AtLeast(1))
+        .WillRepeatedly(Return(
+            std::set<avsCommon::avs::AgentId::IdType>{avsCommon::avs::AgentId::getAlexaAgentId(), SOME_OTHER_AGENT}));
+
+    EXPECT_CALL(*m_mockAgentManager, addAgentEnablementObserverInterface(AgentId::AGENT_ID_ALL, _))
+        .WillOnce(Invoke([](avsCommon::avs::AgentId::IdType id,
+                            std::shared_ptr<observer::AgentEnablementObserverInterface> observer) {
+            if (observer) {
+                observer->onEnabled(avsCommon::avs::AgentId::getAlexaAgentId());
+            }
+        }));
+
     bool equalizerAvailable = false;
     bool enableLiveMode = false;
     bool isCaptionable = true;
@@ -484,6 +512,8 @@ void SpeechSynthesizerTest::SetUp() {
         .WillOnce(Return(std::make_shared<avsCommon::sdkInterfaces::ApplicationMediaInterfaces>(
             m_mockSpeechPlayer, nullptr, nullptr, nullptr)));
 
+    EXPECT_CALL(*m_mockContextManager, setStateProvider(NAMESPACE_AND_NAME_SPEECH_STATE, _)).Times(AtLeast(1));
+
     m_speechSynthesizer = SpeechSynthesizer::createSpeechSynthesizer(
         m_mockAudioPipelineFactory,
         m_mockMessageSender,
@@ -493,12 +523,22 @@ void SpeechSynthesizerTest::SetUp() {
         m_metricRecorder,
         m_dialogUXStateAggregator,
         m_mockCaptionManager,
-        m_mockPowerResourceManager);
+        m_mockPowerResourceManager,
+        m_mockAgentManager);
     m_mockDirHandlerResult.reset(new MockDirectiveHandlerResult);
 
     ASSERT_TRUE(m_speechSynthesizer);
 
     m_speechSynthesizer->addObserver(m_dialogUXStateAggregator);
+
+    auto configuration = m_speechSynthesizer->getConfiguration();
+    EXPECT_NE(
+        configuration.find(
+            NamespaceAndName{NAMESPACE_SPEECH_SYNTHESIZER, NAME_SPEAK, avsCommon::avs::AgentId::getAlexaAgentId()}),
+        configuration.end());
+    EXPECT_NE(
+        configuration.find(NamespaceAndName{NAMESPACE_SPEECH_SYNTHESIZER, NAME_SPEAK, SOME_OTHER_AGENT}),
+        configuration.end());
 }
 
 void SpeechSynthesizerTest::TearDown() {
@@ -547,8 +587,12 @@ void SpeechSynthesizerTest::wakeOnStopped() {
  * @param expectedContent The content that should be included in the request.
  * @return If the content was found or not.
  */
-static bool matchEvent(std::shared_ptr<MessageRequest> request, const std::string& expectedContent) {
-    return request && (request->getJsonContent().find(expectedContent) != std::string::npos);
+static bool matchEvent(
+    std::shared_ptr<MessageRequest> request,
+    const std::string& expectedContent,
+    avsCommon::avs::AgentId::IdType agentId = avsCommon::avs::AgentId::getAlexaAgentId()) {
+    return request && request->getAgentId() == agentId &&
+           (request->getJsonContent().find(expectedContent) != std::string::npos);
 }
 
 MATCHER(IsStartedEvent, "") {
@@ -561,6 +605,24 @@ MATCHER(IsInterruptedEvent, "") {
     return matchEvent(arg, SPEECH_INTERRUPTED_EVENT_NAME);
 }
 
+MATCHER_P(IsStartedEvent, agentId, "") {
+    return matchEvent(arg, SPEECH_STARTED_EVENT_NAME, agentId);
+}
+MATCHER_P(IsFinishedEvent, agentId, "") {
+    return matchEvent(arg, SPEECH_FINISHED_EVENT_NAME, agentId);
+}
+MATCHER_P(IsInterruptedEvent, agentId, "") {
+    return matchEvent(arg, SPEECH_INTERRUPTED_EVENT_NAME, agentId);
+}
+
+MATCHER_P(ObserverStateEq, agentId, "") {
+    return arg.agentId == agentId;
+}
+
+MATCHER_P(ObserverStateAnalyzerEq, analyzer, "") {
+    return arg.audioAnalyzerState == analyzer;
+}
+
 /**
  * Test creating SpeechSynthesizer fails with null audio pipeline factory.
  */
@@ -619,11 +681,12 @@ TEST_F(SpeechSynthesizerTest, test_callingHandleImmediately) {
     std::vector<audioAnalyzer::AudioAnalyzerState> data;
     EXPECT_CALL(
         *m_mockSpeechSynthesizerObserver,
-        onStateChanged(SpeechSynthesizerObserverInterface::SpeechSynthesizerState::GAINING_FOCUS, _, _, _))
+        onStateChanged(SpeechSynthesizerObserverInterface::SpeechSynthesizerState::GAINING_FOCUS, _))
         .Times(1);
     EXPECT_CALL(
         *m_mockSpeechSynthesizerObserver,
-        onStateChanged(SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING, _, _, Eq(data)))
+        onStateChanged(
+            SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING, ObserverStateAnalyzerEq(data)))
         .Times(1);
 
     m_speechSynthesizer->addObserver(m_mockSpeechSynthesizerObserver);
@@ -1283,7 +1346,7 @@ TEST_F(SpeechSynthesizerTest, testSlow_setStateTimeout) {
     EXPECT_CALL(*(m_mockSpeechPlayer.get()), getOffset(_))
         .Times(AtLeast(1))
         .WillRepeatedly(Return(OFFSET_IN_CHRONO_MILLISECONDS_TEST));
-    EXPECT_CALL(*(m_mockExceptionSender.get()), sendExceptionEncountered(_, _, _)).Times(1);
+    EXPECT_CALL(*(m_mockExceptionSender.get()), sendExceptionEncountered(_, _, _, _)).Times(1);
     EXPECT_CALL(
         *(m_mockContextManager.get()),
         setState(NAMESPACE_AND_NAME_SPEECH_STATE, PLAYING_STATE_TEST, StateRefreshPolicy::ALWAYS, 0))
@@ -1404,11 +1467,14 @@ TEST_F(SpeechSynthesizerTest, testTimer_onPlayedStopped) {
 
 bool SpeechSynthesizerTest::setupActiveSpeech(
     std::unique_ptr<DirectiveHandlerResultInterface> resultHandler,
-    const SpeakTestInfo& info) {
+    const SpeakTestInfo& info,
+    avsCommon::avs::AgentId::IdType agentId) {
+    const NamespaceAndName SpeechContextWithAgentId{
+        NAMESPACE_AND_NAME_SPEECH_STATE.nameSpace, NAMESPACE_AND_NAME_SPEECH_STATE.name, agentId};
     auto avsMessageHeader = std::make_shared<AVSMessageHeader>(
         NAMESPACE_SPEECH_SYNTHESIZER, NAME_SPEAK, info.messageId, DIALOG_REQUEST_ID_TEST);
     std::shared_ptr<AVSDirective> directive =
-        AVSDirective::create("", avsMessageHeader, info.payload, m_attachmentManager, CONTEXT_ID_TEST);
+        AVSDirective::create(agentId, "", avsMessageHeader, info.payload, m_attachmentManager, CONTEXT_ID_TEST);
 
     EXPECT_CALL(*m_mockFocusManager, acquireChannel(CHANNEL_NAME, _))
         .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnAcquireChannel));
@@ -1419,9 +1485,9 @@ bool SpeechSynthesizerTest::setupActiveSpeech(
     EXPECT_CALL(*m_mockSpeechPlayer, getOffset(_)).WillRepeatedly(Return(OFFSET_IN_CHRONO_MILLISECONDS_TEST));
     EXPECT_CALL(
         *m_mockContextManager,
-        setState(NAMESPACE_AND_NAME_SPEECH_STATE, generatePlayingState(info), StateRefreshPolicy::ALWAYS, 0))
+        setState(SpeechContextWithAgentId, generatePlayingState(info), StateRefreshPolicy::ALWAYS, 0))
         .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetState));
-    EXPECT_CALL(*m_mockMessageSender, sendMessage(IsStartedEvent()))
+    EXPECT_CALL(*m_mockMessageSender, sendMessage(IsStartedEvent(agentId)))
         .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSendMessage));
     EXPECT_CALL(*m_mockPowerResourceManager, acquire(_, _)).Times(AtLeast(1));
     EXPECT_CALL(*m_mockPowerResourceManager, release(_)).Times(AtLeast(1));
@@ -1447,11 +1513,12 @@ bool SpeechSynthesizerTest::setupActiveSpeech(
 
 bool SpeechSynthesizerTest::setupPendingSpeech(
     std::unique_ptr<DirectiveHandlerResultInterface> resultHandler,
-    const SpeakTestInfo& info) {
+    const SpeakTestInfo& info,
+    avsCommon::avs::AgentId::IdType agentId) {
     auto avsMessageHeader = std::make_shared<AVSMessageHeader>(
         NAMESPACE_SPEECH_SYNTHESIZER, NAME_SPEAK, info.messageId, DIALOG_REQUEST_ID_TEST);
     std::shared_ptr<AVSDirective> directive =
-        AVSDirective::create("", avsMessageHeader, info.payload, m_attachmentManager, CONTEXT_ID_TEST);
+        AVSDirective::create(agentId, "", avsMessageHeader, info.payload, m_attachmentManager, CONTEXT_ID_TEST);
     EXPECT_CALL(*m_mockFocusManager, acquireChannel(CHANNEL_NAME, _))
         .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnAcquireChannel));
     EXPECT_CALL(*m_mockPowerResourceManager, acquire(_, _)).Times(AtLeast(1));
@@ -1846,6 +1913,199 @@ TEST_F(SpeechSynthesizerTest, test_replaceEnqueuedWithAnotherEnqueuedItem) {
     }
 }
 
+/**
+ * Test SpeechSynthesizer is able to send event and report context to the correct agent.
+ */
+TEST_F(SpeechSynthesizerTest, test_sendingEventsAndContextForAnotherAgent) {
+    // Make sure onStateChanged is called correctly.
+    EXPECT_CALL(
+        *m_mockSpeechSynthesizerObserver,
+        onStateChanged(
+            SpeechSynthesizerObserverInterface::SpeechSynthesizerState::GAINING_FOCUS,
+            ObserverStateEq(SOME_OTHER_AGENT)))
+        .Times(2);
+    EXPECT_CALL(
+        *m_mockSpeechSynthesizerObserver,
+        onStateChanged(
+            SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING, ObserverStateEq(SOME_OTHER_AGENT)))
+        .Times(2);
+    EXPECT_CALL(
+        *m_mockSpeechSynthesizerObserver,
+        onStateChanged(
+            SpeechSynthesizerObserverInterface::SpeechSynthesizerState::INTERRUPTED, ObserverStateEq(SOME_OTHER_AGENT)))
+        .Times(1);
+    EXPECT_CALL(
+        *m_mockSpeechSynthesizerObserver,
+        onStateChanged(
+            SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED, ObserverStateEq(SOME_OTHER_AGENT)))
+        .Times(1);
+
+    m_speechSynthesizer->addObserver(m_mockSpeechSynthesizerObserver);
+    const NamespaceAndName ANOTHER_AGENT_CONTEXT{
+        NAMESPACE_AND_NAME_SPEECH_STATE.nameSpace, NAMESPACE_AND_NAME_SPEECH_STATE.name, SOME_OTHER_AGENT};
+    auto active = generateSpeakInfo(PlayBehavior::ENQUEUE);
+    auto mockEnqueuedResultHandler = std::unique_ptr<MockDirectiveHandlerResult>(new MockDirectiveHandlerResult());
+    ASSERT_TRUE(setupActiveSpeech(std::move(mockEnqueuedResultHandler), active, SOME_OTHER_AGENT));
+
+    auto mockResultHandler = std::unique_ptr<MockDirectiveHandlerResult>(new MockDirectiveHandlerResult());
+    EXPECT_CALL(*mockResultHandler, setCompleted())
+        .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetCompleted));
+    auto speak = generateSpeakInfo(PlayBehavior::REPLACE_ALL);
+    auto avsMessageHeader = std::make_shared<AVSMessageHeader>(
+        NAMESPACE_SPEECH_SYNTHESIZER, NAME_SPEAK, speak.messageId, DIALOG_REQUEST_ID_TEST);
+    std::shared_ptr<AVSDirective> directive = AVSDirective::create(
+        SOME_OTHER_AGENT, "", avsMessageHeader, speak.payload, m_attachmentManager, CONTEXT_ID_TEST);
+
+    {
+        // Interrupted event.
+        EXPECT_CALL(*m_mockSpeechPlayer, stop(_));
+        EXPECT_CALL(
+            *m_mockContextManager,
+            setState(ANOTHER_AGENT_CONTEXT, generateInterruptedState(active), StateRefreshPolicy::NEVER, 0));
+        EXPECT_CALL(*m_mockMessageSender, sendMessage(IsInterruptedEvent(SOME_OTHER_AGENT)));
+
+        // New directive handling.
+        EXPECT_CALL(*m_mockFocusManager, acquireChannel(CHANNEL_NAME, _))
+            .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnAcquireChannel));
+        EXPECT_CALL(
+            *m_mockSpeechPlayer,
+            attachmentSetSource(A<std::shared_ptr<avsCommon::avs::attachment::AttachmentReader>>(), nullptr));
+        EXPECT_CALL(*m_mockSpeechPlayer, play(_)).Times(AtLeast(1));
+        EXPECT_CALL(*m_mockSpeechPlayer, getOffset(_))
+            .Times(AtLeast(2))
+            .WillRepeatedly(Return(OFFSET_IN_CHRONO_MILLISECONDS_TEST));
+        EXPECT_CALL(
+            *m_mockContextManager,
+            setState(ANOTHER_AGENT_CONTEXT, generatePlayingState(speak), StateRefreshPolicy::ALWAYS, 0))
+            .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetState));
+        EXPECT_CALL(*m_mockMessageSender, sendMessage(IsStartedEvent(SOME_OTHER_AGENT)))
+            .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSendMessage));
+        EXPECT_CALL(*m_mockPowerResourceManager, acquire(_, _)).Times(AtLeast(1));
+    }
+
+    {
+        SCOPED_TRACE("Test Directive Handling");
+        m_speechSynthesizer->CapabilityAgent::preHandleDirective(directive, std::move(mockResultHandler));
+        m_speechSynthesizer->CapabilityAgent::handleDirective(speak.messageId);
+        EXPECT_TRUE(std::future_status::ready == m_wakeAcquireChannelFuture.wait_for(MY_WAIT_TIMEOUT));
+    }
+
+    {
+        SCOPED_TRACE("Check Speech Playback");
+        m_speechSynthesizer->onFocusChanged(FocusState::NONE, MixingBehavior::MUST_STOP);
+        m_speechSynthesizer->onFocusChanged(FocusState::FOREGROUND, MixingBehavior::PRIMARY);
+        EXPECT_TRUE(m_mockSpeechPlayer->waitUntilPlaybackStarted());
+        EXPECT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(MY_WAIT_TIMEOUT));
+        EXPECT_TRUE(std::future_status::ready == m_wakeSendMessageFuture.wait_for(MY_WAIT_TIMEOUT));
+        m_wakeSendMessagePromise = std::promise<void>();
+        m_wakeSendMessageFuture = m_wakeSendMessagePromise.get_future();
+        m_wakeSetStatePromise = std::promise<void>();
+        m_wakeSetStateFuture = m_wakeSetStatePromise.get_future();
+    }
+
+    {
+        SCOPED_TRACE("Check Speech Playback");
+        EXPECT_CALL(
+            *m_mockContextManager,
+            setState(ANOTHER_AGENT_CONTEXT, generateFinishedState(speak), StateRefreshPolicy::NEVER, 0))
+            .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetState));
+        EXPECT_CALL(*m_mockMessageSender, sendMessage(IsFinishedEvent(SOME_OTHER_AGENT)))
+            .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSendMessage));
+        EXPECT_CALL(*m_mockPowerResourceManager, release(_)).Times(AtLeast(1));
+        m_mockSpeechPlayer->mockFinished(m_mockSpeechPlayer->getCurrentSourceId());
+
+        EXPECT_TRUE(std::future_status::ready == m_wakeSendMessageFuture.wait_for(MY_WAIT_TIMEOUT));
+        EXPECT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(MY_WAIT_TIMEOUT));
+    }
+}
+
+/**
+ * Test SpeechSynthesizer is able to send event and report context to the correct agent.
+ */
+TEST_F(SpeechSynthesizerTest, test_activityStoppedWhenAgentIsDisabled) {
+    const NamespaceAndName ANOTHER_AGENT_CONTEXT{
+        NAMESPACE_AND_NAME_SPEECH_STATE.nameSpace, NAMESPACE_AND_NAME_SPEECH_STATE.name, SOME_OTHER_AGENT};
+    auto active = generateSpeakInfo(PlayBehavior::ENQUEUE);
+    {
+        auto mockEnqueuedResultHandler = std::unique_ptr<MockDirectiveHandlerResult>(new MockDirectiveHandlerResult());
+        EXPECT_CALL(*mockEnqueuedResultHandler, setCompleted());
+        ASSERT_TRUE(setupActiveSpeech(std::move(mockEnqueuedResultHandler), active, SOME_OTHER_AGENT));
+    }
+
+    EXPECT_CALL(
+        *m_mockContextManager,
+        setStateProvider(
+            NamespaceAndName{
+                NAMESPACE_AND_NAME_SPEECH_STATE.nameSpace, NAMESPACE_AND_NAME_SPEECH_STATE.name, SOME_OTHER_AGENT},
+            _))
+        .Times(AtLeast(1));
+    m_speechSynthesizer->onEnabled(SOME_OTHER_AGENT);
+
+    {
+        SCOPED_TRACE("Check disabling agent");
+        EXPECT_CALL(
+            *m_mockContextManager,
+            setState(ANOTHER_AGENT_CONTEXT, generateInterruptedState(active), StateRefreshPolicy::NEVER, 0));
+        EXPECT_CALL(*m_mockSpeechPlayer, stop(_))
+            .Times(1)
+            .WillOnce(Invoke([this](avsCommon::utils::mediaPlayer::MediaPlayerInterface::SourceId id) {
+                wakeOnStopped();
+                m_speechSynthesizer->onPlaybackStopped(id, DEFAULT_MEDIA_PLAYER_STATE);
+                return true;
+            }));
+        EXPECT_CALL(*m_mockMessageSender, sendMessage(IsInterruptedEvent(SOME_OTHER_AGENT)))
+            .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSendMessage));
+        m_speechSynthesizer->onDisabled(SOME_OTHER_AGENT);
+
+        ASSERT_TRUE(std::future_status::ready == m_wakeStoppedFuture.wait_for(MY_WAIT_TIMEOUT));
+        EXPECT_TRUE(std::future_status::ready == m_wakeSendMessageFuture.wait_for(MY_WAIT_TIMEOUT));
+    }
+}
+
+/**
+ * Test SpeechSynthesizer is able not stopping its activity if the non-active agent is disabled.
+ */
+TEST_F(SpeechSynthesizerTest, test_activityNotAffectedIfNonPlayingAgentIsDisabled) {
+    const NamespaceAndName ANOTHER_AGENT_CONTEXT{
+        NAMESPACE_AND_NAME_SPEECH_STATE.nameSpace, NAMESPACE_AND_NAME_SPEECH_STATE.name, SOME_OTHER_AGENT};
+    auto active = generateSpeakInfo(PlayBehavior::ENQUEUE);
+    {
+        auto mockEnqueuedResultHandler = std::unique_ptr<MockDirectiveHandlerResult>(new MockDirectiveHandlerResult());
+        ASSERT_TRUE(setupActiveSpeech(std::move(mockEnqueuedResultHandler), active, SOME_OTHER_AGENT));
+    }
+
+    EXPECT_CALL(
+        *m_mockContextManager,
+        setStateProvider(
+            NamespaceAndName{
+                NAMESPACE_AND_NAME_SPEECH_STATE.nameSpace, NAMESPACE_AND_NAME_SPEECH_STATE.name, SOME_OTHER_AGENT},
+            _))
+        .Times(AtLeast(1));
+    m_speechSynthesizer->onEnabled(SOME_OTHER_AGENT);
+
+    EXPECT_CALL(*m_mockSpeechPlayer, stop(_)).Times(0);
+    m_speechSynthesizer->onDisabled(avsCommon::avs::AgentId::getAlexaAgentId());
+
+    EXPECT_CALL(
+        *m_mockContextManager,
+        setState(ANOTHER_AGENT_CONTEXT, generateFinishedState(active), StateRefreshPolicy::NEVER, 0))
+        .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetState));
+    EXPECT_CALL(*m_mockMessageSender, sendMessage(IsFinishedEvent(SOME_OTHER_AGENT)))
+        .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSendMessage));
+    m_mockSpeechPlayer->mockFinished(m_mockSpeechPlayer->getCurrentSourceId());
+
+    EXPECT_TRUE(std::future_status::ready == m_wakeSendMessageFuture.wait_for(MY_WAIT_TIMEOUT));
+    EXPECT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(MY_WAIT_TIMEOUT));
+}
+
+/**
+ * Test SpeechSynthesizer is able to send event and report context to the correct agent.
+ */
+TEST_F(SpeechSynthesizerTest, test_removeStateProviderWhenAgentIsDisabled) {
+    EXPECT_CALL(*m_mockContextManager, removeStateProvider(NAMESPACE_AND_NAME_SPEECH_STATE)).Times(1);
+    m_speechSynthesizer->onDisabled(avsCommon::avs::AgentId::getAlexaAgentId());
+}
+
 /**
  * Test call to test audio analyzer config parsing logic.
  */
@@ -1883,11 +2143,12 @@ TEST_F(SpeechSynthesizerTest, test_parsingSingleAnalyzerConfig) {
     data.push_back(audioAnalyzer::AudioAnalyzerState("analyzername", "YES"));
     EXPECT_CALL(
         *m_mockSpeechSynthesizerObserver,
-        onStateChanged(SpeechSynthesizerObserverInterface::SpeechSynthesizerState::GAINING_FOCUS, _, _, _))
+        onStateChanged(SpeechSynthesizerObserverInterface::SpeechSynthesizerState::GAINING_FOCUS, _))
         .Times(1);
     EXPECT_CALL(
         *m_mockSpeechSynthesizerObserver,
-        onStateChanged(SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING, _, _, Eq(data)))
+        onStateChanged(
+            SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING, ObserverStateAnalyzerEq(data)))
         .Times(1);
 
     m_speechSynthesizer->addObserver(m_mockSpeechSynthesizerObserver);
@@ -1934,11 +2195,12 @@ TEST_F(SpeechSynthesizerTest, test_parsingMultipleAnalyzerConfig) {
     data.push_back(audioAnalyzer::AudioAnalyzerState("analyzername2", "NO"));
     EXPECT_CALL(
         *m_mockSpeechSynthesizerObserver,
-        onStateChanged(SpeechSynthesizerObserverInterface::SpeechSynthesizerState::GAINING_FOCUS, _, _, _))
+        onStateChanged(SpeechSynthesizerObserverInterface::SpeechSynthesizerState::GAINING_FOCUS, _))
         .Times(1);
     EXPECT_CALL(
         *m_mockSpeechSynthesizerObserver,
-        onStateChanged(SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING, _, _, Eq(data)))
+        onStateChanged(
+            SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING, ObserverStateAnalyzerEq(data)))
         .Times(1);
 
     m_speechSynthesizer->addObserver(m_mockSpeechSynthesizerObserver);
diff --git a/CapabilityAgents/TemplateRuntime/include/TemplateRuntime/TemplateRuntime.h b/CapabilityAgents/TemplateRuntime/include/TemplateRuntime/TemplateRuntime.h
index 81d4eafd..66e54648 100644
--- a/CapabilityAgents/TemplateRuntime/include/TemplateRuntime/TemplateRuntime.h
+++ b/CapabilityAgents/TemplateRuntime/include/TemplateRuntime/TemplateRuntime.h
@@ -116,6 +116,7 @@ public:
     /// @name DialogUXStateObserverInterface Functions
     /// @{
     void onDialogUXStateChanged(
+        avsCommon::avs::AgentId::IdType agentId,
         avsCommon::sdkInterfaces::DialogUXStateObserverInterface::DialogUXState newState) override;
     /// @}
 
diff --git a/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp b/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
index 5a19ef69..950109ab 100644
--- a/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
+++ b/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
@@ -39,7 +39,7 @@ static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_TYPE = "AlexaInter
 /// TemplateRuntime interface name
 static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_NAME = "TemplateRuntime";
 /// TemplateRuntime interface version
-static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_VERSION = "1.1";
+static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_VERSION = "1.2";
 
 /// String to identify log entries originating from this file.
 static const std::string TAG{"TemplateRuntime"};
@@ -226,8 +226,9 @@ void TemplateRuntime::onRenderPlayerCardsInfoChanged(avsCommon::avs::PlayerActiv
 }
 
 void TemplateRuntime::onDialogUXStateChanged(
+    avsCommon::avs::AgentId::IdType agentId,
     avsCommon::sdkInterfaces::DialogUXStateObserverInterface::DialogUXState newState) {
-    ACSDK_DEBUG5(LX("onDialogUXStateChanged").d("state", newState));
+    ACSDK_DEBUG5(LX("onDialogUXStateChanged").d("agentId", agentId).d("state", newState));
     m_executor.submit([this, newState]() {
         if (TemplateRuntime::State::DISPLAYING == m_state && m_lastDisplayedDirective &&
             m_lastDisplayedDirective->directive->getName() == RENDER_TEMPLATE) {
diff --git a/CapabilityAgents/TemplateRuntime/test/TemplateRuntimeTest.cpp b/CapabilityAgents/TemplateRuntime/test/TemplateRuntimeTest.cpp
index 9edbc350..545030bd 100644
--- a/CapabilityAgents/TemplateRuntime/test/TemplateRuntimeTest.cpp
+++ b/CapabilityAgents/TemplateRuntime/test/TemplateRuntimeTest.cpp
@@ -439,6 +439,7 @@ TEST_F(TemplateRuntimeTest, testSlow_renderTemplateDirective) {
     m_wakeSetCompletedFuture.wait_for(TIMEOUT);
     m_wakeRenderTemplateCardFuture.wait_for(TIMEOUT);
     m_templateRuntime->onDialogUXStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(),
         avsCommon::sdkInterfaces::DialogUXStateObserverInterface::DialogUXState::IDLE);
     m_wakeClearTemplateCardFuture.wait_for(TEMPLATE_TIMEOUT);
 }
@@ -471,15 +472,19 @@ TEST_F(
 
     // first test IDLE->EXPECTING transition
     m_templateRuntime->onDialogUXStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(),
         avsCommon::sdkInterfaces::DialogUXStateObserverInterface::DialogUXState::IDLE);
     m_templateRuntime->onDialogUXStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(),
         avsCommon::sdkInterfaces::DialogUXStateObserverInterface::DialogUXState::EXPECTING);
     EXPECT_EQ(m_wakeClearTemplateCardFuture.wait_for(TEMPLATE_NOT_CLEAR_TIMEOUT), std::future_status::timeout);
 
     // now test IDLE->SPEAKING transition
     m_templateRuntime->onDialogUXStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(),
         avsCommon::sdkInterfaces::DialogUXStateObserverInterface::DialogUXState::IDLE);
     m_templateRuntime->onDialogUXStateChanged(
+        avsCommon::avs::AgentId::getAlexaAgentId(),
         avsCommon::sdkInterfaces::DialogUXStateObserverInterface::DialogUXState::SPEAKING);
     EXPECT_EQ(m_wakeClearTemplateCardFuture.wait_for(TEMPLATE_NOT_CLEAR_TIMEOUT), std::future_status::timeout);
 }
diff --git a/Captions/Implementation/include/Captions/CaptionParserInterface.h b/Captions/Implementation/include/Captions/CaptionParserInterface.h
index 9bbff4e7..d1a518b2 100644
--- a/Captions/Implementation/include/Captions/CaptionParserInterface.h
+++ b/Captions/Implementation/include/Captions/CaptionParserInterface.h
@@ -64,7 +64,7 @@ public:
      *
      * @param parseListener the @c CaptionFrameParseListenerInterface instance which can receive the parsed objects.
      */
-    virtual void addListener(std::shared_ptr<CaptionFrameParseListenerInterface> parseListener) = 0;
+    virtual void setListener(std::shared_ptr<CaptionFrameParseListenerInterface> parseListener) = 0;
 };
 
 }  // namespace captions
diff --git a/Captions/Implementation/include/Captions/LibwebvttParserAdapter.h b/Captions/Implementation/include/Captions/LibwebvttParserAdapter.h
index 626654df..b5ad7607 100644
--- a/Captions/Implementation/include/Captions/LibwebvttParserAdapter.h
+++ b/Captions/Implementation/include/Captions/LibwebvttParserAdapter.h
@@ -44,7 +44,7 @@ public:
     /// @name CaptionParserInterface methods
     /// @{
     void parse(CaptionFrame::MediaPlayerSourceId captionId, const CaptionData& captionData) override;
-    void addListener(std::shared_ptr<CaptionFrameParseListenerInterface> parseListener) override;
+    void setListener(std::shared_ptr<CaptionFrameParseListenerInterface> parseListener) override;
     void releaseResourcesFor(CaptionFrame::MediaPlayerSourceId captionId) override;
     ///@}
 
diff --git a/Captions/Implementation/src/CaptionManager.cpp b/Captions/Implementation/src/CaptionManager.cpp
index ab597789..3d4a3372 100644
--- a/Captions/Implementation/src/CaptionManager.cpp
+++ b/Captions/Implementation/src/CaptionManager.cpp
@@ -61,7 +61,7 @@ std::shared_ptr<CaptionManager> CaptionManager::create(
     }
 
     auto captionManager = std::shared_ptr<CaptionManager>(new CaptionManager(parser, timingAdapterFactory));
-    parser->addListener(captionManager);
+    parser->setListener(captionManager);
     return captionManager;
 }
 
@@ -83,7 +83,10 @@ void CaptionManager::doShutdown() {
         adapter.reset();
     }
     m_timingAdaptersBySourceIds.clear();
-    m_parser.reset();
+    if (m_parser) {
+        m_parser->setListener(nullptr);
+        m_parser.reset();
+    }
 }
 
 void CaptionManager::onCaption(CaptionFrame::MediaPlayerSourceId sourceId, const CaptionData& captionData) {
diff --git a/Captions/Implementation/src/LibwebvttParserAdapter.cpp b/Captions/Implementation/src/LibwebvttParserAdapter.cpp
index 3ebf5fed..b02fd14c 100644
--- a/Captions/Implementation/src/LibwebvttParserAdapter.cpp
+++ b/Captions/Implementation/src/LibwebvttParserAdapter.cpp
@@ -53,17 +53,17 @@ static std::vector<CaptionFrame::MediaPlayerSourceId> g_captionSourceIds;
 static std::map<CaptionFrame::MediaPlayerSourceId, std::chrono::milliseconds> g_captionIdsToLastEndTime;
 
 /// The singleton instance returned by @c LibwebvttParserAdapter::getInstance();
-static std::shared_ptr<LibwebvttParserAdapter> m_libwebvttParserAdapterInstance;
+static std::shared_ptr<LibwebvttParserAdapter> g_libwebvttParserAdapterInstance;
 
 /// Global mutex for guarding access to the singleton instance and the maps.
 static std::mutex g_mutex;
 
 std::shared_ptr<LibwebvttParserAdapter> LibwebvttParserAdapter::getInstance() {
     std::lock_guard<std::mutex> lock(g_mutex);
-    if (!m_libwebvttParserAdapterInstance) {
-        m_libwebvttParserAdapterInstance = std::shared_ptr<LibwebvttParserAdapter>(new LibwebvttParserAdapter());
+    if (!g_libwebvttParserAdapterInstance) {
+        g_libwebvttParserAdapterInstance = std::shared_ptr<LibwebvttParserAdapter>(new LibwebvttParserAdapter());
     }
-    return m_libwebvttParserAdapterInstance;
+    return g_libwebvttParserAdapterInstance;
 }
 
 /**
@@ -240,7 +240,7 @@ void LibwebvttParserAdapter::parse(CaptionFrame::MediaPlayerSourceId captionId,
     webvtt_delete_parser(vtt);
 }
 
-void LibwebvttParserAdapter::addListener(std::shared_ptr<CaptionFrameParseListenerInterface> listener) {
+void LibwebvttParserAdapter::setListener(std::shared_ptr<CaptionFrameParseListenerInterface> listener) {
     ACSDK_DEBUG7(LX(__func__));
     g_parseListener = listener;
 }
diff --git a/Captions/Implementation/test/LibwebvttParserAdapterTest.cpp b/Captions/Implementation/test/LibwebvttParserAdapterTest.cpp
index 770f48a7..d6b48d44 100644
--- a/Captions/Implementation/test/LibwebvttParserAdapterTest.cpp
+++ b/Captions/Implementation/test/LibwebvttParserAdapterTest.cpp
@@ -67,14 +67,14 @@ void LibwebvttParserAdapterTest::SetUp() {
 }
 
 void LibwebvttParserAdapterTest::TearDown() {
-    m_libwebvttParser->addListener(nullptr);
+    m_libwebvttParser->setListener(nullptr);
 }
 
 /**
  * Test that parse does not call onParsed with malformed WebVTT header.
  */
 TEST_F(LibwebvttParserAdapterTest, test_createWithNullArgs) {
-    m_libwebvttParser->addListener(m_mockCaptionManager);
+    m_libwebvttParser->setListener(m_mockCaptionManager);
     EXPECT_CALL(*(m_mockCaptionManager.get()), onParsed(_)).Times(0);
 
     const CaptionData inputData = CaptionData(CaptionFormat::WEBVTT, "");
@@ -86,7 +86,7 @@ TEST_F(LibwebvttParserAdapterTest, test_createWithNullArgs) {
  * Test that parse succeeds for a single, sane caption data and returns the same captionId back to the listener.
  */
 TEST_F(LibwebvttParserAdapterTest, test_parseSingleCaptionFrame) {
-    m_libwebvttParser->addListener(m_mockCaptionManager);
+    m_libwebvttParser->setListener(m_mockCaptionManager);
     std::vector<TextStyle> expectedStyles;
 
     Style s0 = Style();
@@ -114,7 +114,7 @@ TEST_F(LibwebvttParserAdapterTest, test_parseSingleCaptionFrame) {
  * listener, along with the correct caption frame.
  */
 TEST_F(LibwebvttParserAdapterTest, test_parseMultipleCaptionFrames) {
-    m_libwebvttParser->addListener(m_mockCaptionManager);
+    m_libwebvttParser->setListener(m_mockCaptionManager);
 
     // Expected frame #1
     std::vector<TextStyle> frame1_expectedStyles;
@@ -162,7 +162,7 @@ TEST_F(LibwebvttParserAdapterTest, test_parseMultipleCaptionFrames) {
  * Test that parse succeeds for a single, sane caption data and returns multiple caption frames, both with the same ID.
  */
 TEST_F(LibwebvttParserAdapterTest, test_parseSingleCaptionDataToCaptionFrames) {
-    m_libwebvttParser->addListener(m_mockCaptionManager);
+    m_libwebvttParser->setListener(m_mockCaptionManager);
 
     // Expected frame #1
     std::vector<CaptionLine> frame1_expectedCaptionLines;
@@ -199,7 +199,7 @@ TEST_F(LibwebvttParserAdapterTest, test_parseSingleCaptionDataToCaptionFrames) {
  * Test that parse honors a time gap between two caption frames.
  */
 TEST_F(LibwebvttParserAdapterTest, test_parseDelayBetweenCaptionFrames) {
-    m_libwebvttParser->addListener(m_mockCaptionManager);
+    m_libwebvttParser->setListener(m_mockCaptionManager);
 
     // Expected frame #1
     std::vector<CaptionLine> frame1_expectedCaptionLines;
@@ -236,7 +236,7 @@ TEST_F(LibwebvttParserAdapterTest, test_parseDelayBetweenCaptionFrames) {
  * Test that parse converts the bold tag to bold style.
  */
 TEST_F(LibwebvttParserAdapterTest, test_parseBoldTagToStyle) {
-    m_libwebvttParser->addListener(m_mockCaptionManager);
+    m_libwebvttParser->setListener(m_mockCaptionManager);
 
     std::vector<TextStyle> expectedStyles;
 
@@ -272,7 +272,7 @@ TEST_F(LibwebvttParserAdapterTest, test_parseBoldTagToStyle) {
  * Test that parse converts the italic tag to italic style.
  */
 TEST_F(LibwebvttParserAdapterTest, test_parseItalicTagToStyle) {
-    m_libwebvttParser->addListener(m_mockCaptionManager);
+    m_libwebvttParser->setListener(m_mockCaptionManager);
 
     std::vector<TextStyle> expectedStyles;
 
diff --git a/Captions/Implementation/test/MockCaptionParser.h b/Captions/Implementation/test/MockCaptionParser.h
index ac8fbad2..764bd31a 100644
--- a/Captions/Implementation/test/MockCaptionParser.h
+++ b/Captions/Implementation/test/MockCaptionParser.h
@@ -32,7 +32,7 @@ public:
     /// @name CaptionParserInterface methods
     /// @{
     MOCK_METHOD2(parse, void(const CaptionFrame::MediaPlayerSourceId, const CaptionData& captionData));
-    MOCK_METHOD1(addListener, void(std::shared_ptr<CaptionFrameParseListenerInterface> parseListener));
+    MOCK_METHOD1(setListener, void(std::shared_ptr<CaptionFrameParseListenerInterface> parseListener));
     MOCK_METHOD1(releaseResourcesFor, void(CaptionFrame::MediaPlayerSourceId));
     /// }@
 };
diff --git a/CertifiedSender/src/CertifiedSender.cpp b/CertifiedSender/src/CertifiedSender.cpp
index 840d3147..e5f9b5d8 100644
--- a/CertifiedSender/src/CertifiedSender.cpp
+++ b/CertifiedSender/src/CertifiedSender.cpp
@@ -265,6 +265,14 @@ void CertifiedSender::mainloop() {
             // ACL to continue interacting with the old instance (for example, if it is involved in a complex flow
             // of exception / onCompleted handling), and allows us to safely try sending the new instance.
             lock.lock();
+            if (m_messagesToSend.empty()) {  // Queue might have got cleared on a separate thread.
+                lock.unlock();
+                ACSDK_DEBUG9(LX(__func__).m("retryingNotRequiredDueToLogout"));
+
+                // Resetting the fail count.
+                failedSendRetryCount = 0;
+                continue; // m_currentMessage get resets at the beining of the while loop
+            }
             m_messagesToSend.pop_front();
             m_messagesToSend.push_front(std::make_shared<CertifiedMessageRequest>(
                 m_currentMessage->getJsonContent(),
@@ -298,7 +306,9 @@ void CertifiedSender::mainloop() {
                 ACSDK_ERROR(LX("mainloop : could not erase message from storage."));
             }
 
-            m_messagesToSend.pop_front();
+            if (!m_messagesToSend.empty()) {  // Queue might have got cleared on a separate thread.
+                m_messagesToSend.pop_front();
+            }
             lock.unlock();
             // Resetting the fail count.
             failedSendRetryCount = 0;
diff --git a/ContextManager/include/ContextManager/ContextManager.h b/ContextManager/include/ContextManager/ContextManager.h
index a00d0592..ba98a28f 100644
--- a/ContextManager/include/ContextManager/ContextManager.h
+++ b/ContextManager/include/ContextManager/ContextManager.h
@@ -95,11 +95,23 @@ public:
         const avsCommon::avs::StateRefreshPolicy& refreshPolicy,
         const avsCommon::sdkInterfaces::ContextRequestToken stateRequestToken = 0) override;
 
+    avsCommon::sdkInterfaces::ContextRequestToken getContext(
+        std::shared_ptr<avsCommon::sdkInterfaces::ContextRequesterInterface> contextRequester,
+        avsCommon::avs::AgentId::IdType agentId,
+        const std::string& endpointId,
+        const std::chrono::milliseconds& timeout) override;
+
     avsCommon::sdkInterfaces::ContextRequestToken getContext(
         std::shared_ptr<avsCommon::sdkInterfaces::ContextRequesterInterface> contextRequester,
         const std::string& endpointId,
         const std::chrono::milliseconds& timeout) override;
 
+    avsCommon::sdkInterfaces::ContextRequestToken getContextWithoutReportableStateProperties(
+        std::shared_ptr<avsCommon::sdkInterfaces::ContextRequesterInterface> contextRequester,
+        avsCommon::avs::AgentId::IdType agentId,
+        const std::string& endpointId,
+        const std::chrono::milliseconds& timeout) override;
+
     avsCommon::sdkInterfaces::ContextRequestToken getContextWithoutReportableStateProperties(
         std::shared_ptr<avsCommon::sdkInterfaces::ContextRequesterInterface> contextRequester,
         const std::string& endpointId,
@@ -191,6 +203,8 @@ private:  // Private type declarations.
         std::shared_ptr<avsCommon::sdkInterfaces::ContextRequesterInterface> contextRequester;
         /// If Reportable Properties should be skipped for this request.
         bool skipReportableStateProperties;
+        /// The AgentId of this request
+        avsCommon::avs::AgentId::IdType agentId;
 
         /**
          * Default Constructor.
@@ -201,12 +215,14 @@ private:  // Private type declarations.
          * Constructor.
          * @param timerToken The token returned by the @c MultiTimer.
          * @param contextRequester The @c ContextRequesterInterface pointer.
+         * @param agentId The @c AgentId of the request.
          * @param skipReportableProperties The boolean indicating if the reportable properties should be skipped for
          * this request.
          */
         RequestTracker(
             avsCommon::utils::timing::MultiTimer::Token timerToken,
             std::shared_ptr<avsCommon::sdkInterfaces::ContextRequesterInterface> contextRequester,
+            avsCommon::avs::AgentId::IdType agentId,
             bool skipReportableProperties);
     };
 
@@ -253,6 +269,7 @@ private:  // Private method declarations.
      *
      * @param contextRequester The context requester asking for context.
      * @param endpointId The @c endpointId used to select which context is being requested.
+     * @param agentId The AgentId of the request.
      * @param timeout The maximum time this request should take. After the timeout, the context manager will abort the
      * request.
      * @param skipReportableStateProperties The flag which indicates if ReportableStateProperties can be ignored from
@@ -261,6 +278,7 @@ private:  // Private method declarations.
      */
     avsCommon::sdkInterfaces::ContextRequestToken getContextInternal(
         std::shared_ptr<avsCommon::sdkInterfaces::ContextRequesterInterface> contextRequester,
+        avsCommon::avs::AgentId::IdType agentId,
         const std::string& endpointId,
         const std::chrono::milliseconds& timeout,
         bool skipReportableStateProperties);
@@ -269,6 +287,9 @@ private:  // Private method declarations.
      * This method returns a callback which should be invoked once the context is ready.
      * If the context is not ready, this method will return a no-op function.
      *
+     * @note The calling thread must hold @c m_requestsMutex over the call to this method. The calling thread must
+     * not be holding @c m_endpointsStateMutex.
+     *
      * @note The callback method that is returned should only be called outside of a lock to prevent deadlock scenarios.
      *
      * @note If the context is ready, the method also removes the request from the pending requests map.
diff --git a/ContextManager/src/ContextManager.cpp b/ContextManager/src/ContextManager.cpp
index 6631034a..494cf388 100644
--- a/ContextManager/src/ContextManager.cpp
+++ b/ContextManager/src/ContextManager.cpp
@@ -15,6 +15,7 @@
 
 #include <algorithm>
 
+#include <AVSCommon/AVS/AgentId.h>
 #include <AVSCommon/Utils/Error/FinallyGuard.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
 #include "AVSCommon/Utils/Metrics/MetricEventBuilder.h"
@@ -90,16 +91,19 @@ static void NoopCallback() {
 ContextManager::RequestTracker::RequestTracker() :
         timerToken{0},
         contextRequester{nullptr},
-        skipReportableStateProperties{false} {
+        skipReportableStateProperties{false},
+        agentId{avsCommon::avs::AgentId::getAlexaAgentId()} {
 }
 
 ContextManager::RequestTracker::RequestTracker(
     avsCommon::utils::timing::MultiTimer::Token timerToken,
     std::shared_ptr<ContextRequesterInterface> contextRequester,
+    avsCommon::avs::AgentId::IdType agentId,
     bool skipReportableProperties) :
         timerToken{timerToken},
         contextRequester{contextRequester},
-        skipReportableStateProperties{skipReportableProperties} {
+        skipReportableStateProperties{skipReportableProperties},
+        agentId{agentId} {
 }
 
 void ContextManager::setStateProvider(
@@ -298,9 +302,14 @@ void ContextManager::provideStateUnavailableResponse(
             }
 
             if (!isEndpointUnreachable) {
-                auto& endpointState = m_endpointsState[capabilityIdentifier.endpointId];
-                auto cachedState = endpointState.find(capabilityIdentifier);
-                if ((cachedState != endpointState.end()) && cachedState->second.capabilityState.hasValue()) {
+                bool hasCachedState = false;
+                {
+                    std::lock_guard<std::mutex> statesLock{m_endpointsStateMutex};
+                    auto& endpointState = m_endpointsState[capabilityIdentifier.endpointId];
+                    auto cachedState = endpointState.find(capabilityIdentifier);
+                    hasCachedState = (cachedState != endpointState.end()) && cachedState->second.capabilityState.hasValue();
+                }
+                if (hasCachedState) {
                     if (requestIt != m_pendingStateRequest.end()) {
                         requestIt->second.erase(capabilityIdentifier);
                     }
@@ -343,25 +352,44 @@ ContextRequestToken ContextManager::getContext(
     const std::string& endpointId,
     const std::chrono::milliseconds& timeout) {
     ACSDK_DEBUG5(LX(__func__));
-    return getContextInternal(contextRequester, endpointId, timeout, false);
+    return getContextInternal(contextRequester, avsCommon::avs::AgentId::getAlexaAgentId(), endpointId, timeout, false);
+}
+
+ContextRequestToken ContextManager::getContext(
+    std::shared_ptr<ContextRequesterInterface> contextRequester,
+    avsCommon::avs::AgentId::IdType agentId,
+    const std::string& endpointId,
+    const std::chrono::milliseconds& timeout) {
+    ACSDK_DEBUG5(LX(__func__));
+    return getContextInternal(contextRequester, agentId, endpointId, timeout, false);
+}
+
+ContextRequestToken ContextManager::getContextWithoutReportableStateProperties(
+    std::shared_ptr<ContextRequesterInterface> contextRequester,
+    const std::string& endpointId,
+    const std::chrono::milliseconds& timeout) {
+    ACSDK_DEBUG5(LX(__func__));
+    return getContextInternal(contextRequester, avsCommon::avs::AgentId::getAlexaAgentId(), endpointId, timeout, true);
 }
 
 ContextRequestToken ContextManager::getContextWithoutReportableStateProperties(
     std::shared_ptr<ContextRequesterInterface> contextRequester,
+    avsCommon::avs::AgentId::IdType agentId,
     const std::string& endpointId,
     const std::chrono::milliseconds& timeout) {
     ACSDK_DEBUG5(LX(__func__));
-    return getContextInternal(contextRequester, endpointId, timeout, true);
+    return getContextInternal(contextRequester, agentId, endpointId, timeout, true);
 }
 
 ContextRequestToken ContextManager::getContextInternal(
     std::shared_ptr<ContextRequesterInterface> contextRequester,
+    avsCommon::avs::AgentId::IdType agentId,
     const std::string& endpointId,
     const std::chrono::milliseconds& timeout,
     bool bSkipReportableStateProperties) {
     ACSDK_DEBUG5(LX(__func__).sensitive("endpointId", endpointId));
     auto token = generateToken();
-    m_executor.submit([this, contextRequester, endpointId, token, timeout, bSkipReportableStateProperties] {
+    m_executor.submit([this, contextRequester, agentId, endpointId, token, timeout, bSkipReportableStateProperties] {
         auto timerToken = m_multiTimer->submitTask(timeout, [this, token] {
             // Cancel request after timeout.
             m_executor.submit([this, token] {
@@ -374,43 +402,51 @@ ContextRequestToken ContextManager::getContextInternal(
                 contextFailureCallback();
             });
         });
-
-        std::lock_guard<std::mutex> requestsLock{m_requestsMutex};
-        auto& requestEndpointId = endpointId.empty() ? m_defaultEndpointId : endpointId;
-        m_pendingRequests.emplace(token, RequestTracker(timerToken, contextRequester, bSkipReportableStateProperties));
-
         std::function<void()> contextAvailableCallback = NoopCallback;
         {
-            std::lock_guard<std::mutex> statesLock{m_endpointsStateMutex};
-
-            for (auto& capability : m_endpointsState[requestEndpointId]) {
-                auto stateInfo = capability.second;
-                auto stateProvider = capability.second.stateProvider;
-
-                if (stateProvider) {
-                    bool requestState = false;
-                    if (stateInfo.legacyCapability && stateInfo.refreshPolicy != StateRefreshPolicy::NEVER) {
-                        requestState = true;
-                    } else if (
-                        !stateInfo.legacyCapability && stateProvider->canStateBeRetrieved() &&
-                        stateProvider->shouldQueryState()) {
-                        if (stateProvider->hasReportableStateProperties()) {
-                            /// Check if the reportable state properties should be skipped.
-                            if (!bSkipReportableStateProperties) {
+            std::lock_guard<std::mutex> requestsLock{m_requestsMutex};
+            auto& requestEndpointId = endpointId.empty() ? m_defaultEndpointId : endpointId;
+            m_pendingRequests.emplace(token, RequestTracker(timerToken, contextRequester, agentId, bSkipReportableStateProperties));
+            {
+                std::lock_guard<std::mutex> statesLock{m_endpointsStateMutex};
+
+                /// Make sure agentId is not AGENT_ID_ALL because this ID is not targeted ao any agent, so it's invalid.
+                if (avsCommon::avs::AgentId::AGENT_ID_ALL != agentId) {
+                    for (auto& capability : m_endpointsState[requestEndpointId]) {
+                        auto stateInfo = capability.second;
+                        auto stateProvider = capability.second.stateProvider;
+                        auto capabilityTag = capability.first;
+
+                        if (capabilityTag.getAgentId() != agentId &&
+                            capabilityTag.getAgentId() != avsCommon::avs::AgentId::AGENT_ID_ALL) {
+                            continue;
+                        }
+
+                        if (stateProvider) {
+                            bool requestState = false;
+                            if (stateInfo.legacyCapability && stateInfo.refreshPolicy != StateRefreshPolicy::NEVER) {
                                 requestState = true;
+                            } else if (
+                                !stateInfo.legacyCapability && stateProvider->canStateBeRetrieved() &&
+                                stateProvider->shouldQueryState()) {
+                                if (stateProvider->hasReportableStateProperties()) {
+                                    /// Check if the reportable state properties should be skipped.
+                                    if (!bSkipReportableStateProperties) {
+                                        requestState = true;
+                                    }
+                                } else {
+                                    requestState = true;
+                                }
                             }
-                        } else {
-                            requestState = true;
-                        }
-                    }
 
-                    if (requestState) {
-                        stateProvider->provideState(capability.first, token);
-                        m_pendingStateRequest[token].emplace(capability.first);
+                            if (requestState) {
+                                stateProvider->provideState(capabilityTag, token);
+                                m_pendingStateRequest[token].emplace(capabilityTag);
+                            }
+                        }
                     }
                 }
             }
-
             contextAvailableCallback = getContextAvailableCallbackIfReadyLocked(token, requestEndpointId);
         }
         /// Callback method should be called outside the lock.
@@ -447,6 +483,7 @@ std::function<void()> ContextManager::getContextFailureCallbackLocked(
         recordMetric(
             m_metricRecorder,
             MetricEventBuilder{}
+                .setMetricContext(MetricContext{request.agentId})
                 .setActivityName("CONTEXT_MANAGER-" + metricName)
                 .addDataPoint(DataPointCounterBuilder{}.setName(metricName).increment(1).build())
                 .build());
@@ -489,11 +526,22 @@ std::function<void()> ContextManager::getContextAvailableCallbackIfReadyLocked(
 
     AVSContext context;
     auto& requestEndpointId = endpointId.empty() ? m_defaultEndpointId : endpointId;
+    std::lock_guard<std::mutex> stateProviderLock(m_endpointsStateMutex);
     for (auto& capability : m_endpointsState[requestEndpointId]) {
         auto stateProvider = capability.second.stateProvider;
         auto stateInfo = capability.second;
+        auto capabilityTag = capability.first;
         bool addState = false;
 
+        if (avsCommon::avs::AgentId::AGENT_ID_ALL == request.agentId) {
+            continue;
+        }
+
+        if (capabilityTag.getAgentId() != request.agentId &&
+            capabilityTag.getAgentId() != avsCommon::avs::AgentId::AGENT_ID_ALL) {
+            continue;
+        }
+
         if (stateInfo.legacyCapability) {
             // Ignore if the state is not available for legacy SOMETIMES refresh policy.
             if ((stateInfo.refreshPolicy == StateRefreshPolicy::SOMETIMES) && !stateInfo.capabilityState.hasValue()) {
diff --git a/ContextManager/test/ContextManagerTest.cpp b/ContextManager/test/ContextManagerTest.cpp
index 54a6b4b1..6238204f 100644
--- a/ContextManager/test/ContextManagerTest.cpp
+++ b/ContextManager/test/ContextManagerTest.cpp
@@ -90,6 +90,9 @@ void ContextManagerTest::SetUp() {
         "clientId", "productId", "1234", "manufacturer", "my device", "friendlyName", "deviceType");
     ASSERT_NE(deviceInfo, nullptr);
 
+    // Set Alexa ID for testing.
+    avsCommon::avs::AgentId::setAlexaAgentId(2);
+
     m_contextManager = ContextManager::createContextManagerInterface(std::move(deviceInfo));
 }
 
@@ -668,6 +671,222 @@ TEST_F(ContextManagerTest, test_getContextShouldReturnCache) {
     EXPECT_EQ(statesFuture.get()[capability].valuePayload, state.valuePayload);
 }
 
+/**
+ * Set the states with a @c StateRefreshPolicy @c ALWAYS for @c StateProviderInterfaces that are registered with the
+ * @c ContextManager. Request for context by calling @c getContext. Expect that the context is returned within the
+ * timeout period. Check the context that is returned by the @c ContextManager. Expect it should match the test value.
+ * Plus also test it for multiple agents case.  We will have providers for ALEXA, some
+ * other agent and ALL agents.  The requester will ask for context for the some other agent.  The expectation is
+ * that ContextManager will query and return the reportable state context provider from provider for some other agent
+ * and All agents.
+ * We will also test a request to request for ALL agents, this is an invalid call to the API and the expectation is
+ * that ContextManager will not query context from any provider and return an empty context.
+ */
+TEST_F(ContextManagerTest, test_getContextLegacyProviderMultiAgents) {
+    // Define another agent other than Alexa.
+    auto someOtherAgent = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+
+    // Provider for Alexa agent.  We expect this will not be asked to provide context.
+    auto alexaAgentProvider = std::make_shared<MockLegacyStateProvider>();
+    auto alexaAgentCapability = NamespaceAndName("Namespace1", "Name1", avsCommon::avs::AgentId::getAlexaAgentId());
+    m_contextManager->setStateProvider(alexaAgentCapability, alexaAgentProvider);
+    EXPECT_CALL(*alexaAgentProvider, provideState(_, _)).Times(0);
+
+    // Provider for Another agent.  We expect this will be asked to provide context.
+    auto someOtherAgentProvider = std::make_shared<MockLegacyStateProvider>();
+    auto someOtherAgentCapability = NamespaceAndName("Namespace2", "Name2", someOtherAgent);
+    std::string someOtherAgentCapabilityPayload{R"({"state2":"value2"})"};
+    m_contextManager->setStateProvider(someOtherAgentCapability, someOtherAgentProvider);
+    std::promise<ContextRequestToken> someOtherAgentTokenPromise;
+    EXPECT_CALL(*someOtherAgentProvider, provideState(_, _))
+        .WillOnce(WithArg<1>(Invoke([&someOtherAgentTokenPromise](const ContextRequestToken token) {
+            someOtherAgentTokenPromise.set_value(token);
+        })));
+
+    // Provider for all agents.  We expect this will be asked to provider context.
+    auto allAgentprovider = std::make_shared<MockLegacyStateProvider>();
+    auto allAgentCapability = NamespaceAndName("Namespace3", "Name3", avsCommon::avs::AgentId::AGENT_ID_ALL);
+    std::string allAgentPayload{R"({"state3":"value3"})"};
+    m_contextManager->setStateProvider(allAgentCapability, allAgentprovider);
+    std::promise<ContextRequestToken> allAgentTokenPromise;
+    EXPECT_CALL(*allAgentprovider, provideState(_, _))
+        .WillOnce(WithArg<1>(Invoke(
+            [&allAgentTokenPromise](const ContextRequestToken token) { allAgentTokenPromise.set_value(token); })));
+
+    auto requester = std::make_shared<MockContextRequester>();
+    std::promise<AVSContext::States> contextStatesPromise;
+    EXPECT_CALL(*requester, onContextAvailable(_, _, _))
+        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const AVSContext& context) {
+            contextStatesPromise.set_value(context.getStates());
+        })));
+
+    auto requestToken = m_contextManager->getContext(requester, someOtherAgent);
+
+    const std::chrono::milliseconds timeout{100};
+    auto expectedSomeOtherAgentTokenFuture = someOtherAgentTokenPromise.get_future();
+    ASSERT_EQ(expectedSomeOtherAgentTokenFuture.wait_for(timeout), std::future_status::ready);
+    EXPECT_EQ(requestToken, expectedSomeOtherAgentTokenFuture.get());
+    ASSERT_EQ(
+        m_contextManager->setState(
+            someOtherAgentCapability, someOtherAgentCapabilityPayload, StateRefreshPolicy::ALWAYS, requestToken),
+        SetStateResult::SUCCESS);
+
+    auto expectedAllAgentTokenFuture = allAgentTokenPromise.get_future();
+    ASSERT_EQ(expectedAllAgentTokenFuture.wait_for(timeout), std::future_status::ready);
+    EXPECT_EQ(requestToken, expectedAllAgentTokenFuture.get());
+    ASSERT_EQ(
+        m_contextManager->setState(allAgentCapability, allAgentPayload, StateRefreshPolicy::ALWAYS, requestToken),
+        SetStateResult::SUCCESS);
+
+    auto statesFuture = contextStatesPromise.get_future();
+    ASSERT_EQ(statesFuture.wait_for(timeout), std::future_status::ready);
+    auto states = statesFuture.get();
+    EXPECT_EQ(states.find(alexaAgentCapability), states.end());
+    EXPECT_EQ(states[someOtherAgentCapability].valuePayload, someOtherAgentCapabilityPayload);
+    EXPECT_EQ(states[allAgentCapability].valuePayload, allAgentPayload);
+
+    // check that when request context for AGENT_ID_ALL, it returns nothing
+    auto requesterAllAgents = std::make_shared<MockContextRequester>();
+    std::promise<AVSContext::States> contextStatesPromiseAllAgents;
+    EXPECT_CALL(*requesterAllAgents, onContextAvailable(_, _, _))
+        .WillOnce(WithArg<1>(Invoke([&contextStatesPromiseAllAgents](const AVSContext& context) {
+            contextStatesPromiseAllAgents.set_value(context.getStates());
+        })));
+    m_contextManager->getContextWithoutReportableStateProperties(
+        requesterAllAgents, avsCommon::avs::AgentId::AGENT_ID_ALL);
+
+    auto statesFutureAllAgent = contextStatesPromiseAllAgents.get_future();
+    ASSERT_EQ(statesFutureAllAgent.wait_for(timeout), std::future_status::ready);
+
+    auto statesAllAgent = statesFutureAllAgent.get();
+    EXPECT_EQ(statesAllAgent.find(alexaAgentCapability), statesAllAgent.end());
+    EXPECT_EQ(statesAllAgent.find(someOtherAgentCapability), statesAllAgent.end());
+    EXPECT_EQ(statesAllAgent.find(allAgentCapability), statesAllAgent.end());
+}
+
+/**
+ * Test if the getContextWithoutReportableStateProperties() method skips state from @c StateProviders which have
+ * reportable state properties.  Plus also test it for multiple agents case.  We will have providers for ALEXA, some
+ * other agent and ALL agents.  The requester will ask for context for the some other agent.  The expectation is
+ * that ContextManager will query and return the reportable state context provider from provider for some other agent
+ * and All agents.
+ * We will also test a request to request for ALL agents, this is an invalid call to the API and the expectation is
+ * that ContextManager will not query context from any provider and return an empty context.
+ */
+TEST_F(ContextManagerTest, test_getContextWithoutReportableStatePropertiesMultiAgents) {
+    // Define another agent other than Alexa.
+    auto someOtherAgent = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+
+    // Provider for Alexa agent.  We don't expect these will be called.
+    auto providerWithReportableStatePropertiesAlexaAgent = std::make_shared<MockStateProvider>();
+    auto capability1AlexaAgent =
+        CapabilityTag("NamespaceAlexa", "Name1", avsCommon::avs::AgentId::getAlexaAgentId(), "");
+    EXPECT_CALL(*providerWithReportableStatePropertiesAlexaAgent, hasReportableStateProperties())
+        .WillRepeatedly(Return(true));
+    EXPECT_CALL(*providerWithReportableStatePropertiesAlexaAgent, shouldQueryState()).WillRepeatedly(Return(true));
+    m_contextManager->setStateProvider(capability1AlexaAgent, providerWithReportableStatePropertiesAlexaAgent);
+    EXPECT_CALL(*providerWithReportableStatePropertiesAlexaAgent, provideState(_, _)).Times(0);
+
+    auto providerWithoutReportableStatePropertiesAlexaAgent = std::make_shared<MockStateProvider>();
+    auto capability2AlexaAgent =
+        CapabilityTag("NamespaceAlexa", "Name2", avsCommon::avs::AgentId::getAlexaAgentId(), "");
+    EXPECT_CALL(*providerWithoutReportableStatePropertiesAlexaAgent, hasReportableStateProperties())
+        .WillRepeatedly(Return(false));
+    EXPECT_CALL(*providerWithoutReportableStatePropertiesAlexaAgent, shouldQueryState()).WillRepeatedly(Return(true));
+    m_contextManager->setStateProvider(capability2AlexaAgent, providerWithoutReportableStatePropertiesAlexaAgent);
+    EXPECT_CALL(*providerWithReportableStatePropertiesAlexaAgent, provideState(_, _)).Times(0);
+
+    // Provider for Another agent.  We expect the ones without reportable state will be called.
+    auto providerWithReportableStatePropertiesOtherAgent = std::make_shared<MockStateProvider>();
+    auto capability1OtherAgent = CapabilityTag("NamespaceOther", "Name1", someOtherAgent, "");
+    EXPECT_CALL(*providerWithReportableStatePropertiesOtherAgent, hasReportableStateProperties())
+        .WillRepeatedly(Return(true));
+    EXPECT_CALL(*providerWithReportableStatePropertiesOtherAgent, shouldQueryState()).WillRepeatedly(Return(true));
+    m_contextManager->setStateProvider(capability1OtherAgent, providerWithReportableStatePropertiesOtherAgent);
+    EXPECT_CALL(*providerWithReportableStatePropertiesOtherAgent, provideState(_, _)).Times(0);
+
+    auto providerWithoutReportableStatePropertiesOtherAgent = std::make_shared<MockStateProvider>();
+    auto capability2OtherAgent = CapabilityTag("NamespaceOther", "Name2", someOtherAgent, "");
+    CapabilityState state2OtherAgent{R"({"state2Other":"target2"})"};
+    EXPECT_CALL(*providerWithoutReportableStatePropertiesOtherAgent, hasReportableStateProperties())
+        .WillRepeatedly(Return(false));
+    EXPECT_CALL(*providerWithoutReportableStatePropertiesOtherAgent, shouldQueryState()).WillRepeatedly(Return(true));
+    m_contextManager->setStateProvider(capability2OtherAgent, providerWithoutReportableStatePropertiesOtherAgent);
+    utils::WaitEvent provideStateEventOtherAgents;
+    EXPECT_CALL(*providerWithoutReportableStatePropertiesOtherAgent, provideState(_, _))
+        .WillOnce((InvokeWithoutArgs([&provideStateEventOtherAgents] { provideStateEventOtherAgents.wakeUp(); })));
+
+    // Provider for all agents.  We expect the ones without reportable state will be called.
+    auto providerWithReportableStatePropertiesAllAgents = std::make_shared<MockStateProvider>();
+    auto capability1AllAgents = CapabilityTag("NamespaceAll", "Name1", avsCommon::avs::AgentId::AGENT_ID_ALL, "");
+    CapabilityState state1AllAgents{R"({"state1All":"target1"})"};
+    EXPECT_CALL(*providerWithReportableStatePropertiesAllAgents, hasReportableStateProperties())
+        .WillRepeatedly(Return(true));
+    EXPECT_CALL(*providerWithReportableStatePropertiesAllAgents, shouldQueryState()).WillRepeatedly(Return(true));
+    m_contextManager->setStateProvider(capability1AllAgents, providerWithReportableStatePropertiesAllAgents);
+    EXPECT_CALL(*providerWithReportableStatePropertiesAllAgents, provideState(_, _)).Times(0);
+
+    auto providerWithoutReportableStatePropertiesAllAgents = std::make_shared<MockStateProvider>();
+    auto capability2AllAgents = CapabilityTag("NamespaceAll", "Name2", avsCommon::avs::AgentId::AGENT_ID_ALL, "");
+    CapabilityState state2AllAgents{R"({"state2All":"target2"})"};
+    EXPECT_CALL(*providerWithoutReportableStatePropertiesAllAgents, hasReportableStateProperties())
+        .WillRepeatedly(Return(false));
+    EXPECT_CALL(*providerWithoutReportableStatePropertiesAllAgents, shouldQueryState()).WillRepeatedly(Return(true));
+    m_contextManager->setStateProvider(capability2AllAgents, providerWithoutReportableStatePropertiesAllAgents);
+    utils::WaitEvent provideStateEventAllAgents;
+    EXPECT_CALL(*providerWithoutReportableStatePropertiesAllAgents, provideState(_, _))
+        .WillOnce((InvokeWithoutArgs([&provideStateEventAllAgents] { provideStateEventAllAgents.wakeUp(); })));
+
+    auto requester = std::make_shared<MockContextRequester>();
+    std::promise<AVSContext::States> contextStatesPromise;
+    EXPECT_CALL(*requester, onContextAvailable(_, _, _))
+        .WillOnce(WithArg<1>(Invoke([&contextStatesPromise](const AVSContext& context) {
+            contextStatesPromise.set_value(context.getStates());
+        })));
+
+    // Get context for the target endpoint.
+    auto requestToken = m_contextManager->getContextWithoutReportableStateProperties(requester, someOtherAgent);
+
+    const std::chrono::milliseconds timeout{100};
+    provideStateEventAllAgents.wait(timeout);
+    m_contextManager->provideStateResponse(capability2AllAgents, state2AllAgents, requestToken);
+
+    provideStateEventOtherAgents.wait(timeout);
+    m_contextManager->provideStateResponse(capability2OtherAgent, state2OtherAgent, requestToken);
+
+    auto statesFuture = contextStatesPromise.get_future();
+    ASSERT_EQ(statesFuture.wait_for(timeout), std::future_status::ready);
+
+    auto states = statesFuture.get();
+    EXPECT_EQ(states.find(capability1AlexaAgent), states.end());
+    EXPECT_EQ(states.find(capability2AlexaAgent), states.end());
+    EXPECT_EQ(states[capability2OtherAgent].valuePayload, state2OtherAgent.valuePayload);
+    EXPECT_EQ(states.find(capability1OtherAgent), states.end());
+    EXPECT_EQ(states[capability2AllAgents].valuePayload, state2AllAgents.valuePayload);
+    EXPECT_EQ(states.find(capability1AllAgents), states.end());
+
+    // check that when request context for AGENT_ID_ALL, it returns nothing
+    auto requesterAllAgents = std::make_shared<MockContextRequester>();
+    std::promise<AVSContext::States> contextStatesPromiseAllAgents;
+    EXPECT_CALL(*requesterAllAgents, onContextAvailable(_, _, _))
+        .WillOnce(WithArg<1>(Invoke([&contextStatesPromiseAllAgents](const AVSContext& context) {
+            contextStatesPromiseAllAgents.set_value(context.getStates());
+        })));
+    m_contextManager->getContextWithoutReportableStateProperties(
+        requesterAllAgents, avsCommon::avs::AgentId::AGENT_ID_ALL);
+
+    auto statesFutureAllAgent = contextStatesPromiseAllAgents.get_future();
+    ASSERT_EQ(statesFutureAllAgent.wait_for(timeout), std::future_status::ready);
+
+    auto statesAllAgent = statesFutureAllAgent.get();
+    EXPECT_EQ(statesAllAgent.find(capability1AlexaAgent), statesAllAgent.end());
+    EXPECT_EQ(statesAllAgent.find(capability2AlexaAgent), statesAllAgent.end());
+    EXPECT_EQ(statesAllAgent.find(capability1OtherAgent), statesAllAgent.end());
+    EXPECT_EQ(statesAllAgent.find(capability2OtherAgent), statesAllAgent.end());
+    EXPECT_EQ(statesAllAgent.find(capability1AllAgents), statesAllAgent.end());
+    EXPECT_EQ(statesAllAgent.find(capability2AllAgents), statesAllAgent.end());
+}
+
 }  // namespace test
 }  // namespace contextManager
 }  // namespace alexaClientSDK
diff --git a/Endpoints/include/Endpoints/DefaultEndpointBuilder.h b/Endpoints/include/Endpoints/DefaultEndpointBuilder.h
index 6c57aea1..280489e4 100644
--- a/Endpoints/include/Endpoints/DefaultEndpointBuilder.h
+++ b/Endpoints/include/Endpoints/DefaultEndpointBuilder.h
@@ -102,6 +102,7 @@ public:
     DefaultEndpointBuilder& withFriendlyName(const std::string& friendlyName) override;
     DefaultEndpointBuilder& withDescription(const std::string& description) override;
     DefaultEndpointBuilder& withManufacturerName(const std::string& manufacturerName) override;
+    DefaultEndpointBuilder& withEndpointResources(const avsCommon::avs::EndpointResources& endpointResources) override;
     DefaultEndpointBuilder& withDisplayCategory(const std::vector<std::string>& displayCategories) override;
     DefaultEndpointBuilder& withAdditionalAttributes(
         const std::string& manufacturer,
diff --git a/Endpoints/include/Endpoints/EndpointAttributeValidation.h b/Endpoints/include/Endpoints/EndpointAttributeValidation.h
index 74856249..e86f41b3 100644
--- a/Endpoints/include/Endpoints/EndpointAttributeValidation.h
+++ b/Endpoints/include/Endpoints/EndpointAttributeValidation.h
@@ -34,6 +34,14 @@ namespace endpoints {
  */
 bool isEndpointIdValid(const avsCommon::sdkInterfaces::endpoints::EndpointIdentifier& identifier);
 
+/**
+ * Returns whether the given endpointResources follows AVS specification.
+ *
+ * @param endpointResources The endpointResources to be validated.
+ * @return @c true if valid; otherwise, return @c false.
+ */
+bool isEndpointResourcesValid(const avsCommon::avs::EndpointResources& endpointResources);
+
 /**
  * Returns whether the given name follows AVS specification.
  *
diff --git a/Endpoints/include/Endpoints/EndpointBuilder.h b/Endpoints/include/Endpoints/EndpointBuilder.h
index 6eb57a10..ae07f90e 100644
--- a/Endpoints/include/Endpoints/EndpointBuilder.h
+++ b/Endpoints/include/Endpoints/EndpointBuilder.h
@@ -104,6 +104,8 @@ public:
     EndpointBuilder& withFriendlyName(const std::string& friendlyName) override;
     EndpointBuilder& withDescription(const std::string& description) override;
     EndpointBuilder& withManufacturerName(const std::string& manufacturerName) override;
+    EndpointBuilder& withEndpointResources(
+            const avsCommon::avs::EndpointResources& endpointResources) override;
     EndpointBuilder& withDisplayCategory(const std::vector<std::string>& displayCategories) override;
     EndpointBuilder& withAdditionalAttributes(
         const std::string& manufacturer,
@@ -209,6 +211,9 @@ private:
     /// rules apply differently.
     bool m_isDefaultEndpoint;
 
+    /// Flag used to indicate whether endpointResources is used.
+    bool m_isEndpointResourcesUsed;
+
     /// The client endpoint id that is used to build the default endpoint and generate derived endpoints.
     std::shared_ptr<avsCommon::utils::DeviceInfo> m_deviceInfo;
 
diff --git a/Endpoints/src/DefaultEndpointBuilder.cpp b/Endpoints/src/DefaultEndpointBuilder.cpp
index 7f566565..bc061a27 100644
--- a/Endpoints/src/DefaultEndpointBuilder.cpp
+++ b/Endpoints/src/DefaultEndpointBuilder.cpp
@@ -113,6 +113,12 @@ DefaultEndpointBuilder& DefaultEndpointBuilder::withManufacturerName(const std::
     return *this;
 }
 
+DefaultEndpointBuilder& DefaultEndpointBuilder::withEndpointResources(const avsCommon::avs::EndpointResources& endpointResources) {
+    ACSDK_DEBUG5(LX(__func__));
+    m_builder->withEndpointResources(endpointResources);
+    return *this;
+}
+
 DefaultEndpointBuilder& DefaultEndpointBuilder::withDisplayCategory(const std::vector<std::string>& displayCategories) {
     ACSDK_DEBUG5(LX(__func__));
     m_builder->withDisplayCategory(displayCategories);
diff --git a/Endpoints/src/EndpointAttributeValidation.cpp b/Endpoints/src/EndpointAttributeValidation.cpp
index c078d38f..5ced5929 100644
--- a/Endpoints/src/EndpointAttributeValidation.cpp
+++ b/Endpoints/src/EndpointAttributeValidation.cpp
@@ -29,6 +29,10 @@ bool isEndpointIdValid(const EndpointIdentifier& identifier) {
     return (length > 0) && (length <= AVSDiscoveryEndpointAttributes::MAX_ENDPOINT_IDENTIFIER_LENGTH);
 }
 
+bool isEndpointResourcesValid(const EndpointResources& endpointResources) {
+    return endpointResources.isValid();
+}
+
 bool isFriendlyNameValid(const std::string& name) {
     auto length = name.length();
     return (length > 0) && (length <= AVSDiscoveryEndpointAttributes::MAX_FRIENDLY_NAME_LENGTH);
diff --git a/Endpoints/src/EndpointBuilder.cpp b/Endpoints/src/EndpointBuilder.cpp
index ca2e6e29..fe92f735 100644
--- a/Endpoints/src/EndpointBuilder.cpp
+++ b/Endpoints/src/EndpointBuilder.cpp
@@ -110,6 +110,7 @@ EndpointBuilder::EndpointBuilder(
         m_hasBeenBuilt{false},
         m_invalidConfiguration{false},
         m_isDefaultEndpoint{false},
+        m_isEndpointResourcesUsed{false},
         m_deviceInfo{deviceInfo},
         m_contextManager{contextManager},
         m_exceptionSender{exceptionSender},
@@ -190,6 +191,18 @@ void EndpointBuilder::finalizeAttributes() {
     m_isConfigurationFinalized = true;
 }
 
+EndpointBuilder& EndpointBuilder::withEndpointResources(
+        const avsCommon::avs::EndpointResources& endpointResources) {
+    m_isEndpointResourcesUsed = true;
+    if (!isEndpointResourcesValid(endpointResources)){
+        ACSDK_ERROR(LX(__func__).d("reason", "invalidEndpointResources"));
+        m_invalidConfiguration = true;
+        return *this;
+    }
+    m_attributes.endpointResources = endpointResources;
+    return *this;
+}
+
 EndpointBuilder& EndpointBuilder::withFriendlyName(const std::string& friendlyName) {
     if (m_isConfigurationFinalized) {
         ACSDK_ERROR(LX(std::string(__func__) + "Failed").d("reason", "operationNotAllowed"));
@@ -551,7 +564,14 @@ std::unique_ptr<EndpointInterface> EndpointBuilder::buildImplementation() {
         return nullptr;
     }
 
-    if (!m_isDefaultEndpoint && !isFriendlyNameValid(m_attributes.friendlyName)) {
+    if (!m_isDefaultEndpoint && m_isEndpointResourcesUsed
+                             && !isEndpointResourcesValid(m_attributes.endpointResources)) {
+        ACSDK_ERROR(LX("buildFailed").d("reason", "invalidEndpointResources"));
+        return nullptr;
+    }
+
+    if (!m_isDefaultEndpoint && !m_isEndpointResourcesUsed
+                             && !isFriendlyNameValid(m_attributes.friendlyName)) {
         ACSDK_ERROR(
             LX("buildFailed").d("reason", "friendlyNameInvalid").sensitive("friendlyName", m_attributes.friendlyName));
         return nullptr;
diff --git a/Integration/include/Integration/AipStateObserver.h b/Integration/include/Integration/AipStateObserver.h
index 38378b7c..f946941c 100644
--- a/Integration/include/Integration/AipStateObserver.h
+++ b/Integration/include/Integration/AipStateObserver.h
@@ -29,7 +29,9 @@ namespace integration {
 class AipStateObserver : public avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface {
 public:
     AipStateObserver();
-    void onStateChanged(avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface::State newState) override;
+    void onStateChanged(
+        avsCommon::avs::AgentId::IdType agentId,
+        avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface::State newState) override;
     bool checkState(
         const avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface::State expectedState,
         const std::chrono::seconds duration = std::chrono::seconds(10));
diff --git a/Integration/include/Integration/ClientMessageHandler.h b/Integration/include/Integration/ClientMessageHandler.h
index 233b7ea1..ce12edc8 100644
--- a/Integration/include/Integration/ClientMessageHandler.h
+++ b/Integration/include/Integration/ClientMessageHandler.h
@@ -41,7 +41,8 @@ public:
      *
      * For the purposes of these integration tests, this function simply logs and counts messages.
      */
-    void receive(const std::string& contextId, const std::string& message) override;
+    void receive(avsCommon::avs::AgentId::IdType agentId, const std::string& contextId, const std::string& message)
+        override;
 
     /**
      * Wait for a message to be received.
diff --git a/Integration/include/Integration/TestExceptionEncounteredSender.h b/Integration/include/Integration/TestExceptionEncounteredSender.h
index 0df39f10..93f8b1aa 100644
--- a/Integration/include/Integration/TestExceptionEncounteredSender.h
+++ b/Integration/include/Integration/TestExceptionEncounteredSender.h
@@ -46,6 +46,12 @@ public:
         const std::string& unparsedDirective,
         avsCommon::avs::ExceptionErrorType error,
         const std::string& message) override;
+    void sendExceptionEncountered(
+        avsCommon::avs::AgentId::IdType agentId,
+        const std::string& unparsedDirective,
+        avs::ExceptionErrorType error,
+        const std::string& errorDescription) override;
+
     /**
      * Parse an @c AVSDirective from a JSON string.
      *
diff --git a/Integration/include/Integration/TestSpeechSynthesizerObserver.h b/Integration/include/Integration/TestSpeechSynthesizerObserver.h
index 56cb3a5d..c1003336 100644
--- a/Integration/include/Integration/TestSpeechSynthesizerObserver.h
+++ b/Integration/include/Integration/TestSpeechSynthesizerObserver.h
@@ -38,9 +38,7 @@ public:
 
     void onStateChanged(
         avsCommon::sdkInterfaces::SpeechSynthesizerObserverInterface::SpeechSynthesizerState state,
-        const avsCommon::utils::mediaPlayer::MediaPlayerInterface::SourceId mediaSourceId,
-        const avsCommon::utils::Optional<avsCommon::utils::mediaPlayer::MediaPlayerState>& mediaPlayerState,
-        const std::vector<avsCommon::utils::audioAnalyzer::AudioAnalyzerState>& audioAnalyzerState) override;
+        const Context& context) override;
 
     bool checkState(
         const avsCommon::sdkInterfaces::SpeechSynthesizerObserverInterface::SpeechSynthesizerState expectedState,
diff --git a/Integration/src/AipStateObserver.cpp b/Integration/src/AipStateObserver.cpp
index 012a0aa4..67ddd57a 100644
--- a/Integration/src/AipStateObserver.cpp
+++ b/Integration/src/AipStateObserver.cpp
@@ -23,7 +23,9 @@ using avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface;
 AipStateObserver::AipStateObserver() : m_state(AudioInputProcessorObserverInterface::State::IDLE) {
 }
 
-void AipStateObserver::onStateChanged(AudioInputProcessorObserverInterface::State newState) {
+void AipStateObserver::onStateChanged(
+    avsCommon::avs::AgentId::IdType agentId,
+    AudioInputProcessorObserverInterface::State newState) {
     std::unique_lock<std::mutex> lock(m_mutex);
     m_queue.push_back(newState);
     m_state = newState;
diff --git a/Integration/src/ClientMessageHandler.cpp b/Integration/src/ClientMessageHandler.cpp
index c6fd245f..451525c1 100644
--- a/Integration/src/ClientMessageHandler.cpp
+++ b/Integration/src/ClientMessageHandler.cpp
@@ -26,7 +26,10 @@ ClientMessageHandler::ClientMessageHandler(std::shared_ptr<AttachmentManager> at
         m_attachmentManager{attachmentManager} {
 }
 
-void ClientMessageHandler::receive(const std::string& contextId, const std::string& message) {
+void ClientMessageHandler::receive(
+    avsCommon::avs::AgentId::IdType agentId,
+    const std::string& contextId,
+    const std::string& message) {
     std::cout << "ClientMessageHandler::receive: message:" << message << std::endl;
     std::unique_lock<std::mutex> lock(m_mutex);
     ++m_count;
diff --git a/Integration/src/TestExceptionEncounteredSender.cpp b/Integration/src/TestExceptionEncounteredSender.cpp
index e0b558d8..af0c459a 100644
--- a/Integration/src/TestExceptionEncounteredSender.cpp
+++ b/Integration/src/TestExceptionEncounteredSender.cpp
@@ -55,6 +55,24 @@ void TestExceptionEncounteredSender::sendExceptionEncountered(
     m_queue.push_back(dp);
     m_wakeTrigger.notify_all();
 }
+void TestExceptionEncounteredSender::sendExceptionEncountered(
+    avsCommon::avs::AgentId::IdType agentId,
+    const std::string& unparsedDirective,
+    avs::ExceptionErrorType error,
+    const std::string& message) {
+    std::unique_lock<std::mutex> lock(m_mutex);
+    ExceptionParams dp;
+    dp.type = ExceptionParams::Type::EXCEPTION;
+    dp.directive = parseDirective(
+        unparsedDirective,
+        std::make_shared<avsCommon::avs::attachment::AttachmentManager>(
+            avsCommon::avs::attachment::AttachmentManager::AttachmentType::IN_PROCESS));
+    dp.exceptionUnparsedDirective = unparsedDirective;
+    dp.exceptionError = error;
+    dp.exceptionMessage = message;
+    m_queue.push_back(dp);
+    m_wakeTrigger.notify_all();
+}
 
 std::shared_ptr<avsCommon::avs::AVSDirective> TestExceptionEncounteredSender::parseDirective(
     const std::string& rawJSON,
diff --git a/Integration/src/TestSpeechSynthesizerObserver.cpp b/Integration/src/TestSpeechSynthesizerObserver.cpp
index a2efec6d..3092ce82 100644
--- a/Integration/src/TestSpeechSynthesizerObserver.cpp
+++ b/Integration/src/TestSpeechSynthesizerObserver.cpp
@@ -27,9 +27,7 @@ TestSpeechSynthesizerObserver::TestSpeechSynthesizerObserver() :
 
 void TestSpeechSynthesizerObserver::onStateChanged(
     SpeechSynthesizerObserverInterface::SpeechSynthesizerState state,
-    const avsCommon::utils::mediaPlayer::MediaPlayerInterface::SourceId mediaSourceId,
-    const avsCommon::utils::Optional<avsCommon::utils::mediaPlayer::MediaPlayerState>& mediaPlayerState,
-    const std::vector<avsCommon::utils::audioAnalyzer::AudioAnalyzerState>& audioAnalyzerState) {
+    const Context& context) {
     std::unique_lock<std::mutex> lock(m_mutex);
     m_state = state;
     m_queue.push_back(state);
diff --git a/Integration/test/AlertsIntegrationTest.cpp b/Integration/test/AlertsIntegrationTest.cpp
index b9e276df..75cf3b49 100644
--- a/Integration/test/AlertsIntegrationTest.cpp
+++ b/Integration/test/AlertsIntegrationTest.cpp
@@ -31,11 +31,11 @@
 #include <AFML/FocusManager.h>
 #include <AIP/AudioInputProcessor.h>
 #include <AIP/AudioProvider.h>
-#include <AIP/Initiator.h>
 #include <acsdkAlerts/AlertsCapabilityAgent.h>
 #include <acsdkAlerts/Storage/SQLiteAlertStorage.h>
 #include <Audio/AlertsAudioFactory.h>
 #include <Audio/SystemSoundAudioFactory.h>
+#include <AVSCommon/AVS/AgentInitiator.h>
 #include <AVSCommon/AVS/Attachment/InProcessAttachmentReader.h>
 #include <AVSCommon/AVS/CapabilityChangeNotifier.h>
 #include <AVSCommon/SDKInterfaces/MockLocaleAssetsManager.h>
@@ -258,7 +258,7 @@ private:
 class holdToTalkButton {
 public:
     bool startRecognizing(std::shared_ptr<AudioInputProcessor> aip, std::shared_ptr<AudioProvider> audioProvider) {
-        return aip->recognize(*audioProvider, Initiator::PRESS_AND_HOLD).get();
+        return aip->recognize(*audioProvider, AgentInitiator::PRESS_AND_HOLD).get();
     }
 
     bool stopRecognizing(std::shared_ptr<AudioInputProcessor> aip) {
diff --git a/Integration/test/AudioInputProcessorIntegrationTest.cpp b/Integration/test/AudioInputProcessorIntegrationTest.cpp
index d1743ae9..4c673d55 100644
--- a/Integration/test/AudioInputProcessorIntegrationTest.cpp
+++ b/Integration/test/AudioInputProcessorIntegrationTest.cpp
@@ -33,8 +33,8 @@
 #include <AFML/FocusManager.h>
 #include <AIP/AudioInputProcessor.h>
 #include <AIP/AudioProvider.h>
-#include <AIP/Initiator.h>
 #include <Audio/SystemSoundAudioFactory.h>
+#include <AVSCommon/AVS/AgentInitiator.h>
 #include <AVSCommon/AVS/Attachment/InProcessAttachmentWriter.h>
 #include <AVSCommon/AVS/BlockingPolicy.h>
 #include <AVSCommon/AVS/CapabilityChangeNotifier.h>
@@ -222,14 +222,14 @@ static std::string g_inputPath;
 class tapToTalkButton {
 public:
     bool startRecognizing(std::shared_ptr<AudioInputProcessor> aip, std::shared_ptr<AudioProvider> audioProvider) {
-        return aip->recognize(*audioProvider, Initiator::TAP).get();
+        return aip->recognize(*audioProvider, AgentInitiator::TAP).get();
     }
 };
 
 class holdToTalkButton {
 public:
     bool startRecognizing(std::shared_ptr<AudioInputProcessor> aip, std::shared_ptr<AudioProvider> audioProvider) {
-        return aip->recognize(*audioProvider, Initiator::PRESS_AND_HOLD).get();
+        return aip->recognize(*audioProvider, AgentInitiator::PRESS_AND_HOLD).get();
     }
 
     bool stopRecognizing(std::shared_ptr<AudioInputProcessor> aip) {
diff --git a/Integration/test/AudioPlayerIntegrationTest.cpp b/Integration/test/AudioPlayerIntegrationTest.cpp
index bd3d00f8..05d74d3f 100644
--- a/Integration/test/AudioPlayerIntegrationTest.cpp
+++ b/Integration/test/AudioPlayerIntegrationTest.cpp
@@ -29,9 +29,9 @@
 #include <AFML/FocusManager.h>
 #include <AIP/AudioInputProcessor.h>
 #include <AIP/AudioProvider.h>
-#include <AIP/Initiator.h>
 #include <acsdkAudioPlayer/AudioPlayer.h>
 #include <Audio/SystemSoundAudioFactory.h>
+#include <AVSCommon/AVS/AgentInitiator.h>
 #include <AVSCommon/AVS/Attachment/InProcessAttachmentWriter.h>
 #include <AVSCommon/AVS/CapabilityChangeNotifier.h>
 #include <AVSCommon/Utils/JSON/JSONUtils.h>
@@ -49,6 +49,7 @@
 
 #include <PlaybackController/PlaybackController.h>
 #include <PlaybackController/PlaybackRouter.h>
+#include <RegistrationManager/CustomerDataManagerFactory.h>
 #include <SpeechSynthesizer/SpeechSynthesizer.h>
 #include <System/UserInactivityMonitor.h>
 #include <Settings/MockSetting.h>
@@ -249,7 +250,7 @@ private:
 class holdToTalkButton {
 public:
     bool startRecognizing(std::shared_ptr<AudioInputProcessor> aip, std::shared_ptr<AudioProvider> audioProvider) {
-        return aip->recognize(*audioProvider, Initiator::PRESS_AND_HOLD).get();
+        return aip->recognize(*audioProvider, AgentInitiator::PRESS_AND_HOLD).get();
     }
 
     bool stopRecognizing(std::shared_ptr<AudioInputProcessor> aip) {
@@ -294,6 +295,7 @@ protected:
 
         m_playbackController = PlaybackController::create(m_context->getContextManager(), m_avsConnectionManager);
         m_playbackRouter = PlaybackRouter::create(m_playbackController);
+        m_customerDataManager = registrationManager::CustomerDataManagerFactory::createCustomerDataManagerInterface();
         m_speakerInterface = std::make_shared<testing::NiceMock<MockChannelVolumeInterface>>();
 
 #ifdef GSTREAMER_MEDIA_PLAYER
@@ -403,6 +405,7 @@ protected:
             m_context->getContextManager(),
             m_exceptionEncounteredSender,
             m_playbackRouter,
+            m_customerDataManager,
             m_captionManager,
             m_metricRecorder);
         ASSERT_NE(nullptr, m_audioPlayer);
@@ -554,6 +557,7 @@ protected:
     std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
     std::shared_ptr<PlaybackController> m_playbackController;
     std::shared_ptr<PlaybackRouter> m_playbackRouter;
+    std::shared_ptr<registrationManager::CustomerDataManagerInterface> m_customerDataManager;
     std::shared_ptr<MockChannelVolumeInterface> m_speakerInterface;
     std::shared_ptr<TestDirectiveHandler> m_directiveHandler;
     std::shared_ptr<DirectiveSequencerInterface> m_directiveSequencer;
diff --git a/Integration/test/CMakeLists.txt b/Integration/test/CMakeLists.txt
index 81f71949..f71f005e 100644
--- a/Integration/test/CMakeLists.txt
+++ b/Integration/test/CMakeLists.txt
@@ -24,6 +24,7 @@ set(LINK_PATH ACL
         ADSL
         AFML
         AIP
+        acsdkDUXSA
         AVSSystem
         CBLAuthDelegate
         ContextManager
diff --git a/Metrics/UplCalculator/CMakeLists.txt b/Metrics/UplCalculator/CMakeLists.txt
index 9b3674e3..a8ee9904 100644
--- a/Metrics/UplCalculator/CMakeLists.txt
+++ b/Metrics/UplCalculator/CMakeLists.txt
@@ -3,4 +3,5 @@ project(UplCalculator LANGUAGES CXX)
 
 include(${AVS_CMAKE_BUILD}/BuildDefaults.cmake)
 
-add_subdirectory("src")
\ No newline at end of file
+add_subdirectory("src")
+add_subdirectory("test")
\ No newline at end of file
diff --git a/Metrics/UplCalculator/include/Metrics/BaseUplCalculator.h b/Metrics/UplCalculator/include/Metrics/BaseUplCalculator.h
index d220dd76..2d35e56d 100644
--- a/Metrics/UplCalculator/include/Metrics/BaseUplCalculator.h
+++ b/Metrics/UplCalculator/include/Metrics/BaseUplCalculator.h
@@ -97,16 +97,20 @@ public:
 
     /**
      * Returns the pointer to the collected UplData
-     *
+     * @param uplCalculatorContext the context for a specific instance of uplData
      * @returns @c UplData
      */
-    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> getUplData() const;
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> getUplData(
+        const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext) const override;
 
     /// @name Overridden UplCaclulatorInterface method.
     /// @{
     void inspectMetric(
         const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::MetricEvent>& metricEvent) override;
-    void setUplData(const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData) override;
+    void addUplData(
+        const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData,
+        const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext) override;
+
     /// @}
 
 private:
@@ -117,14 +121,16 @@ private:
 
     /**
      * Stops the UPL Calculator from further recording metrics
+     * @param uplCalculatorContext the context for a specific instance of uplData for which to stop recording metrics
      */
-    void inhibitSubmission();
+    void inhibitSubmission(const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext);
 
     /// Initial time point to check for UPL timeout
     std::chrono::steady_clock::time_point m_startTime;
 
     /// Stop UPL calculations for unwanted cases
-    bool m_uplInhibited;
+    std::unordered_map<alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext, bool>
+        m_UPLCalculatorContextToUPLInhibitedFlagMap;
 };
 
 }  // namespace implementations
diff --git a/Metrics/UplCalculator/include/Metrics/MediaUplCalculator.h b/Metrics/UplCalculator/include/Metrics/MediaUplCalculator.h
index 1ca46917..4b7d50e2 100644
--- a/Metrics/UplCalculator/include/Metrics/MediaUplCalculator.h
+++ b/Metrics/UplCalculator/include/Metrics/MediaUplCalculator.h
@@ -51,16 +51,20 @@ public:
 
     /**
      * Returns the pointer to the collected UplData
-     *
+     * @param uplCalculatorContext the context for a specific instance of uplData
      * @returns @c UplData
      */
-    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> getUplData() const;
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> getUplData(
+        const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext) const override;
 
     /// @name Overridden UplCaclulatorInterface method.
     /// @{
     void inspectMetric(
         const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::MetricEvent>& metricEvent) override;
-    void setUplData(const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData) override;
+    void addUplData(
+        const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData,
+        const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext) override;
+
     /// @}
 private:
     /// Types of Media UPL
@@ -85,12 +89,14 @@ private:
      * Add a time-span metric from two time points in the UplData time points map
      *
      * @param metricEventBuilder the builder to add the time-span to.
+     * @param uplData the upl data from which to get the timepoint data
      * @param name of the upl metric.
      * @param startTimepointName the name of the start timepoint
      * @param endTimepointName the name of the end timepoint
      */
     void addDuration(
         alexaClientSDK::avsCommon::utils::metrics::MetricEventBuilder& metricEventBuilder,
+        const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData,
         const std::string& name,
         const std::string& startTimepointName,
         const std::string& endTimepointName);
@@ -111,23 +117,29 @@ private:
 
     /**
      * Adjust the given timepoint to remove the TTS duration from UPL
-     *
+     * @param uplData the upl data for which to adjust the time point
      * @param timepoint the time point to adjust
      * @return the adjusted time point
      */
-    UplTimePoint getTimePointAdjustedForTtsDuration(const UplTimePoint& timepoint) const;
+    UplTimePoint getTimePointAdjustedForTtsDuration(
+        const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData,
+        const UplTimePoint& timepoint) const;
 
     /**
      * Calculate the Media player UPL from the recorded time points
      *
      * @param type Type of Media UPL to calculate
      */
-    void calculateMediaUpl(MediaUplType type);
+    void calculateMediaUpl(
+        const avsCommon::utils::metrics::MetricContext& metricContext,
+        const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData,
+        MediaUplType type);
 
     /**
      * Stops the UPL Calculator from further recording or submitting metrics
+     * @param uplCalculatorContext the context for a specific instance of uplData for which to stop recording metrics
      */
-    void inhibitSubmission();
+    void inhibitSubmission(const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext);
 
     /// MetricRecorder to publish UPL metrics.
     std::weak_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
@@ -139,7 +151,8 @@ private:
     UplTimePoint m_ttsFinished;
 
     /// Stop UPL calculations for unwanted cases
-    bool m_uplInhibited;
+    std::unordered_map<alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext, bool>
+        m_UPLCalculatorContextToUPLInhibitedFlagMap;
 };
 
 }  // namespace implementations
diff --git a/Metrics/UplCalculator/include/Metrics/TtsUplCalculator.h b/Metrics/UplCalculator/include/Metrics/TtsUplCalculator.h
index 75a92dd3..209ff4a5 100644
--- a/Metrics/UplCalculator/include/Metrics/TtsUplCalculator.h
+++ b/Metrics/UplCalculator/include/Metrics/TtsUplCalculator.h
@@ -46,16 +46,19 @@ public:
 
     /**
      * Returns the pointer to the collected UplData
-     *
+     * @param uplCalculatorContext the context for the instance of collected uplData
      * @returns @c UplData
      */
-    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> getUplData() const;
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> getUplData(
+        const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext) const override;
 
     /// @name Overridden UplCaclulatorInterface method.
     /// @{
     void inspectMetric(
         const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::MetricEvent>& metricEvent) override;
-    void setUplData(const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData) override;
+    void addUplData(
+        const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData,
+        const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext) override;
     /// @}
 private:
     /**
@@ -70,12 +73,14 @@ private:
      * Add a time-span metric from two timepoints in the UplData time points map
      *
      * @param metricEventBuilder the builder to add the time-span to.
+     * @param uplData the uplData for a specific agent
      * @param name of the upl metric.
      * @param startTimepointName the name of the start timepoint
      * @param endTimepointName the name of the end timepoint
      */
     void addDuration(
         alexaClientSDK::avsCommon::utils::metrics::MetricEventBuilder& metricEventBuilder,
+        const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData,
         const std::string& name,
         const std::string& startTimepointName,
         const std::string& endTimepointName);
@@ -83,18 +88,22 @@ private:
     /**
      * Calculate the TTS UPL from the recorded time points
      */
-    void calculateTtsUpl();
+    void calculateTtsUpl(
+        const avsCommon::utils::metrics::MetricContext& metricContext,
+        const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData);
 
     /**
      * Stops the UPL Calculator from further recording or submitting metrics
+     * @param uplCalculatorContext the context for a specific instance of uplData for which to stop recording metrics
      */
-    void inhibitSubmission();
+    void inhibitSubmission(const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext);
 
     /// MetricRecorder to publish UPL metrics.
     std::weak_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
 
     /// Stop UPL calculations for unwanted cases
-    bool m_uplInhibited;
+    std::unordered_map<alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext, bool>
+        m_UPLCalculatorContextToUPLInhibitedFlagMap;
 };
 
 }  // namespace implementations
diff --git a/Metrics/UplCalculator/src/BaseUplCalculator.cpp b/Metrics/UplCalculator/src/BaseUplCalculator.cpp
index 86f62e5d..48708f4d 100644
--- a/Metrics/UplCalculator/src/BaseUplCalculator.cpp
+++ b/Metrics/UplCalculator/src/BaseUplCalculator.cpp
@@ -15,6 +15,7 @@
 
 #include <AVSCommon/Utils/Logger/Logger.h>
 #include <AVSCommon/Utils/Metrics/DataType.h>
+#include <AVSCommon/Utils/Metrics/Utils.h>
 
 #include "Metrics/BaseUplCalculator.h"
 
@@ -39,7 +40,7 @@ std::unique_ptr<avsCommon::utils::metrics::UplCalculatorInterface> BaseUplCalcul
     return std::unique_ptr<avsCommon::utils::metrics::UplCalculatorInterface>(new BaseUplCalculator());
 }
 
-BaseUplCalculator::BaseUplCalculator() : m_startTime(), m_uplInhibited(false) {
+BaseUplCalculator::BaseUplCalculator() : m_startTime() {
 }
 
 void BaseUplCalculator::inspectMetric(
@@ -49,18 +50,34 @@ void BaseUplCalculator::inspectMetric(
         return;
     }
 
-    if (m_uplInhibited) {
+    auto metricContext = metricEvent->getMetricContext();
+    auto uplCalculatorContext = createUPLCalculatorContext(metricContext);
+    auto uplInhibitedFlagFound = m_UPLCalculatorContextToUPLInhibitedFlagMap.find(uplCalculatorContext);
+    bool uplInhibited = false;
+
+    if (uplInhibitedFlagFound != m_UPLCalculatorContextToUPLInhibitedFlagMap.end()) {
+        uplInhibited = uplInhibitedFlagFound->second;
+    }
+
+    if (uplInhibited) {
+        return;
+    }
+
+    auto uplDataFound = m_UPLCalculatorContextToUPLdataMap.find(uplCalculatorContext);
+
+    if (uplDataFound == m_UPLCalculatorContextToUPLdataMap.end()) {
         return;
     }
+    auto uplData = uplDataFound->second;
 
-    if (!m_uplData) {
+    if (!uplData) {
         return;
     }
 
     if (m_startTime.time_since_epoch() == std::chrono::steady_clock::duration::zero()) {
         m_startTime = std::chrono::steady_clock::now();
     } else if (std::chrono::steady_clock::now() - m_startTime > METRIC_RECORD_TIMEOUT) {
-        inhibitSubmission();
+        inhibitSubmission(uplCalculatorContext);
         return;
     }
 
@@ -71,38 +88,38 @@ void BaseUplCalculator::inspectMetric(
     std::getline(ss, metricName);
 
     if (START_OF_UTTERANCE == metricName) {
-        m_uplData->addTimepoint(metricName, metricEvent->getSteadyTimestamp());
+        uplData->addTimepoint(metricName, metricEvent->getSteadyTimestamp());
         std::string dialogID;
         if (getMetricTag(metricName, metricEvent, DIALOG_REQUEST_ID_TAG, dialogID)) {
-            m_uplData->addStringData(DIALOG_REQUEST_ID_TAG, dialogID);
+            uplData->addStringData(DIALOG_REQUEST_ID_TAG, dialogID);
         }
     } else if (WW_DURATION == metricName) {
         std::chrono::milliseconds startOfStreamTimestamp;
         if (getDuration(START_OF_STREAM_TIMESTAMP, metricEvent, startOfStreamTimestamp)) {
             // Sends a warning since it overwrites previous START_OF_UTTERANCE
-            m_uplData->addTimepoint(START_OF_UTTERANCE, UplTimePoint(startOfStreamTimestamp));
+            uplData->addTimepoint(START_OF_UTTERANCE, UplTimePoint(startOfStreamTimestamp));
         } else {
             ACSDK_ERROR(
                 LX("inspectMetricFailed").d("reason", "missing START_OF_STREAM_TIMESTAMP").d("metricName", metricName));
         }
     } else if (STOP_CAPTURE == metricName) {
-        m_uplData->addTimepoint(metricName, metricEvent->getSteadyTimestamp());
+        uplData->addTimepoint(metricName, metricEvent->getSteadyTimestamp());
     } else if (END_OF_SPEECH_OFFSET == metricName) {
         std::chrono::milliseconds duration;
         if (getDuration(metricName, metricEvent, duration)) {
-            UplTimePoint startOfUtterance = m_uplData->getTimepoint(START_OF_UTTERANCE);
+            UplTimePoint startOfUtterance = uplData->getTimepoint(START_OF_UTTERANCE);
             UplTimePoint endOfUtterance = startOfUtterance + duration;
-            m_uplData->addTimepoint(END_OF_UTTERANCE, endOfUtterance);
+            uplData->addTimepoint(END_OF_UTTERANCE, endOfUtterance);
         }
     } else if (PARSE_COMPLETE == metricName) {
         std::string directiveId;
         if (getMetricTag(metricName, metricEvent, DIRECTIVE_MESSAGE_ID_TAG, directiveId)) {
-            m_uplData->addParseCompleteTimepoint(directiveId, metricEvent->getSteadyTimestamp());
+            uplData->addParseCompleteTimepoint(directiveId, metricEvent->getSteadyTimestamp());
         }
     } else if (DIRECTIVE_DISPATCHED_HANDLE == metricName || DIRECTIVE_DISPATCHED_IMMEDIATE == metricName) {
         std::string directiveId;
         if (getMetricTag(metricName, metricEvent, DIRECTIVE_MESSAGE_ID_TAG, directiveId)) {
-            m_uplData->addDirectiveDispatchedTimepoint(directiveId, metricEvent->getSteadyTimestamp());
+            uplData->addDirectiveDispatchedTimepoint(directiveId, metricEvent->getSteadyTimestamp());
         }
     }  // else, metricName doesn't match any monitored metric names, do nothing
 }
@@ -157,16 +174,51 @@ bool BaseUplCalculator::getDuration(
     return true;
 }
 
-void BaseUplCalculator::setUplData(const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData) {
-    m_uplData = uplData;
+void BaseUplCalculator::addUplData(
+    const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData,
+    const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext) {
+    auto uplDataFound = m_UPLCalculatorContextToUPLdataMap.find(uplCalculatorContext);
+
+    if (uplDataFound == m_UPLCalculatorContextToUPLdataMap.end()) {
+        m_UPLCalculatorContextToUPLdataMap.insert({uplCalculatorContext, uplData});
+    } else {
+        uplDataFound->second = uplData;
+    }
+    // Reset inhibited flag because addUplData is only called at the start of a new utterance
+    auto uplInhibitedFlagFound = m_UPLCalculatorContextToUPLInhibitedFlagMap.find(uplCalculatorContext);
+    if (uplInhibitedFlagFound == m_UPLCalculatorContextToUPLInhibitedFlagMap.end()) {
+        m_UPLCalculatorContextToUPLInhibitedFlagMap.insert({uplCalculatorContext, false});
+    } else {
+        uplInhibitedFlagFound->second = false;
+    }
+    // Reset startTime for the new utterance
+    m_startTime = std::chrono::steady_clock::time_point();
 }
 
-std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> BaseUplCalculator::getUplData() const {
-    return m_uplData;
+std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> BaseUplCalculator::getUplData(
+    const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext) const {
+    auto uplDataFound = m_UPLCalculatorContextToUPLdataMap.find(uplCalculatorContext);
+
+    if (uplDataFound == m_UPLCalculatorContextToUPLdataMap.end()) {
+        return nullptr;
+    }
+    auto uplData = uplDataFound->second;
+
+    if (!uplData) {
+        return nullptr;
+    }
+
+    return uplData;
 }
 
-void BaseUplCalculator::inhibitSubmission() {
-    m_uplInhibited = true;
+void BaseUplCalculator::inhibitSubmission(
+    const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext) {
+    auto uplInhibitedFlagFound = m_UPLCalculatorContextToUPLInhibitedFlagMap.find(uplCalculatorContext);
+    if (uplInhibitedFlagFound == m_UPLCalculatorContextToUPLInhibitedFlagMap.end()) {
+        m_UPLCalculatorContextToUPLInhibitedFlagMap.insert({uplCalculatorContext, true});
+    } else {
+        uplInhibitedFlagFound->second = true;
+    }
 }
 
 }  // namespace implementations
diff --git a/Metrics/UplCalculator/src/MediaUplCalculator.cpp b/Metrics/UplCalculator/src/MediaUplCalculator.cpp
index 1817b390..7106d62e 100644
--- a/Metrics/UplCalculator/src/MediaUplCalculator.cpp
+++ b/Metrics/UplCalculator/src/MediaUplCalculator.cpp
@@ -20,6 +20,7 @@
 #include <AVSCommon/Utils/Metrics/DataPointDurationBuilder.h>
 #include <AVSCommon/Utils/Metrics/DataPointStringBuilder.h>
 #include <AVSCommon/Utils/Metrics/MetricEventBuilder.h>
+#include <AVSCommon/Utils/Metrics/Utils.h>
 #include <Metrics/BaseUplCalculator.h>
 
 #include "Metrics/MediaUplCalculator.h"
@@ -80,8 +81,7 @@ MediaUplCalculator::MediaUplCalculator(
     std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder) :
         m_metricRecorder(metricRecorder),
         m_ttsStarted(),
-        m_ttsFinished(),
-        m_uplInhibited(false) {
+        m_ttsFinished() {
 }
 
 void MediaUplCalculator::inspectMetric(
@@ -91,11 +91,27 @@ void MediaUplCalculator::inspectMetric(
         return;
     }
 
-    if (m_uplInhibited) {
+    auto metricContext = metricEvent->getMetricContext();
+    auto uplCalculatorContext = createUPLCalculatorContext(metricContext);
+    auto uplInhibitedFlagFound = m_UPLCalculatorContextToUPLInhibitedFlagMap.find(uplCalculatorContext);
+    bool uplInhibited = false;
+
+    if (uplInhibitedFlagFound != m_UPLCalculatorContextToUPLInhibitedFlagMap.end()) {
+        uplInhibited = uplInhibitedFlagFound->second;
+    }
+
+    if (uplInhibited) {
         return;
     }
 
-    if (!m_uplData) {
+    auto uplDataFound = m_UPLCalculatorContextToUPLdataMap.find(uplCalculatorContext);
+
+    if (uplDataFound == m_UPLCalculatorContextToUPLdataMap.end()) {
+        return;
+    }
+    auto uplData = uplDataFound->second;
+
+    if (!uplData) {
         return;
     }
 
@@ -110,7 +126,7 @@ void MediaUplCalculator::inspectMetric(
         // by subtracting from the media player metrics after PARSE_COMPLETE
         std::string dialogRequestId;
         if (BaseUplCalculator::getMetricTag(metricName, metricEvent, DIALOG_REQUEST_ID_TAG, dialogRequestId)) {
-            if (dialogRequestId == m_uplData->getStringData(DIALOG_REQUEST_ID_TAG)) {
+            if (dialogRequestId == uplData->getStringData(DIALOG_REQUEST_ID_TAG)) {
                 if (TTS_STARTED == metricName) {
                     m_ttsStarted = metricEvent->getSteadyTimestamp();
                 } else {  // TTS_FINISHED == metricName
@@ -125,49 +141,77 @@ void MediaUplCalculator::inspectMetric(
             // point to start calculating from, and the current calculator will start from the last utterance
             // which is not related to the music alarm.
             if (requesterType == "ALERT") {
-                inhibitSubmission();
+                inhibitSubmission(uplCalculatorContext);
                 return;
             }
         }
 
-        m_uplData->addTimepoint(metricName, metricEvent->getSteadyTimestamp());
+        uplData->addTimepoint(metricName, metricEvent->getSteadyTimestamp());
         std::string directiveId;
         if (BaseUplCalculator::getMetricTag(metricName, metricEvent, DIRECTIVE_MESSAGE_ID_TAG, directiveId)) {
-            m_uplData->addTimepoint(MEDIA_DIRECTIVE_PARSED, m_uplData->getParseCompleteTimepoint(directiveId));
-            m_uplData->addTimepoint(
-                MEDIA_DIRECTIVE_DISPATCHED, m_uplData->getDirectiveDispatchedTimepoint(directiveId));
+            uplData->addTimepoint(MEDIA_DIRECTIVE_PARSED, uplData->getParseCompleteTimepoint(directiveId));
+            uplData->addTimepoint(MEDIA_DIRECTIVE_DISPATCHED, uplData->getDirectiveDispatchedTimepoint(directiveId));
         }
     } else if (PLAYBACK_STOPPED == metricName) {
-        m_uplData->addTimepoint(metricName, metricEvent->getSteadyTimestamp());
-        calculateMediaUpl(MediaUplType::STOP);
+        uplData->addTimepoint(metricName, metricEvent->getSteadyTimestamp());
+        calculateMediaUpl(metricContext, uplData, MediaUplType::STOP);
     } else if (PLAYBACK_STARTED == metricName) {
-        m_uplData->addTimepoint(metricName, metricEvent->getSteadyTimestamp());
+        uplData->addTimepoint(metricName, metricEvent->getSteadyTimestamp());
 
         if (m_ttsStarted.time_since_epoch() == std::chrono::steady_clock::duration::zero() ||
             m_ttsFinished.time_since_epoch() == std::chrono::steady_clock::duration::zero()) {
-            calculateMediaUpl(MediaUplType::PLAY);
+            calculateMediaUpl(metricContext, uplData, MediaUplType::PLAY);
         } else {
-            calculateMediaUpl(MediaUplType::PLAY_AFTER_TTS);
+            calculateMediaUpl(metricContext, uplData, MediaUplType::PLAY_AFTER_TTS);
         }
     }  // else,  doesn't match any monitored metric names, do nothing
 }
 
-void MediaUplCalculator::setUplData(
-    const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData) {
-    m_uplData = uplData;
+void MediaUplCalculator::addUplData(
+    const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData,
+    const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext) {
+    auto uplDataFound = m_UPLCalculatorContextToUPLdataMap.find(uplCalculatorContext);
+
+    if (uplDataFound == m_UPLCalculatorContextToUPLdataMap.end()) {
+        m_UPLCalculatorContextToUPLdataMap.insert({uplCalculatorContext, uplData});
+    } else {
+        uplDataFound->second = uplData;
+    }
+    // Reset inhibited flag because addUplData is only called at the start of a new utterance
+    auto uplInhibitedFlagFound = m_UPLCalculatorContextToUPLInhibitedFlagMap.find(uplCalculatorContext);
+    if (uplInhibitedFlagFound == m_UPLCalculatorContextToUPLInhibitedFlagMap.end()) {
+        m_UPLCalculatorContextToUPLInhibitedFlagMap.insert({uplCalculatorContext, false});
+    } else {
+        uplInhibitedFlagFound->second = false;
+    }
+    // Reset timepoints for the new utterance
+    m_ttsStarted = m_ttsFinished = std::chrono::steady_clock::time_point();
 }
 
-std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> MediaUplCalculator::getUplData() const {
-    return m_uplData;
+std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> MediaUplCalculator::getUplData(
+    const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext) const {
+    auto uplDataFound = m_UPLCalculatorContextToUPLdataMap.find(uplCalculatorContext);
+
+    if (uplDataFound == m_UPLCalculatorContextToUPLdataMap.end()) {
+        return nullptr;
+    }
+    auto uplData = uplDataFound->second;
+
+    if (!uplData) {
+        return nullptr;
+    }
+
+    return uplData;
 }
 
 void MediaUplCalculator::addDuration(
     alexaClientSDK::avsCommon::utils::metrics::MetricEventBuilder& metricEventBuilder,
+    const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData,
     const std::string& name,
     const std::string& startTimepointName,
     const std::string& endTimepointName) {
-    UplTimePoint startTimepoint = m_uplData->getTimepoint(startTimepointName);
-    UplTimePoint endTimepoint = m_uplData->getTimepoint(endTimepointName);
+    UplTimePoint startTimepoint = uplData->getTimepoint(startTimepointName);
+    UplTimePoint endTimepoint = uplData->getTimepoint(endTimepointName);
 
     addDuration(metricEventBuilder, name, startTimepoint, endTimepoint);
 }
@@ -207,8 +251,9 @@ void MediaUplCalculator::addDuration(
 }
 
 MediaUplCalculator::UplTimePoint MediaUplCalculator::getTimePointAdjustedForTtsDuration(
+    const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData,
     const UplTimePoint& timepoint) const {
-    UplTimePoint parseCompleteTimePoint = m_uplData->getTimepoint(MEDIA_DIRECTIVE_PARSED);
+    UplTimePoint parseCompleteTimePoint = uplData->getTimepoint(MEDIA_DIRECTIVE_PARSED);
     UplTimePoint startAdjustmentTimePoint =
         m_ttsStarted > parseCompleteTimePoint ? m_ttsStarted : parseCompleteTimePoint;
 
@@ -228,60 +273,92 @@ MediaUplCalculator::UplTimePoint MediaUplCalculator::getTimePointAdjustedForTtsD
     return timepoint;
 }
 
-void MediaUplCalculator::calculateMediaUpl(MediaUplType type) {
-    if (m_uplInhibited) {
+void MediaUplCalculator::calculateMediaUpl(
+    const avsCommon::utils::metrics::MetricContext& metricContext,
+    const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData,
+    MediaUplType type) {
+    auto uplCalculatorContext = createUPLCalculatorContext(metricContext);
+    auto uplInhibitedFlagFound = m_UPLCalculatorContextToUPLInhibitedFlagMap.find(uplCalculatorContext);
+    bool uplInhibited = false;
+
+    if (uplInhibitedFlagFound != m_UPLCalculatorContextToUPLInhibitedFlagMap.end()) {
+        uplInhibited = uplInhibitedFlagFound->second;
+    }
+
+    if (uplInhibited) {
         return;
     }
 
-    auto metricEventBuilder = alexaClientSDK::avsCommon::utils::metrics::MetricEventBuilder{};
+    auto metricEventBuilder =
+        alexaClientSDK::avsCommon::utils::metrics::MetricEventBuilder{}.setMetricContext(metricContext);
 
     // Common media UPL metrics
-    addDuration(metricEventBuilder, SERVER_PROCESSING, END_OF_UTTERANCE, MEDIA_DIRECTIVE_PARSED);
-    addDuration(metricEventBuilder, UTTERANCE_END_TO_STOP_CAPTURE, END_OF_UTTERANCE, STOP_CAPTURE);
-    addDuration(metricEventBuilder, STOP_CAPTURE_TO_PARSE_COMPLETE, STOP_CAPTURE, MEDIA_DIRECTIVE_PARSED);
+    addDuration(metricEventBuilder, uplData, SERVER_PROCESSING, END_OF_UTTERANCE, MEDIA_DIRECTIVE_PARSED);
+    addDuration(metricEventBuilder, uplData, UTTERANCE_END_TO_STOP_CAPTURE, END_OF_UTTERANCE, STOP_CAPTURE);
+    addDuration(metricEventBuilder, uplData, STOP_CAPTURE_TO_PARSE_COMPLETE, STOP_CAPTURE, MEDIA_DIRECTIVE_PARSED);
 
     if (MediaUplType::STOP == type) {
         metricEventBuilder.setActivityName(UPL_MEDIA_PREFIX + UPL_MEDIA_STOP);
 
-        addDuration(metricEventBuilder, MEDIA_LATENCY, END_OF_UTTERANCE, PLAYBACK_STOPPED);
-        addDuration(metricEventBuilder, DEVICE_PROCESSING, MEDIA_DIRECTIVE_PARSED, PLAYBACK_STOPPED);
+        addDuration(metricEventBuilder, uplData, MEDIA_LATENCY, END_OF_UTTERANCE, PLAYBACK_STOPPED);
+        addDuration(metricEventBuilder, uplData, DEVICE_PROCESSING, MEDIA_DIRECTIVE_PARSED, PLAYBACK_STOPPED);
 
-        addDuration(metricEventBuilder, PARSE_COMPLETE_TO_DISPATCH, MEDIA_DIRECTIVE_PARSED, MEDIA_DIRECTIVE_DISPATCHED);
         addDuration(
-            metricEventBuilder, DISPATCH_TO_DIRECTIVE_RECEIVED, MEDIA_DIRECTIVE_DISPATCHED, STOP_DIRECTIVE_RECEIVED);
-        addDuration(metricEventBuilder, DIRECTIVE_RECEIVED_TO_MEDIA_UPDATE, STOP_DIRECTIVE_RECEIVED, PLAYBACK_STOPPED);
+            metricEventBuilder,
+            uplData,
+            PARSE_COMPLETE_TO_DISPATCH,
+            MEDIA_DIRECTIVE_PARSED,
+            MEDIA_DIRECTIVE_DISPATCHED);
+        addDuration(
+            metricEventBuilder,
+            uplData,
+            DISPATCH_TO_DIRECTIVE_RECEIVED,
+            MEDIA_DIRECTIVE_DISPATCHED,
+            STOP_DIRECTIVE_RECEIVED);
+        addDuration(
+            metricEventBuilder, uplData, DIRECTIVE_RECEIVED_TO_MEDIA_UPDATE, STOP_DIRECTIVE_RECEIVED, PLAYBACK_STOPPED);
     } else if (MediaUplType::PLAY == type) {
         metricEventBuilder.setActivityName(UPL_MEDIA_PREFIX + UPL_MEDIA_PLAY);
 
-        addDuration(metricEventBuilder, MEDIA_LATENCY, END_OF_UTTERANCE, PLAYBACK_STARTED);
-        addDuration(metricEventBuilder, DEVICE_PROCESSING, MEDIA_DIRECTIVE_PARSED, PLAYBACK_STARTED);
+        addDuration(metricEventBuilder, uplData, MEDIA_LATENCY, END_OF_UTTERANCE, PLAYBACK_STARTED);
+        addDuration(metricEventBuilder, uplData, DEVICE_PROCESSING, MEDIA_DIRECTIVE_PARSED, PLAYBACK_STARTED);
 
-        addDuration(metricEventBuilder, PARSE_COMPLETE_TO_DISPATCH, MEDIA_DIRECTIVE_PARSED, MEDIA_DIRECTIVE_DISPATCHED);
         addDuration(
-            metricEventBuilder, DISPATCH_TO_DIRECTIVE_RECEIVED, MEDIA_DIRECTIVE_DISPATCHED, PLAY_DIRECTIVE_RECEIVED);
-        addDuration(metricEventBuilder, DIRECTIVE_RECEIVED_TO_MEDIA_UPDATE, PLAY_DIRECTIVE_RECEIVED, PLAYBACK_STARTED);
+            metricEventBuilder,
+            uplData,
+            PARSE_COMPLETE_TO_DISPATCH,
+            MEDIA_DIRECTIVE_PARSED,
+            MEDIA_DIRECTIVE_DISPATCHED);
+        addDuration(
+            metricEventBuilder,
+            uplData,
+            DISPATCH_TO_DIRECTIVE_RECEIVED,
+            MEDIA_DIRECTIVE_DISPATCHED,
+            PLAY_DIRECTIVE_RECEIVED);
+        addDuration(
+            metricEventBuilder, uplData, DIRECTIVE_RECEIVED_TO_MEDIA_UPDATE, PLAY_DIRECTIVE_RECEIVED, PLAYBACK_STARTED);
     } else if (MediaUplType::PLAY_AFTER_TTS == type) {
         metricEventBuilder.setActivityName(UPL_MEDIA_PREFIX + UPL_MEDIA_PLAY_AFTER_TTS);
 
         UplTimePoint adjustedDirectiveDispatched =
-            getTimePointAdjustedForTtsDuration(m_uplData->getTimepoint(MEDIA_DIRECTIVE_DISPATCHED));
+            getTimePointAdjustedForTtsDuration(uplData, uplData->getTimepoint(MEDIA_DIRECTIVE_DISPATCHED));
         UplTimePoint adjustedDirectiveReceived =
-            getTimePointAdjustedForTtsDuration(m_uplData->getTimepoint(PLAY_DIRECTIVE_RECEIVED));
+            getTimePointAdjustedForTtsDuration(uplData, uplData->getTimepoint(PLAY_DIRECTIVE_RECEIVED));
         UplTimePoint adjustedPlaybackStarted =
-            getTimePointAdjustedForTtsDuration(m_uplData->getTimepoint(PLAYBACK_STARTED));
+            getTimePointAdjustedForTtsDuration(uplData, uplData->getTimepoint(PLAYBACK_STARTED));
 
         addDuration(
-            metricEventBuilder, MEDIA_LATENCY, m_uplData->getTimepoint(END_OF_UTTERANCE), adjustedPlaybackStarted);
+            metricEventBuilder, MEDIA_LATENCY, uplData->getTimepoint(END_OF_UTTERANCE), adjustedPlaybackStarted);
         addDuration(
             metricEventBuilder,
             DEVICE_PROCESSING,
-            m_uplData->getTimepoint(MEDIA_DIRECTIVE_PARSED),
+            uplData->getTimepoint(MEDIA_DIRECTIVE_PARSED),
             adjustedPlaybackStarted);
 
         addDuration(
             metricEventBuilder,
             PARSE_COMPLETE_TO_DISPATCH,
-            m_uplData->getTimepoint(MEDIA_DIRECTIVE_PARSED),
+            uplData->getTimepoint(MEDIA_DIRECTIVE_PARSED),
             adjustedDirectiveDispatched);
         addDuration(
             metricEventBuilder, DISPATCH_TO_DIRECTIVE_RECEIVED, adjustedDirectiveDispatched, adjustedDirectiveReceived);
@@ -293,7 +370,7 @@ void MediaUplCalculator::calculateMediaUpl(MediaUplType type) {
 
     metricEventBuilder.addDataPoint(alexaClientSDK::avsCommon::utils::metrics::DataPointStringBuilder{}
                                         .setName(DIALOG_REQUEST_ID_TAG)
-                                        .setValue(m_uplData->getStringData(DIALOG_REQUEST_ID_TAG))
+                                        .setValue(uplData->getStringData(DIALOG_REQUEST_ID_TAG))
                                         .build());
     auto metricRecorder = m_metricRecorder.lock();
     if (metricRecorder) {
@@ -301,11 +378,17 @@ void MediaUplCalculator::calculateMediaUpl(MediaUplType type) {
     } else {
         ACSDK_ERROR(LX("calculateMediaUplFailed").d("reason", "nullMetricRecorder"));
     }
-    inhibitSubmission();
+    inhibitSubmission(uplCalculatorContext);
 }
 
-void MediaUplCalculator::inhibitSubmission() {
-    m_uplInhibited = true;
+void MediaUplCalculator::inhibitSubmission(
+    const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext) {
+    auto uplInhibitedFlagFound = m_UPLCalculatorContextToUPLInhibitedFlagMap.find(uplCalculatorContext);
+    if (uplInhibitedFlagFound == m_UPLCalculatorContextToUPLInhibitedFlagMap.end()) {
+        m_UPLCalculatorContextToUPLInhibitedFlagMap.insert({uplCalculatorContext, true});
+    } else {
+        uplInhibitedFlagFound->second = true;
+    }
 }
 
 }  // namespace implementations
diff --git a/Metrics/UplCalculator/src/TtsUplCalculator.cpp b/Metrics/UplCalculator/src/TtsUplCalculator.cpp
index 97174c3c..9f4174fc 100644
--- a/Metrics/UplCalculator/src/TtsUplCalculator.cpp
+++ b/Metrics/UplCalculator/src/TtsUplCalculator.cpp
@@ -19,6 +19,7 @@
 #include <AVSCommon/Utils/Metrics/DataPointDurationBuilder.h>
 #include <AVSCommon/Utils/Metrics/DataPointStringBuilder.h>
 #include <AVSCommon/Utils/Metrics/MetricEventBuilder.h>
+#include <AVSCommon/Utils/Metrics/Utils.h>
 #include <Metrics/BaseUplCalculator.h>
 
 #include "Metrics/TtsUplCalculator.h"
@@ -67,8 +68,7 @@ std::unique_ptr<avsCommon::utils::metrics::UplCalculatorInterface> TtsUplCalcula
 
 TtsUplCalculator::TtsUplCalculator(
     std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder) :
-        m_metricRecorder(metricRecorder),
-        m_uplInhibited(false) {
+        m_metricRecorder(metricRecorder) {
 }
 
 void TtsUplCalculator::inspectMetric(
@@ -78,11 +78,27 @@ void TtsUplCalculator::inspectMetric(
         return;
     }
 
-    if (m_uplInhibited) {
+    auto metricContext = metricEvent->getMetricContext();
+    auto uplCalculatorContext = createUPLCalculatorContext(metricContext);
+    auto uplInhibitedFlagFound = m_UPLCalculatorContextToUPLInhibitedFlagMap.find(uplCalculatorContext);
+    bool uplInhibited = false;
+
+    if (uplInhibitedFlagFound != m_UPLCalculatorContextToUPLInhibitedFlagMap.end()) {
+        uplInhibited = uplInhibitedFlagFound->second;
+    }
+
+    if (uplInhibited) {
+        return;
+    }
+
+    auto uplDataFound = m_UPLCalculatorContextToUPLdataMap.find(uplCalculatorContext);
+
+    if (uplDataFound == m_UPLCalculatorContextToUPLdataMap.end()) {
         return;
     }
+    auto uplData = uplDataFound->second;
 
-    if (!m_uplData) {
+    if (!uplData) {
         return;
     }
 
@@ -93,35 +109,63 @@ void TtsUplCalculator::inspectMetric(
     std::getline(ss, metricName);
 
     if (metricName == FIRST_BYTES_AUDIO) {
-        m_uplData->addTimepoint(metricName, metricEvent->getSteadyTimestamp());
+        uplData->addTimepoint(metricName, metricEvent->getSteadyTimestamp());
     } else if (metricName == TTS_STARTED) {
-        m_uplData->addTimepoint(metricName, metricEvent->getSteadyTimestamp());
+        uplData->addTimepoint(metricName, metricEvent->getSteadyTimestamp());
 
         std::string directiveId;
         if (BaseUplCalculator::getMetricTag(metricName, metricEvent, DIRECTIVE_MESSAGE_ID_TAG, directiveId)) {
-            m_uplData->addTimepoint(TTS_DIRECTIVE_PARSED, m_uplData->getParseCompleteTimepoint(directiveId));
-            m_uplData->addTimepoint(TTS_DIRECTIVE_DISPATCHED, m_uplData->getDirectiveDispatchedTimepoint(directiveId));
+            uplData->addTimepoint(TTS_DIRECTIVE_PARSED, uplData->getParseCompleteTimepoint(directiveId));
+            uplData->addTimepoint(TTS_DIRECTIVE_DISPATCHED, uplData->getDirectiveDispatchedTimepoint(directiveId));
         }
 
-        calculateTtsUpl();
+        calculateTtsUpl(metricContext, uplData);
     }  // else, metricName doesn't match any monitored metric names, do nothing
 }
 
-void TtsUplCalculator::setUplData(const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData) {
-    m_uplData = uplData;
+void TtsUplCalculator::addUplData(
+    const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData,
+    const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext) {
+    auto uplDataFound = m_UPLCalculatorContextToUPLdataMap.find(uplCalculatorContext);
+
+    if (uplDataFound == m_UPLCalculatorContextToUPLdataMap.end()) {
+        m_UPLCalculatorContextToUPLdataMap.insert({uplCalculatorContext, uplData});
+    } else {
+        uplDataFound->second = uplData;
+    }
+    // Reset inhibited flag because addUplData is only called at the start of a new utterance
+    auto uplInhibitedFlagFound = m_UPLCalculatorContextToUPLInhibitedFlagMap.find(uplCalculatorContext);
+    if (uplInhibitedFlagFound == m_UPLCalculatorContextToUPLInhibitedFlagMap.end()) {
+        m_UPLCalculatorContextToUPLInhibitedFlagMap.insert({uplCalculatorContext, false});
+    } else {
+        uplInhibitedFlagFound->second = false;
+    }
 }
 
-std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> TtsUplCalculator::getUplData() const {
-    return m_uplData;
+std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> TtsUplCalculator::getUplData(
+    const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext) const {
+    auto uplDataFound = m_UPLCalculatorContextToUPLdataMap.find(uplCalculatorContext);
+
+    if (uplDataFound == m_UPLCalculatorContextToUPLdataMap.end()) {
+        return nullptr;
+    }
+    auto uplData = uplDataFound->second;
+
+    if (!uplData) {
+        return nullptr;
+    }
+
+    return uplData;
 }
 
 void TtsUplCalculator::addDuration(
     alexaClientSDK::avsCommon::utils::metrics::MetricEventBuilder& metricEventBuilder,
+    const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData,
     const std::string& name,
     const std::string& startTimepointName,
     const std::string& endTimepointName) {
-    UplTimePoint startTimepoint = m_uplData->getTimepoint(startTimepointName);
-    UplTimePoint endTimepoint = m_uplData->getTimepoint(endTimepointName);
+    UplTimePoint startTimepoint = uplData->getTimepoint(startTimepointName);
+    UplTimePoint endTimepoint = uplData->getTimepoint(endTimepointName);
 
     if (startTimepoint.time_since_epoch().count() == 0) {
         ACSDK_ERROR(LX("addDurationFailed")
@@ -152,27 +196,39 @@ void TtsUplCalculator::addDuration(
         alexaClientSDK::avsCommon::utils::metrics::DataPointDurationBuilder{duration}.setName(name).build());
 }
 
-void TtsUplCalculator::calculateTtsUpl() {
-    if (m_uplInhibited) {
+void TtsUplCalculator::calculateTtsUpl(
+    const avsCommon::utils::metrics::MetricContext& metricContext,
+    const std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData>& uplData) {
+    auto uplCalculatorContext = createUPLCalculatorContext(metricContext);
+    auto uplInhibitedFlagFound = m_UPLCalculatorContextToUPLInhibitedFlagMap.find(uplCalculatorContext);
+    bool uplInhibited = false;
+
+    if (uplInhibitedFlagFound != m_UPLCalculatorContextToUPLInhibitedFlagMap.end()) {
+        uplInhibited = uplInhibitedFlagFound->second;
+    }
+
+    if (uplInhibited) {
         return;
     }
 
-    auto metricEventBuilder =
-        alexaClientSDK::avsCommon::utils::metrics::MetricEventBuilder{}.setActivityName(UPL_ACTIVITY_NAME);
+    auto metricEventBuilder = alexaClientSDK::avsCommon::utils::metrics::MetricEventBuilder{}
+                                  .setActivityName(UPL_ACTIVITY_NAME)
+                                  .setMetricContext(metricContext);
 
-    addDuration(metricEventBuilder, TTS_LATENCY, END_OF_UTTERANCE, TTS_STARTED);
-    addDuration(metricEventBuilder, SERVER_PROCESSING, END_OF_UTTERANCE, TTS_DIRECTIVE_PARSED);
-    addDuration(metricEventBuilder, DEVICE_PROCESSING, TTS_DIRECTIVE_PARSED, TTS_STARTED);
+    addDuration(metricEventBuilder, uplData, TTS_LATENCY, END_OF_UTTERANCE, TTS_STARTED);
+    addDuration(metricEventBuilder, uplData, SERVER_PROCESSING, END_OF_UTTERANCE, TTS_DIRECTIVE_PARSED);
+    addDuration(metricEventBuilder, uplData, DEVICE_PROCESSING, TTS_DIRECTIVE_PARSED, TTS_STARTED);
 
-    addDuration(metricEventBuilder, UTTERANCE_END_TO_STOP_CAPTURE, END_OF_UTTERANCE, STOP_CAPTURE);
-    addDuration(metricEventBuilder, STOP_CAPTURE_TO_PARSE_COMPLETE, STOP_CAPTURE, TTS_DIRECTIVE_PARSED);
-    addDuration(metricEventBuilder, PARSE_COMPLETE_TO_DISPATCH, TTS_DIRECTIVE_PARSED, TTS_DIRECTIVE_DISPATCHED);
-    addDuration(metricEventBuilder, DISPATCH_TO_FIRST_BYTE_AUDIO, TTS_DIRECTIVE_DISPATCHED, FIRST_BYTES_AUDIO);
-    addDuration(metricEventBuilder, FIRST_BYTE_AUDIO_TO_TTS_STARTED, FIRST_BYTES_AUDIO, TTS_STARTED);
+    addDuration(metricEventBuilder, uplData, UTTERANCE_END_TO_STOP_CAPTURE, END_OF_UTTERANCE, STOP_CAPTURE);
+    addDuration(metricEventBuilder, uplData, STOP_CAPTURE_TO_PARSE_COMPLETE, STOP_CAPTURE, TTS_DIRECTIVE_PARSED);
+    addDuration(
+        metricEventBuilder, uplData, PARSE_COMPLETE_TO_DISPATCH, TTS_DIRECTIVE_PARSED, TTS_DIRECTIVE_DISPATCHED);
+    addDuration(metricEventBuilder, uplData, DISPATCH_TO_FIRST_BYTE_AUDIO, TTS_DIRECTIVE_DISPATCHED, FIRST_BYTES_AUDIO);
+    addDuration(metricEventBuilder, uplData, FIRST_BYTE_AUDIO_TO_TTS_STARTED, FIRST_BYTES_AUDIO, TTS_STARTED);
 
     metricEventBuilder.addDataPoint(alexaClientSDK::avsCommon::utils::metrics::DataPointStringBuilder{}
                                         .setName(DIALOG_REQUEST_ID_TAG)
-                                        .setValue(m_uplData->getStringData(DIALOG_REQUEST_ID_TAG))
+                                        .setValue(uplData->getStringData(DIALOG_REQUEST_ID_TAG))
                                         .build());
     auto metricsRecorder = m_metricRecorder.lock();
     if (metricsRecorder) {
@@ -180,11 +236,17 @@ void TtsUplCalculator::calculateTtsUpl() {
     } else {
         ACSDK_ERROR(LX("calculateTtsUplFailed").d("reason", "nullMetricRecorder"));
     }
-    inhibitSubmission();
+    inhibitSubmission(uplCalculatorContext);
 }
 
-void TtsUplCalculator::inhibitSubmission() {
-    m_uplInhibited = true;
+void TtsUplCalculator::inhibitSubmission(
+    const alexaClientSDK::avsCommon::utils::metrics::UPLCalculatorContext& uplCalculatorContext) {
+    auto uplInhibitedFlagFound = m_UPLCalculatorContextToUPLInhibitedFlagMap.find(uplCalculatorContext);
+    if (uplInhibitedFlagFound == m_UPLCalculatorContextToUPLInhibitedFlagMap.end()) {
+        m_UPLCalculatorContextToUPLInhibitedFlagMap.insert({uplCalculatorContext, true});
+    } else {
+        uplInhibitedFlagFound->second = true;
+    }
 }
 
 }  // namespace implementations
diff --git a/Metrics/UplCalculator/src/UplMetricSink.cpp b/Metrics/UplCalculator/src/UplMetricSink.cpp
index 2193a609..4f6ebb72 100644
--- a/Metrics/UplCalculator/src/UplMetricSink.cpp
+++ b/Metrics/UplCalculator/src/UplMetricSink.cpp
@@ -14,6 +14,7 @@
  */
 #include <AVSCommon/Utils/Logger/Logger.h>
 #include <AVSCommon/Utils/Metrics/UplData.h>
+#include <AVSCommon/Utils/Metrics/Utils.h>
 #include <Metrics/BaseUplCalculator.h>
 #include <Metrics/MediaUplCalculator.h>
 #include <Metrics/TtsUplCalculator.h>
@@ -51,6 +52,11 @@ std::unique_ptr<avsCommon::utils::metrics::MetricSinkInterface> UplMetricSink::c
 UplMetricSink::UplMetricSink(
     std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder) :
         m_metricRecorder(metricRecorder) {
+    uplCalculators[BASE_UPL_NAME] = BaseUplCalculator::createBaseUplCalculator();
+    if (metricRecorder) {
+        uplCalculators[TTS_UPL_NAME] = TtsUplCalculator::createTtsUplCalculator(metricRecorder);
+        uplCalculators[MEDIA_UPL_NAME] = MediaUplCalculator::createMediaUplCalculator(metricRecorder);
+    }
 }
 
 void UplMetricSink::consumeMetric(std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::MetricEvent> metricEvent) {
@@ -65,24 +71,27 @@ void UplMetricSink::consumeMetric(std::shared_ptr<alexaClientSDK::avsCommon::uti
     std::string metricName;
     std::getline(ss, metricName);
 
+    auto metricContext = metricEvent->getMetricContext();
+    auto uplCalculatorContext = createUPLCalculatorContext(metricContext);
     // Reset UPL data on the start of a new utterance
     if (metricName == START_OF_UTTERANCE) {
-        uplCalculators[BASE_UPL_NAME] = BaseUplCalculator::createBaseUplCalculator();
         auto metricRecorder = m_metricRecorder.lock();
         if (metricRecorder) {
-            uplCalculators[TTS_UPL_NAME] = TtsUplCalculator::createTtsUplCalculator(metricRecorder);
-            uplCalculators[MEDIA_UPL_NAME] = MediaUplCalculator::createMediaUplCalculator(metricRecorder);
             std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> uplData =
                 std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
             for (auto& kv : uplCalculators) {
-                kv.second->setUplData(uplData);
+                if (kv.second) {
+                    kv.second->addUplData(uplData, uplCalculatorContext);
+                }
             }
         }
     }
 
     if (!uplCalculators.empty()) {
         for (auto& kv : uplCalculators) {
-            kv.second->inspectMetric(metricEvent);
+            if (kv.second) {
+                kv.second->inspectMetric(metricEvent);
+            }
         }
     }
 }
diff --git a/Metrics/UplCalculator/test/BaseUplCalculatorTest.cpp b/Metrics/UplCalculator/test/BaseUplCalculatorTest.cpp
new file mode 100644
index 00000000..fcea5813
--- /dev/null
+++ b/Metrics/UplCalculator/test/BaseUplCalculatorTest.cpp
@@ -0,0 +1,200 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+// @file BaseUplCalculatorTest.cpp
+
+#include <gtest/gtest.h>
+
+#include <AVSCommon/Utils/Metrics/MetricEvent.h>
+#include <AVSCommon/Utils/Metrics/MetricEventBuilder.h>
+#include <AVSCommon/Utils/Metrics/UplCalculatorInterface.h>
+#include <AVSCommon/Utils/Metrics/UplData.h>
+#include <AVSCommon/Utils/Metrics/Utils.h>
+
+#include "Metrics/BaseUplCalculator.h"
+
+namespace alexaClientSDK {
+namespace metrics {
+namespace test {
+
+using namespace ::testing;
+using namespace alexaClientSDK::avsCommon::utils::metrics;
+
+/**
+ * Class for testing the BaseUplCalculator class
+ */
+class BaseUplCalculatorTest : public ::testing::Test {};
+
+/**
+ * Tests addUplData() for BaseUplCalculator with one agent id
+ */
+TEST_F(BaseUplCalculatorTest, test_baseUplCalculatorAddUplDataOneAgent) {
+    auto baseUplCalculator = alexaClientSDK::metrics::implementations::BaseUplCalculator::createBaseUplCalculator();
+
+    MetricContext metricContext;
+    metricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId();
+
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> uplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+
+    auto uplCalculatorContext = createUPLCalculatorContext(metricContext);
+
+    baseUplCalculator->addUplData(uplData, uplCalculatorContext);
+
+    auto retrievedUplData = baseUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify that the upl data is set correctly for the agent
+    ASSERT_EQ(uplData, retrievedUplData);
+
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> anotherUplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+
+    baseUplCalculator->addUplData(anotherUplData, uplCalculatorContext);
+    retrievedUplData = baseUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify that the upl data has been changed for the agent
+    ASSERT_NE(uplData, retrievedUplData);
+}
+
+/**
+ * Tests addUplData() for BaseUplCalculator with two agent ids
+ */
+TEST_F(BaseUplCalculatorTest, test_baseUplCalculatorAddUplDataTwoAgents) {
+    auto baseUplCalculator = alexaClientSDK::metrics::implementations::BaseUplCalculator::createBaseUplCalculator();
+
+    MetricContext firstMetricContext;
+    firstMetricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId();
+
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> firstUplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+
+    auto firstUplCalculatorContext = createUPLCalculatorContext(firstMetricContext);
+
+    baseUplCalculator->addUplData(firstUplData, firstUplCalculatorContext);
+
+    auto retrievedUplData = baseUplCalculator->getUplData(firstUplCalculatorContext);
+
+    // Verify that the data is set correctly for the first agent
+    ASSERT_EQ(firstUplData, retrievedUplData);
+
+    MetricContext secondMetricContext;
+    secondMetricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> secondUplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+    auto secondUplCalculatorContext = createUPLCalculatorContext(secondMetricContext);
+
+    // Verify that no data is set for the second agent
+    retrievedUplData = baseUplCalculator->getUplData(secondUplCalculatorContext);
+    ASSERT_TRUE(retrievedUplData == nullptr);
+
+    baseUplCalculator->addUplData(secondUplData, secondUplCalculatorContext);
+    retrievedUplData = baseUplCalculator->getUplData(secondUplCalculatorContext);
+
+    // Verify that the data is set correctly for the second agent
+    ASSERT_EQ(secondUplData, retrievedUplData);
+
+    retrievedUplData = baseUplCalculator->getUplData(firstUplCalculatorContext);
+
+    // Verify that the upl data has not changed for the first agent
+    ASSERT_EQ(firstUplData, retrievedUplData);
+}
+
+/**
+ * Tests inspectMetric() for BaseUplCalculator with one agent id
+ */
+TEST_F(BaseUplCalculatorTest, test_baseUplCalculatorInspectMetricOneAgent) {
+    auto baseUplCalculator = alexaClientSDK::metrics::implementations::BaseUplCalculator::createBaseUplCalculator();
+
+    MetricContext metricContext;
+    metricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId();
+
+    MetricEventBuilder builder = MetricEventBuilder{};
+    std::shared_ptr<MetricEvent> metricEvent = builder.setActivityName("TEST-START_OF_UTTERANCE")
+                                                   .setPriority(Priority::NORMAL)
+                                                   .setMetricContext(metricContext)
+                                                   .build();
+    auto timePoint = metricEvent->getSteadyTimestamp();
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> uplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+    auto uplCalculatorContext = createUPLCalculatorContext(metricContext);
+
+    baseUplCalculator->addUplData(uplData, uplCalculatorContext);
+    auto retrievedUplData = baseUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify that the upl data is set correctly for the agent
+    ASSERT_EQ(uplData, retrievedUplData);
+
+    baseUplCalculator->inspectMetric(metricEvent);
+    retrievedUplData = baseUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify inspectMetric updated the uplData for the agent
+    ASSERT_EQ(uplData, retrievedUplData);
+    ASSERT_EQ(timePoint, retrievedUplData->getTimepoint("START_OF_UTTERANCE"));
+}
+
+/**
+ * Tests inspectMetric() for BaseUplCalculator with two agent ids
+ */
+TEST_F(BaseUplCalculatorTest, test_baseUplCalculatorInspectMetricTwoAgents) {
+    auto baseUplCalculator = alexaClientSDK::metrics::implementations::BaseUplCalculator::createBaseUplCalculator();
+
+    MetricContext metricContext;
+    metricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId();
+
+    MetricContext anotherMetricContext;
+    metricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+
+    MetricEventBuilder builder = MetricEventBuilder{};
+    std::shared_ptr<MetricEvent> metricEvent = builder.setActivityName("TEST-START_OF_UTTERANCE")
+                                                   .setPriority(Priority::NORMAL)
+                                                   .setMetricContext(metricContext)
+                                                   .build();
+    auto timePoint = metricEvent->getSteadyTimestamp();
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> uplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+    auto uplCalculatorContext = createUPLCalculatorContext(metricContext);
+
+    baseUplCalculator->addUplData(uplData, uplCalculatorContext);
+    auto retrievedUplData = baseUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify that the upl data is set correctly for the agent
+    ASSERT_EQ(uplData, retrievedUplData);
+
+    baseUplCalculator->inspectMetric(metricEvent);
+    retrievedUplData = baseUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify inspectMetric updated the uplData for the agent
+    ASSERT_EQ(uplData, retrievedUplData);
+    ASSERT_EQ(timePoint, retrievedUplData->getTimepoint("START_OF_UTTERANCE"));
+
+    // Create a metric event for another agent
+    std::shared_ptr<MetricEvent> anotherMetricEvent = builder.setActivityName("TEST-START_OF_UTTERANCE")
+                                                          .setPriority(Priority::NORMAL)
+                                                          .setMetricContext(anotherMetricContext)
+                                                          .build();
+    auto anotherTimePoint = anotherMetricEvent->getSteadyTimestamp();
+
+    // Verify that the timepoints for the two metric events are different
+    ASSERT_NE(timePoint, anotherTimePoint);
+
+    baseUplCalculator->inspectMetric(anotherMetricEvent);
+    retrievedUplData = baseUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify that the first agent upl data was not changed by the second agent upl data
+    ASSERT_EQ(timePoint, retrievedUplData->getTimepoint("START_OF_UTTERANCE"));
+}
+
+}  // namespace test
+}  // namespace metrics
+}  // namespace alexaClientSDK
diff --git a/Metrics/UplCalculator/test/CMakeLists.txt b/Metrics/UplCalculator/test/CMakeLists.txt
new file mode 100644
index 00000000..909bd0e5
--- /dev/null
+++ b/Metrics/UplCalculator/test/CMakeLists.txt
@@ -0,0 +1,7 @@
+cmake_minimum_required(VERSION 3.1 FATAL_ERROR)
+
+set(INCLUDE_PATH
+        "${AVSCommon_SOURCE_DIR}/Utils/test")
+
+discover_unit_tests("${INCLUDE_PATH}" UplCalculator)
+
diff --git a/Metrics/UplCalculator/test/MediaUplCalculatorTest.cpp b/Metrics/UplCalculator/test/MediaUplCalculatorTest.cpp
new file mode 100644
index 00000000..a8612a33
--- /dev/null
+++ b/Metrics/UplCalculator/test/MediaUplCalculatorTest.cpp
@@ -0,0 +1,216 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+// @file MediaUplCalculatorTest.cpp
+
+#include <gtest/gtest.h>
+
+#include <AVSCommon/Utils/Metrics/MetricEvent.h>
+#include <AVSCommon/Utils/Metrics/MetricEventBuilder.h>
+#include <AVSCommon/Utils/Metrics/UplCalculatorInterface.h>
+#include <AVSCommon/Utils/Metrics/UplData.h>
+#include <AVSCommon/Utils/Metrics/Utils.h>
+
+#include "Metrics/MediaUplCalculator.h"
+#include "Metrics/MockMetricRecorder.h"
+
+namespace alexaClientSDK {
+namespace metrics {
+namespace test {
+
+using namespace ::testing;
+using namespace alexaClientSDK::avsCommon::utils::metrics;
+
+/**
+ * Class for testing the MediaUplCalculator class
+ */
+class MediaUplCalculatorTest : public ::testing::Test {
+public:
+    void SetUp() override;
+
+protected:
+    /// The mock @c MetricRecorderInterface.
+    std::shared_ptr<MockMetricRecorder> m_mockMetricRecorder;
+};
+
+void MediaUplCalculatorTest::SetUp() {
+    m_mockMetricRecorder = std::make_shared<MockMetricRecorder>();
+}
+
+/**
+ * Tests addUplData() for MediaUplCalculator with one agent id
+ */
+TEST_F(MediaUplCalculatorTest, test_mediaUplCalculatorAddUplDataOneAgent) {
+    auto mediaUplCalculator =
+        alexaClientSDK::metrics::implementations::MediaUplCalculator::createMediaUplCalculator(m_mockMetricRecorder);
+
+    MetricContext metricContext;
+    metricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId();
+
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> uplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+
+    auto uplCalculatorContext = createUPLCalculatorContext(metricContext);
+
+    mediaUplCalculator->addUplData(uplData, uplCalculatorContext);
+
+    auto retrievedUplData = mediaUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify that the upl data is set correctly for the agent
+    ASSERT_EQ(uplData, retrievedUplData);
+
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> anotherUplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+
+    mediaUplCalculator->addUplData(anotherUplData, uplCalculatorContext);
+    retrievedUplData = mediaUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify that the upl data has been changed for the agent
+    ASSERT_NE(uplData, retrievedUplData);
+}
+
+/**
+ * Tests addUplData() for MediaUplCalculator with two agent ids
+ */
+TEST_F(MediaUplCalculatorTest, test_mediaUplCalculatorAddUplDataTwoAgents) {
+    auto mediaUplCalculator =
+        alexaClientSDK::metrics::implementations::MediaUplCalculator::createMediaUplCalculator(m_mockMetricRecorder);
+
+    MetricContext firstMetricContext;
+    firstMetricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId();
+
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> firstUplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+
+    auto firstUplCalculatorContext = createUPLCalculatorContext(firstMetricContext);
+
+    mediaUplCalculator->addUplData(firstUplData, firstUplCalculatorContext);
+
+    auto retrievedUplData = mediaUplCalculator->getUplData(firstUplCalculatorContext);
+
+    // Verify that the data is set correctly for the first agent
+    ASSERT_EQ(firstUplData, retrievedUplData);
+
+    MetricContext secondMetricContext;
+    secondMetricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> secondUplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+    auto secondUplCalculatorContext = createUPLCalculatorContext(secondMetricContext);
+
+    // Verify that no data is set for the second agent
+    retrievedUplData = mediaUplCalculator->getUplData(secondUplCalculatorContext);
+    ASSERT_TRUE(retrievedUplData == nullptr);
+
+    mediaUplCalculator->addUplData(secondUplData, secondUplCalculatorContext);
+    retrievedUplData = mediaUplCalculator->getUplData(secondUplCalculatorContext);
+
+    // Verify that the data is set correctly for the second agent
+    ASSERT_EQ(secondUplData, retrievedUplData);
+
+    retrievedUplData = mediaUplCalculator->getUplData(firstUplCalculatorContext);
+
+    // Verify that the upl data has not changed for the first agent
+    ASSERT_EQ(firstUplData, retrievedUplData);
+}
+
+/**
+ * Tests inspectMetric() for MediaUplCalculator with one agent id
+ */
+TEST_F(MediaUplCalculatorTest, test_mediaUplCalculatorInspectMetricOneAgent) {
+    auto mediaUplCalculator =
+        alexaClientSDK::metrics::implementations::MediaUplCalculator::createMediaUplCalculator(m_mockMetricRecorder);
+
+    MetricContext metricContext;
+    metricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId();
+
+    MetricEventBuilder builder = MetricEventBuilder{};
+    std::shared_ptr<MetricEvent> metricEvent = builder.setActivityName("TEST-PLAYBACK_STOPPED")
+                                                   .setPriority(Priority::NORMAL)
+                                                   .setMetricContext(metricContext)
+                                                   .build();
+    auto timePoint = metricEvent->getSteadyTimestamp();
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> uplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+    auto uplCalculatorContext = createUPLCalculatorContext(metricContext);
+
+    mediaUplCalculator->addUplData(uplData, uplCalculatorContext);
+    auto retrievedUplData = mediaUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify that the upl data is set correctly for the agent
+    ASSERT_EQ(uplData, retrievedUplData);
+
+    mediaUplCalculator->inspectMetric(metricEvent);
+    retrievedUplData = mediaUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify inspectMetric updated the uplData for the agent
+    ASSERT_EQ(uplData, retrievedUplData);
+    ASSERT_EQ(timePoint, retrievedUplData->getTimepoint("PLAYBACK_STOPPED"));
+}
+
+/**
+ * Tests inspectMetric() for MediaUplCalculator with two agent ids
+ */
+TEST_F(MediaUplCalculatorTest, test_mediaUplCalculatorInspectMetricTwoAgents) {
+    auto mediaUplCalculator =
+        alexaClientSDK::metrics::implementations::MediaUplCalculator::createMediaUplCalculator(m_mockMetricRecorder);
+
+    MetricContext metricContext;
+    metricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId();
+
+    MetricContext anotherMetricContext;
+    metricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+
+    MetricEventBuilder builder = MetricEventBuilder{};
+    std::shared_ptr<MetricEvent> metricEvent = builder.setActivityName("TEST-PLAYBACK_STOPPED")
+                                                   .setPriority(Priority::NORMAL)
+                                                   .setMetricContext(metricContext)
+                                                   .build();
+    auto timePoint = metricEvent->getSteadyTimestamp();
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> uplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+    auto uplCalculatorContext = createUPLCalculatorContext(metricContext);
+
+    mediaUplCalculator->addUplData(uplData, uplCalculatorContext);
+    auto retrievedUplData = mediaUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify that the upl data is set correctly for the agent
+    ASSERT_EQ(uplData, retrievedUplData);
+
+    mediaUplCalculator->inspectMetric(metricEvent);
+    retrievedUplData = mediaUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify inspectMetric updated the uplData for the agent
+    ASSERT_EQ(uplData, retrievedUplData);
+    ASSERT_EQ(timePoint, retrievedUplData->getTimepoint("PLAYBACK_STOPPED"));
+
+    // Create a metric event for another agent
+    std::shared_ptr<MetricEvent> anotherMetricEvent = builder.setActivityName("TEST-PLAYBACK_STOPPED")
+                                                          .setPriority(Priority::NORMAL)
+                                                          .setMetricContext(anotherMetricContext)
+                                                          .build();
+    auto anotherTimePoint = anotherMetricEvent->getSteadyTimestamp();
+
+    // Verify that the timepoints for the two metric events are different
+    ASSERT_NE(timePoint, anotherTimePoint);
+
+    mediaUplCalculator->inspectMetric(anotherMetricEvent);
+    retrievedUplData = mediaUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify that the first agent upl data was not changed by the second agent upl data
+    ASSERT_EQ(timePoint, retrievedUplData->getTimepoint("PLAYBACK_STOPPED"));
+}
+
+}  // namespace test
+}  // namespace metrics
+}  // namespace alexaClientSDK
diff --git a/Metrics/UplCalculator/test/Metrics/MockMetricRecorder.h b/Metrics/UplCalculator/test/Metrics/MockMetricRecorder.h
new file mode 100644
index 00000000..0f42a047
--- /dev/null
+++ b/Metrics/UplCalculator/test/Metrics/MockMetricRecorder.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+#ifndef ALEXA_CLIENT_SDK_METRICS_UPLCALCULATOR_TEST_METRICS_MOCKMETRICRECORDER_H_
+#define ALEXA_CLIENT_SDK_METRICS_UPLCALCULATOR_TEST_METRICS_MOCKMETRICRECORDER_H_
+
+#include <AVSCommon/Utils/Metrics/MetricEvent.h>
+#include <AVSCommon/Utils/Metrics/MetricRecorderInterface.h>
+#include <gmock/gmock.h>
+
+namespace alexaClientSDK {
+namespace metrics {
+namespace test {
+
+/// Mock class that implements the DirectiveSequencer.
+class MockMetricRecorder : public avsCommon::utils::metrics::MetricRecorderInterface {
+public:
+    MockMetricRecorder();
+
+    MOCK_METHOD1(recordMetric, void(std::shared_ptr<avsCommon::utils::metrics::MetricEvent> metricEvent));
+};
+
+inline MockMetricRecorder::MockMetricRecorder() : avsCommon::utils::metrics::MetricRecorderInterface{} {
+}
+
+}  // namespace test
+}  // namespace metrics
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_METRICS_UPLCALCULATOR_TEST_METRICS_MOCKMETRICRECORDER_H_
diff --git a/Metrics/UplCalculator/test/TtsUplCalculatorTest.cpp b/Metrics/UplCalculator/test/TtsUplCalculatorTest.cpp
new file mode 100644
index 00000000..7fad49e3
--- /dev/null
+++ b/Metrics/UplCalculator/test/TtsUplCalculatorTest.cpp
@@ -0,0 +1,216 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+// @file TtsUplCalculatorTest.cpp
+
+#include <gtest/gtest.h>
+
+#include <AVSCommon/Utils/Metrics/MetricEvent.h>
+#include <AVSCommon/Utils/Metrics/MetricEventBuilder.h>
+#include <AVSCommon/Utils/Metrics/UplCalculatorInterface.h>
+#include <AVSCommon/Utils/Metrics/UplData.h>
+#include <AVSCommon/Utils/Metrics/Utils.h>
+
+#include "Metrics/MockMetricRecorder.h"
+#include "Metrics/TtsUplCalculator.h"
+
+namespace alexaClientSDK {
+namespace metrics {
+namespace test {
+
+using namespace ::testing;
+using namespace alexaClientSDK::avsCommon::utils::metrics;
+
+/**
+ * Class for testing the TtsUplCalculator class
+ */
+class TtsUplCalculatorTest : public ::testing::Test {
+public:
+    void SetUp() override;
+
+protected:
+    /// The mock @c MetricRecorderInterface.
+    std::shared_ptr<MockMetricRecorder> m_mockMetricRecorder;
+};
+
+void TtsUplCalculatorTest::SetUp() {
+    m_mockMetricRecorder = std::make_shared<MockMetricRecorder>();
+}
+
+/**
+ * Tests addUplData() for TtsUplCalculator with one agent id
+ */
+TEST_F(TtsUplCalculatorTest, test_ttsUplCalculatorAddUplDataOneAgent) {
+    auto ttsUplCalculator =
+        alexaClientSDK::metrics::implementations::TtsUplCalculator::createTtsUplCalculator(m_mockMetricRecorder);
+
+    MetricContext metricContext;
+    metricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId();
+
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> uplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+
+    auto uplCalculatorContext = createUPLCalculatorContext(metricContext);
+
+    ttsUplCalculator->addUplData(uplData, uplCalculatorContext);
+
+    auto retrievedUplData = ttsUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify that the upl data is set correctly for the agent
+    ASSERT_EQ(uplData, retrievedUplData);
+
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> anotherUplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+
+    ttsUplCalculator->addUplData(anotherUplData, uplCalculatorContext);
+    retrievedUplData = ttsUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify that the upl data has been changed for the agent
+    ASSERT_NE(uplData, retrievedUplData);
+}
+
+/**
+ * Tests addUplData() for TtsUplCalculator with two agent ids
+ */
+TEST_F(TtsUplCalculatorTest, test_ttsUplCalculatorAddUplDataTwoAgents) {
+    auto ttsUplCalculator =
+        alexaClientSDK::metrics::implementations::TtsUplCalculator::createTtsUplCalculator(m_mockMetricRecorder);
+
+    MetricContext firstMetricContext;
+    firstMetricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId();
+
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> firstUplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+
+    auto firstUplCalculatorContext = createUPLCalculatorContext(firstMetricContext);
+
+    ttsUplCalculator->addUplData(firstUplData, firstUplCalculatorContext);
+
+    auto retrievedUplData = ttsUplCalculator->getUplData(firstUplCalculatorContext);
+
+    // Verify that the data is set correctly for the first agent
+    ASSERT_EQ(firstUplData, retrievedUplData);
+
+    MetricContext secondMetricContext;
+    secondMetricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> secondUplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+    auto secondUplCalculatorContext = createUPLCalculatorContext(secondMetricContext);
+
+    // Verify that no data is set for the second agent
+    retrievedUplData = ttsUplCalculator->getUplData(secondUplCalculatorContext);
+    ASSERT_TRUE(retrievedUplData == nullptr);
+
+    ttsUplCalculator->addUplData(secondUplData, secondUplCalculatorContext);
+    retrievedUplData = ttsUplCalculator->getUplData(secondUplCalculatorContext);
+
+    // Verify that the data is set correctly for the second agent
+    ASSERT_EQ(secondUplData, retrievedUplData);
+
+    retrievedUplData = ttsUplCalculator->getUplData(firstUplCalculatorContext);
+
+    // Verify that the upl data has not changed for the first agent
+    ASSERT_EQ(firstUplData, retrievedUplData);
+}
+
+/**
+ * Tests inspectMetric() for TtsUplCalculator with one agent id
+ */
+TEST_F(TtsUplCalculatorTest, test_ttsUplCalculatorInspectMetricOneAgent) {
+    auto ttsUplCalculator =
+        alexaClientSDK::metrics::implementations::TtsUplCalculator::createTtsUplCalculator(m_mockMetricRecorder);
+
+    MetricContext metricContext;
+    metricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId();
+
+    MetricEventBuilder builder = MetricEventBuilder{};
+    std::shared_ptr<MetricEvent> metricEvent = builder.setActivityName("TEST-FIRST_BYTES_AUDIO")
+                                                   .setPriority(Priority::NORMAL)
+                                                   .setMetricContext(metricContext)
+                                                   .build();
+    auto timePoint = metricEvent->getSteadyTimestamp();
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> uplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+    auto uplCalculatorContext = createUPLCalculatorContext(metricContext);
+
+    ttsUplCalculator->addUplData(uplData, uplCalculatorContext);
+    auto retrievedUplData = ttsUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify that the upl data is set correctly for the agent
+    ASSERT_EQ(uplData, retrievedUplData);
+
+    ttsUplCalculator->inspectMetric(metricEvent);
+    retrievedUplData = ttsUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify inspectMetric updated the uplData for the agent
+    ASSERT_EQ(uplData, retrievedUplData);
+    ASSERT_EQ(timePoint, retrievedUplData->getTimepoint("FIRST_BYTES_AUDIO"));
+}
+
+/**
+ * Tests inspectMetric() for TtsUplCalculator with two agent ids
+ */
+TEST_F(TtsUplCalculatorTest, test_ttsUplCalculatorInspectMetricTwoAgents) {
+    auto ttsUplCalculator =
+        alexaClientSDK::metrics::implementations::TtsUplCalculator::createTtsUplCalculator(m_mockMetricRecorder);
+
+    MetricContext metricContext;
+    metricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId();
+
+    MetricContext anotherMetricContext;
+    metricContext.agentId = avsCommon::avs::AgentId::getAlexaAgentId() + 1;
+
+    MetricEventBuilder builder = MetricEventBuilder{};
+    std::shared_ptr<MetricEvent> metricEvent = builder.setActivityName("TEST-FIRST_BYTES_AUDIO")
+                                                   .setPriority(Priority::NORMAL)
+                                                   .setMetricContext(metricContext)
+                                                   .build();
+    auto timePoint = metricEvent->getSteadyTimestamp();
+    std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> uplData =
+        std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+    auto uplCalculatorContext = createUPLCalculatorContext(metricContext);
+
+    ttsUplCalculator->addUplData(uplData, uplCalculatorContext);
+    auto retrievedUplData = ttsUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify that the upl data is set correctly for the agent
+    ASSERT_EQ(uplData, retrievedUplData);
+
+    ttsUplCalculator->inspectMetric(metricEvent);
+    retrievedUplData = ttsUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify inspectMetric updated the uplData for the agent
+    ASSERT_EQ(uplData, retrievedUplData);
+    ASSERT_EQ(timePoint, retrievedUplData->getTimepoint("FIRST_BYTES_AUDIO"));
+
+    // Create a metric event for another agent
+    std::shared_ptr<MetricEvent> anotherMetricEvent = builder.setActivityName("TEST-FIRST_BYTES_AUDIO")
+                                                          .setPriority(Priority::NORMAL)
+                                                          .setMetricContext(anotherMetricContext)
+                                                          .build();
+    auto anotherTimePoint = anotherMetricEvent->getSteadyTimestamp();
+
+    // Verify that the timepoints for the two metric events are different
+    ASSERT_NE(timePoint, anotherTimePoint);
+
+    ttsUplCalculator->inspectMetric(anotherMetricEvent);
+    retrievedUplData = ttsUplCalculator->getUplData(uplCalculatorContext);
+
+    // Verify that the first agent upl data was not changed by the second agent upl data
+    ASSERT_EQ(timePoint, retrievedUplData->getTimepoint("FIRST_BYTES_AUDIO"));
+}
+
+}  // namespace test
+}  // namespace metrics
+}  // namespace alexaClientSDK
diff --git a/Metrics/UplCalculator/test/UplMetricSinkTest.cpp b/Metrics/UplCalculator/test/UplMetricSinkTest.cpp
new file mode 100644
index 00000000..88acd030
--- /dev/null
+++ b/Metrics/UplCalculator/test/UplMetricSinkTest.cpp
@@ -0,0 +1,70 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+// @file UplMetricSink.cpp
+
+#include <gtest/gtest.h>
+
+#include <AVSCommon/Utils/Logger/Logger.h>
+#include <AVSCommon/Utils/Metrics/DataType.h>
+#include <AVSCommon/Utils/Metrics/Utils.h>
+
+#include "Metrics/MockMetricRecorder.h"
+#include "Metrics/UplMetricSink.h"
+
+namespace alexaClientSDK {
+namespace metrics {
+namespace test {
+
+/**
+ * Class for testing the UplMetricSink class
+ */
+class UplMetricSinkTest : public ::testing::Test {
+public:
+    void SetUp() override;
+
+protected:
+    /// The mock @c MetricRecorderInterface.
+    std::shared_ptr<MockMetricRecorder> m_mockMetricRecorder;
+};
+
+void UplMetricSinkTest::SetUp() {
+    m_mockMetricRecorder = std::make_shared<MockMetricRecorder>();
+}
+
+/**
+ * Tests UplMetricSink createMetricSinkInterface
+ */
+TEST_F(UplMetricSinkTest, test_createUplMetricSink) {
+    auto uplMetricSink =
+        alexaClientSDK::metrics::implementations::UplMetricSink::createMetricSinkInterface(m_mockMetricRecorder);
+
+    ASSERT_TRUE(uplMetricSink != nullptr);
+}
+
+/**
+ * Tests UplMetricSink createMetricSinkInterface with null MetricRecorder
+ */
+TEST_F(UplMetricSinkTest, test_createUplMetricSinkNullMetricRecorder) {
+    std::shared_ptr<MockMetricRecorder> mockMetricRecorder = nullptr;
+
+    auto uplMetricSink =
+        alexaClientSDK::metrics::implementations::UplMetricSink::createMetricSinkInterface(mockMetricRecorder);
+
+    ASSERT_TRUE(uplMetricSink == nullptr);
+}
+
+}  // namespace test
+}  // namespace metrics
+}  // namespace alexaClientSDK
diff --git a/SampleApp/include/SampleApp/InteractionManager.h b/SampleApp/include/SampleApp/InteractionManager.h
index d2237235..c2347ce3 100644
--- a/SampleApp/include/SampleApp/InteractionManager.h
+++ b/SampleApp/include/SampleApp/InteractionManager.h
@@ -447,7 +447,7 @@ public:
     /**
      * UXDialogObserverInterface methods
      */
-    void onDialogUXStateChanged(DialogUXState newState) override;
+    void onDialogUXStateChanged(avsCommon::avs::AgentId::IdType agentId, DialogUXState newState) override;
 
     /**
      * CallStateObserverInterface methods
diff --git a/SampleApp/include/SampleApp/UIManager.h b/SampleApp/include/SampleApp/UIManager.h
index 7fccf5e1..aa9727b1 100644
--- a/SampleApp/include/SampleApp/UIManager.h
+++ b/SampleApp/include/SampleApp/UIManager.h
@@ -74,7 +74,7 @@ public:
 
     /// @name DialogUxStateObserverInetrface methods.
     /// @{
-    void onDialogUXStateChanged(DialogUXState state) override;
+    void onDialogUXStateChanged(avsCommon::avs::AgentId::IdType agentId, DialogUXState state) override;
     /// @}
 
     /// @name ConnectionStatusObserverInterface methods.
diff --git a/SampleApp/src/InteractionManager.cpp b/SampleApp/src/InteractionManager.cpp
index 4186d367..1fc62b00 100644
--- a/SampleApp/src/InteractionManager.cpp
+++ b/SampleApp/src/InteractionManager.cpp
@@ -653,7 +653,7 @@ void InteractionManager::disableVideo() {
 }
 #endif
 
-void InteractionManager::onDialogUXStateChanged(DialogUXState state) {
+void InteractionManager::onDialogUXStateChanged(avsCommon::avs::AgentId::IdType agentId, DialogUXState state) {
     m_executor.submit([this, state]() {
         if (DialogUXState::LISTENING == state) {
             if (m_isMicOn && !m_micWrapper->isStreaming()) {
diff --git a/SampleApp/src/UIManager.cpp b/SampleApp/src/UIManager.cpp
index 36bb4378..9fe232e0 100644
--- a/SampleApp/src/UIManager.cpp
+++ b/SampleApp/src/UIManager.cpp
@@ -631,7 +631,7 @@ static const std::string DTMF_MESSAGE =
     "|                                                                            |\n"
     "+----------------------------------------------------------------------------+\n";
 
-void UIManager::onDialogUXStateChanged(DialogUXState state) {
+void UIManager::onDialogUXStateChanged(avsCommon::avs::AgentId::IdType agentId, DialogUXState state) {
     m_executor.submit([this, state]() {
         if (state == m_dialogState) {
             return;
diff --git a/Settings/include/Settings/DeviceSettingsManager.h b/Settings/include/Settings/DeviceSettingsManager.h
index 5a815b81..b58b6568 100644
--- a/Settings/include/Settings/DeviceSettingsManager.h
+++ b/Settings/include/Settings/DeviceSettingsManager.h
@@ -27,6 +27,8 @@
 #include "Settings/Types/AlarmVolumeRampTypes.h"
 #include "Settings/Types/NetworkInfo.h"
 
+#include "Settings/Types/GeolocationEnablement.h"
+
 namespace alexaClientSDK {
 namespace settings {
 
@@ -66,6 +68,9 @@ using LocalesSetting = SettingInterface<DeviceLocales>;
 /// Type for network info.
 using NetworkInfoSetting = SettingInterface<types::NetworkInfo>;
 
+/// Type for geolocation.
+using GeolocationEnablementSetting = SettingInterface<types::GeolocationEnablement>;
+
 /**
  * Enumerates the settings that are kept inside DeviceSettingsManager.
  *
@@ -79,7 +84,8 @@ enum DeviceSettingsIndex {
     TIMEZONE,
     WAKE_WORDS,
     LOCALE,
-    NETWORK_INFO
+    NETWORK_INFO,
+    GEOLOCATION_ENABLEMENT
 };
 
 /// The DeviceSettingsManager will manage all common settings to alexa devices.
@@ -91,7 +97,8 @@ using DeviceSettingsManager = SettingsManager<
     TimeZoneSetting,
     WakeWordsSetting,
     LocalesSetting,
-    NetworkInfoSetting>;
+    NetworkInfoSetting,
+    GeolocationEnablementSetting>;
 
 /// An alias to shorten the name.
 using DeviceSettingManagerSettingConfigurations = std::tuple<
@@ -102,7 +109,8 @@ using DeviceSettingManagerSettingConfigurations = std::tuple<
     SettingConfiguration<TimeZoneSetting>,
     SettingConfiguration<WakeWordsSetting>,
     SettingConfiguration<LocalesSetting>,
-    SettingConfiguration<NetworkInfoSetting>>;
+    SettingConfiguration<NetworkInfoSetting>,
+    SettingConfiguration<GeolocationEnablementSetting>>;
 
 }  // namespace settings
 }  // namespace alexaClientSDK
diff --git a/Settings/include/Settings/Types/GeolocationEnablement.h b/Settings/include/Settings/Types/GeolocationEnablement.h
new file mode 100644
index 00000000..d9f45a0d
--- /dev/null
+++ b/Settings/include/Settings/Types/GeolocationEnablement.h
@@ -0,0 +1,146 @@
+/*
+    * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+    *
+    * Licensed under the Apache License, Version 2.0 (the "License").
+    * You may not use this file except in compliance with the License.
+    * A copy of the License is located at
+    *
+    *     http://aws.amazon.com/apache2.0/
+    *
+    * or in the "license" file accompanying this file. This file is distributed
+    * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+    * express or implied. See the License for the specific language governing
+    * permissions and limitations under the License.
+    */
+
+#ifndef ALEXA_CLIENT_SDK_SETTINGS_INCLUDE_SETTINGS_TYPES_GEOLOCATIONENABLEMENT_H__
+#define ALEXA_CLIENT_SDK_SETTINGS_INCLUDE_SETTINGS_TYPES_GEOLOCATIONENABLEMENT_H__
+
+#include <istream>
+#include <ostream>
+#include <string>
+
+#include <AVSCommon/Utils/JSON/JSONUtils.h>
+
+namespace alexaClientSDK {
+namespace settings {
+namespace types {
+
+/**
+ * Defines the values for Geolocation Enablement setting.
+ */
+enum class GeolocationEnablement {
+    /// Geolocation data will not be uploaded to AVS.
+    DISABLED,
+
+    /// Geolocation data will always be uploaded to AVS.
+    ENABLED
+};
+
+/**
+ * Retrieves the default value of Geolocation Enablement.
+ *
+ * @return The default value Geolocation Enablement.
+ */
+constexpr GeolocationEnablement getGeolocationEnablementDefault() {
+    return GeolocationEnablement::DISABLED;
+}
+
+/**
+ * Convert a @c GeolocationEnablement to an AVS-compliant @c std::string.
+ *
+ * @param enablement The @c GeolocationEnablement to convert.
+ * @return The AVS-compliant string representation of @c enablement.
+ */
+inline std::string enablementToString(GeolocationEnablement enablement) {
+    switch (enablement) {
+        case GeolocationEnablement::ENABLED:
+            return "ENABLED";
+        case GeolocationEnablement::DISABLED:
+            return "DISABLED";
+    }
+    return "unknown GeolocationEnablement";
+}
+
+/**
+ * Convert an AVS-compliant @c string to a @c GeolocationEnablement.
+ *
+ * @param text The string to convert.
+ * @param[out] GeolocationEnablement The converted @c GeolocationEnablement.
+ * @return @c true if the string converted succesfully, else @c false.
+ */
+inline bool stringToGeolocationEnablement(const std::string& text, GeolocationEnablement* enablement) {
+    if (nullptr == enablement) {
+        return false;
+    }
+    if (enablementToString(GeolocationEnablement::ENABLED) == text) {
+        *enablement = GeolocationEnablement::ENABLED;
+        return true;
+    } else if (enablementToString(GeolocationEnablement::DISABLED) == text) {
+        *enablement = GeolocationEnablement::DISABLED;
+        return true;
+    }
+    return false;
+}
+
+/**
+ * Write a @c GeolocationEnablement value to the given stream.
+ *
+ * @param stream The stream to write the value to.
+ * @param value The value to write to the stream as a string.
+ * @return The stream that was passed in and written to.
+ */
+inline std::ostream& operator<<(std::ostream& stream, const GeolocationEnablement& value) {
+    switch (value) {
+        case GeolocationEnablement::DISABLED:
+            stream << "DISABLED";
+            return stream;
+        case GeolocationEnablement::ENABLED:
+            stream << "ENABLED";
+            return stream;
+    }
+
+    stream.setstate(std::ios_base::failbit);
+    return stream;
+}
+
+/**
+ * Converts an input string stream value to GeolocationEnablement.
+ *
+ * @param stream The string stream to retrieve the value from.
+ * @param [out] value The value to write to.
+ * @return The stream that was passed in.
+ */
+inline std::istream& operator>>(std::istream& is, GeolocationEnablement& value) {
+    std::string str;
+    is >> str;
+    if ("DISABLED" == str) {
+        value = GeolocationEnablement::DISABLED;
+    } else if ("ENABLED" == str) {
+        value = GeolocationEnablement::ENABLED;
+    } else {
+        is.setstate(std::ios_base::failbit);
+    }
+    return is;
+}
+
+/**
+ * Convert a @c GeolocationEnablement to a @c rapidjson::Value.
+ *
+ * @param documentNode The @c rapidjson::Value to write to.
+ * @param enablement The @c GeolocationEnablement to convert.
+ * @return @c true if conversion is successful, else @c false.
+ */
+inline bool convertToValue(const rapidjson::Value& documentNode, GeolocationEnablement* enablement) {
+    std::string text;
+    if (!avsCommon::utils::json::jsonUtils::convertToValue(documentNode, &text)) {
+        return false;
+    }
+    return stringToGeolocationEnablement(text, enablement);
+}
+
+}  // namespace types
+}  // namespace settings
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_SETTINGS_INCLUDE_SETTINGS_TYPES_GEOLOCATIONENABLEMENT_H__
\ No newline at end of file
diff --git a/SpeechEncoder/OpusEncoderContext/src/CMakeLists.txt b/SpeechEncoder/OpusEncoderContext/src/CMakeLists.txt
index 4e470c72..5256c48a 100644
--- a/SpeechEncoder/OpusEncoderContext/src/CMakeLists.txt
+++ b/SpeechEncoder/OpusEncoderContext/src/CMakeLists.txt
@@ -3,10 +3,11 @@ add_definitions("-DACSDK_LOG_MODULE=opusEncoderContext")
 add_library(OpusEncoderContext
 OpusEncoderContext.cpp)
 
-find_path(OPUS_INCLUDE_DIR opus)
-find_library(OPUS_LIBRARY opus)
+find_package(Opus ${OPUS_PACKAGE_CONFIG})
+message("OPUS LIBRARY IS: ${Opus_LIBRARIES}")
+message("OPUS INCLUDE DIR IS: ${Opus_INCLUDE_DIR}")
 
-if(NOT OPUS_LIBRARY)
+if(NOT Opus_LIBRARIES)
 	message(FATAL_ERROR "Cannot find libopus")
 endif()
 
@@ -15,7 +16,7 @@ target_include_directories(OpusEncoderContext
 		"${SpeechEncoder_SOURCE_DIR}/include"
 		"${OpusEncoderContext_SOURCE_DIR}/include"
 	PRIVATE
-		${OPUS_INCLUDE_DIR}
+		${Opus_INCLUDE_DIR}
 )
 
 target_link_libraries(OpusEncoderContext
@@ -23,7 +24,7 @@ target_link_libraries(OpusEncoderContext
 		SpeechEncoder
 		AVSCommon
 	PRIVATE
-		${OPUS_LIBRARY}
+		${Opus_LIBRARIES}
 )
 
 # install target
diff --git a/applications/acsdkLibcurlAlexaCommunications/include/acsdkAlexaCommunications/AlexaCommunicationsComponent.h b/applications/acsdkLibcurlAlexaCommunications/include/acsdkAlexaCommunications/AlexaCommunicationsComponent.h
index 6b8a0874..4d8b3e15 100644
--- a/applications/acsdkLibcurlAlexaCommunications/include/acsdkAlexaCommunications/AlexaCommunicationsComponent.h
+++ b/applications/acsdkLibcurlAlexaCommunications/include/acsdkAlexaCommunications/AlexaCommunicationsComponent.h
@@ -18,6 +18,7 @@
 
 #include <memory>
 
+#include <acsdk/MultiAgentInterface/AgentManagerInterface.h>
 #include <acsdkManufactory/Annotated.h>
 #include <acsdkManufactory/Component.h>
 #include <acsdkShutdownManagerInterfaces/ShutdownNotifierInterface.h>
@@ -37,6 +38,7 @@ namespace acsdkAlexaCommunications {
 using AlexaCommunicationsComponent = acsdkManufactory::Component<
     std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface>,
     std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface>,
+    acsdkManufactory::Import<std::shared_ptr<multiAgentInterface::AgentManagerInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::EventTracerInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::InternetConnectionMonitorInterface>>,
diff --git a/applications/acsdkPreviewAlexaClient/include/acsdkPreviewAlexaClient/PreviewAlexaClientComponent.h b/applications/acsdkPreviewAlexaClient/include/acsdkPreviewAlexaClient/PreviewAlexaClientComponent.h
index bcde9482..f3db4c51 100644
--- a/applications/acsdkPreviewAlexaClient/include/acsdkPreviewAlexaClient/PreviewAlexaClientComponent.h
+++ b/applications/acsdkPreviewAlexaClient/include/acsdkPreviewAlexaClient/PreviewAlexaClientComponent.h
@@ -98,6 +98,7 @@ using PreviewAlexaClientComponent = acsdkManufactory::Component<
     std::shared_ptr<acsdkStartupManagerInterfaces::StartupManagerInterface>,
     std::shared_ptr<acsdkSystemClockMonitorInterfaces::SystemClockMonitorInterface>,
     std::shared_ptr<afml::interruptModel::InterruptModel>,
+    std::shared_ptr<multiAgentInterface::AgentManagerInterface>,
     std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface>,
     std::shared_ptr<avsCommon::avs::AudioInputStream>,
     std::shared_ptr<avsCommon::avs::DialogUXStateAggregator>,
@@ -152,7 +153,8 @@ PreviewAlexaClientComponent getComponent(
     const std::shared_ptr<avsCommon::sdkInterfaces::diagnostics::DiagnosticsInterface>& diagnostics,
     const std::shared_ptr<sampleApp::PlatformSpecificValues>& platformSpecificValues,
     const std::shared_ptr<avsCommon::sdkInterfaces::ExpectSpeechTimeoutHandlerInterface>& expectSpeechTimeoutHandler,
-    const std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface>& powerResourceManager);
+    const std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface>& powerResourceManager,
+    const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager);
 
 }  // namespace acsdkPreviewAlexaClient
 }  // namespace alexaClientSDK
diff --git a/applications/acsdkPreviewAlexaClient/src/PreviewAlexaClient.cpp b/applications/acsdkPreviewAlexaClient/src/PreviewAlexaClient.cpp
index 50cf2cb0..159ba2b7 100644
--- a/applications/acsdkPreviewAlexaClient/src/PreviewAlexaClient.cpp
+++ b/applications/acsdkPreviewAlexaClient/src/PreviewAlexaClient.cpp
@@ -176,6 +176,7 @@ using PreviewAlexaClientManufactory = Manufactory<
     std::shared_ptr<acsdkStartupManagerInterfaces::StartupManagerInterface>,
     std::shared_ptr<acsdkSystemClockMonitorInterfaces::SystemClockMonitorInterface>,
     std::shared_ptr<afml::interruptModel::InterruptModel>,
+    std::shared_ptr<multiAgentInterface::AgentManagerInterface>,
     std::shared_ptr<avsCommon::avs::attachment::AttachmentManagerInterface>,
     std::shared_ptr<avsCommon::avs::AudioInputStream>,
     std::shared_ptr<avsCommon::avs::DialogUXStateAggregator>,
@@ -791,7 +792,7 @@ bool PreviewAlexaClient::initialize(
     auto initParams = builder->build();
 
     auto previewAlexaClientComponent = acsdkPreviewAlexaClient::getComponent(
-        std::move(initParams), diagnostics, platformSpecificValues, nullptr, powerResourceManager);
+        std::move(initParams), diagnostics, platformSpecificValues, nullptr, powerResourceManager, nullptr);
 
     std::shared_ptr<PreviewAlexaClientManufactory> manufactory =
         PreviewAlexaClientManufactory::create(previewAlexaClientComponent);
diff --git a/applications/acsdkPreviewAlexaClient/src/PreviewAlexaClientComponent.cpp b/applications/acsdkPreviewAlexaClient/src/PreviewAlexaClientComponent.cpp
index 35729349..7809ccf9 100644
--- a/applications/acsdkPreviewAlexaClient/src/PreviewAlexaClientComponent.cpp
+++ b/applications/acsdkPreviewAlexaClient/src/PreviewAlexaClientComponent.cpp
@@ -149,7 +149,8 @@ PreviewAlexaClientComponent getComponent(
     const std::shared_ptr<avsCommon::sdkInterfaces::diagnostics::DiagnosticsInterface>& diagnostics,
     const std::shared_ptr<sampleApp::PlatformSpecificValues>& platformSpecificValues,
     const std::shared_ptr<avsCommon::sdkInterfaces::ExpectSpeechTimeoutHandlerInterface>& expectSpeechTimeoutHandler,
-    const std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface>& powerResourceManager) {
+    const std::shared_ptr<avsCommon::sdkInterfaces::PowerResourceManagerInterface>& powerResourceManager,
+    const std::shared_ptr<multiAgentInterface::AgentManagerInterface>& agentManager) {
     /// This component is provided as a preview of changes to come. The imports, exports, and factory methods
     /// will change while manufactory integration is incrementally released over the next several releases.
 
@@ -165,6 +166,7 @@ PreviewAlexaClientComponent getComponent(
         /// Implementations created at the application level, added to the manufactory to satisfy dependencies.
         .addInstance(expectSpeechTimeoutHandler)
         .addInstance(powerResourceManager)
+        .addInstance(agentManager)
 
         /// Baseline SDK components. Applications are not expected to modify these.
         .addComponent(acsdkCore::getComponent())
diff --git a/capabilities/AudioPlayer/acsdkAudioPlayer/include/acsdkAudioPlayer/AudioPlayer.h b/capabilities/AudioPlayer/acsdkAudioPlayer/include/acsdkAudioPlayer/AudioPlayer.h
index 4b919485..63bec069 100644
--- a/capabilities/AudioPlayer/acsdkAudioPlayer/include/acsdkAudioPlayer/AudioPlayer.h
+++ b/capabilities/AudioPlayer/acsdkAudioPlayer/include/acsdkAudioPlayer/AudioPlayer.h
@@ -53,6 +53,8 @@
 #include <AVSCommon/Utils/Timing/Timer.h>
 #include <AVSCommon/Utils/Timing/TimeUtils.h>
 #include <Captions/CaptionManagerInterface.h>
+#include <RegistrationManager/CustomerDataHandler.h>
+#include <RegistrationManager/CustomerDataManagerInterface.h>
 
 #include "AudioItem.h"
 #include "ClearBehavior.h"
@@ -128,6 +130,7 @@ class AudioPlayer
         , public avsCommon::sdkInterfaces::LocalPlaybackHandlerInterface
         , public avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface
         , public avsCommon::utils::mediaPlayer::MediaPlayerFactoryObserverInterface
+        , public alexaClientSDK::registrationManager::CustomerDataHandler
         , public avsCommon::utils::RequiresShutdown
         , public std::enable_shared_from_this<AudioPlayer> {
 public:
@@ -146,6 +149,7 @@ public:
      * @param contextManager The AVS Context manager used to generate system context for events.
      * @param exceptionSender The object to use for sending AVS Exception messages.
      * @param playbackRouter The @c PlaybackRouterInterface instance to use when @c AudioPlayer becomes active.
+     * @param customerDataManager The @c CustomerDataManager object that tracks components managing customer data.
      * @param captionManager The @c CaptionManagerInterface instance to use for handling captions.
      * @param metricRecorder The metric recorder.
      * @param shutdownNotifier The object to notify this AudioPlayer when to shut down.
@@ -165,6 +169,7 @@ public:
         const std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface>& contextManager,
         const std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>& exceptionSender,
         const std::shared_ptr<avsCommon::sdkInterfaces::PlaybackRouterInterface>& playbackRouter,
+        const std::shared_ptr<registrationManager::CustomerDataManagerInterface>& customerDataManager,
         const std::shared_ptr<captions::CaptionManagerInterface>& captionManager,
         const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
         const std::shared_ptr<acsdkShutdownManagerInterfaces::ShutdownNotifierInterface>& shutdownNotifier,
@@ -184,6 +189,7 @@ public:
      * @param contextManager The AVS Context manager used to generate system context for events.
      * @param exceptionSender The object to use for sending AVS Exception messages.
      * @param playbackRouter The @c PlaybackRouterInterface instance to use when @c AudioPlayer becomes active.
+     * @param customerDataManager The @c CustomerDataManager object that tracks components managing customer data.
      * @param captionManager The optional @c CaptionManagerInterface instance to use for handling captions.
      * @param metricRecorder The metric recorder.
      * @return A @c std::shared_ptr to the new @c AudioPlayer instance.
@@ -195,6 +201,7 @@ public:
         std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
         std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
         std::shared_ptr<avsCommon::sdkInterfaces::PlaybackRouterInterface> playbackRouter,
+        std::shared_ptr<registrationManager::CustomerDataManagerInterface> customerDataManager,
         std::shared_ptr<captions::CaptionManagerInterface> captionManager = nullptr,
         std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder = nullptr);
 
@@ -288,6 +295,11 @@ public:
     std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> getCapabilityConfigurations() override;
     /// @}
 
+    /// @name CustomerDataHandler Functions
+    /// @{
+    void clearData() override;
+    /// @}
+
 private:
     /**
      * A utility class to manage interaction with the MessageSender.
@@ -396,6 +408,7 @@ private:
      * @param contextManager The AVS Context manager used to generate system context for events.
      * @param exceptionSender The object to use for sending AVS Exception messages.
      * @param playbackRouter The playback router used for switching playback buttons handler to default.
+     * @param customerDataManager The @c CustomerDataManager object that tracks components managing customer data.
      * @param audioChannelVolumeInterfaces A list of @c ChannelVolumeInterface instances to use to control/attenuate
      * channel volume. These instances are required for controlling volume for the @c MediaPlayerInterface instances
      * provided by @param mediaResourceProvider.
@@ -410,6 +423,7 @@ private:
         std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
         std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
         std::shared_ptr<avsCommon::sdkInterfaces::PlaybackRouterInterface> playbackRouter,
+        std::shared_ptr<registrationManager::CustomerDataManagerInterface> customerDataManager,
         std::vector<std::shared_ptr<avsCommon::sdkInterfaces::ChannelVolumeInterface>> audioChannelVolumeInterfaces,
         std::shared_ptr<captions::CaptionManagerInterface> captionManager = nullptr,
         std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder = nullptr);
@@ -898,8 +912,10 @@ private:
      * Factory
      *
      * @param playbackItem PlayDirectiveInfo holding the MediaPlayer
+     * @param waitForStopped Whether to wait for @c onPlaybackStopped / @c onPlaybackError before releasing the
+     * MediaPlayer
      */
-    void stopAndReleaseMediaPlayer(std::shared_ptr<PlayDirectiveInfo> playbackItem);
+    void stopAndReleaseMediaPlayer(std::shared_ptr<PlayDirectiveInfo> playbackItem, bool waitForStopped = false);
 
     /**
      * Clean-up MediaPlayer information in a PlayDirectiveInfo, and return it to the Factory
@@ -1111,6 +1127,12 @@ private:
      */
     bool m_playNextItemAfterStopped;
 
+    /**
+     * A flag which is set when calling @c MediaPlayerInterface::stop(), and used by @c onPlaybackStopped() to decide
+     * whether to release the @c MediaPlayerInterface.
+     */
+    bool m_releaseWhenStopped;
+
     /**
      * A flag which is set when calling @c MediaPlayerInterface::stop(), and cleared in @c executeOnPlaybackStopped().
      * This flag is used to tell if the @c AudioPlayer is in the process of stopping playback.
diff --git a/capabilities/AudioPlayer/acsdkAudioPlayer/include/acsdkAudioPlayer/AudioPlayerComponent.h b/capabilities/AudioPlayer/acsdkAudioPlayer/include/acsdkAudioPlayer/AudioPlayerComponent.h
index 4c162ff3..ba888a42 100644
--- a/capabilities/AudioPlayer/acsdkAudioPlayer/include/acsdkAudioPlayer/AudioPlayerComponent.h
+++ b/capabilities/AudioPlayer/acsdkAudioPlayer/include/acsdkAudioPlayer/AudioPlayerComponent.h
@@ -39,6 +39,7 @@
 #include <AVSCommon/Utils/MediaPlayer/PooledMediaResourceProviderInterface.h>
 #include <AVSCommon/Utils/Metrics/MetricRecorderInterface.h>
 #include <Captions/CaptionManagerInterface.h>
+#include <RegistrationManager/CustomerDataManagerInterface.h>
 
 namespace alexaClientSDK {
 namespace acsdkAudioPlayer {
@@ -64,6 +65,7 @@ acsdkManufactory::Component<
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::PlaybackRouterInterface>>,
+    acsdkManufactory::Import<std::shared_ptr<registrationManager::CustomerDataManagerInterface>>,
     acsdkManufactory::Import<std::shared_ptr<captions::CaptionManagerInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>>,
     acsdkManufactory::Import<std::shared_ptr<acsdkShutdownManagerInterfaces::ShutdownNotifierInterface>>,
@@ -91,6 +93,7 @@ acsdkManufactory::Component<
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::PlaybackRouterInterface>>,
+    acsdkManufactory::Import<std::shared_ptr<registrationManager::CustomerDataManagerInterface>>,
     acsdkManufactory::Import<std::shared_ptr<captions::CaptionManagerInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>>,
     acsdkManufactory::Import<std::shared_ptr<acsdkShutdownManagerInterfaces::ShutdownNotifierInterface>>,
diff --git a/capabilities/AudioPlayer/acsdkAudioPlayer/src/AudioPlayer.cpp b/capabilities/AudioPlayer/acsdkAudioPlayer/src/AudioPlayer.cpp
index ca48d110..d3012e95 100644
--- a/capabilities/AudioPlayer/acsdkAudioPlayer/src/AudioPlayer.cpp
+++ b/capabilities/AudioPlayer/acsdkAudioPlayer/src/AudioPlayer.cpp
@@ -25,6 +25,7 @@
 #include <rapidjson/stringbuffer.h>
 #include <rapidjson/error/en.h>
 
+#include <AVSCommon/AVS/AgentId.h>
 #include <AVSCommon/AVS/CapabilityConfiguration.h>
 #include <AVSCommon/AVS/EventBuilder.h>
 #include <AVSCommon/SDKInterfaces/Audio/MixingBehavior.h>
@@ -337,6 +338,7 @@ static void submitMetric(
     const std::string& trackPlaylistType = "",
     const std::string& trackDomainNameHash = "") {
     auto metricBuilder = MetricEventBuilder{}.setActivityName(metricActivityName).addDataPoint(dataPoint);
+    metricBuilder.setMetricContext(MetricContext{avsCommon::avs::AgentId::getAlexaAgentId()});
     if (!msgId.empty()) {
         metricBuilder.addDataPoint(DataPointStringBuilder{}.setName("DIRECTIVE_MESSAGE_ID").setValue(msgId).build());
     }
@@ -390,6 +392,7 @@ static void submitInstanceMetric(
         return;
     }
     auto metricBuilder = MetricEventBuilder{}.setActivityName(AUDIO_PLAYER_METRIC_PREFIX + "ENTRY");
+    metricBuilder.setMetricContext(MetricContext{avsCommon::avs::AgentId::getAlexaAgentId()});
     metricBuilder.addDataPoint(DataPointStringBuilder{}.setName(METRIC_KEY_SEGMENT_ID).setValue(segmentId).build());
     metricBuilder.addDataPoint(DataPointStringBuilder{}.setName(METRIC_KEY_ACTOR).setValue("AudioPlayerCA").build());
     metricBuilder.addDataPoint(DataPointStringBuilder{}.setName(METRIC_KEY_ENTRY_NAME).setValue(name).build());
@@ -418,6 +421,7 @@ static void createAssociation(
     }
 
     auto metricBuilder = MetricEventBuilder{}.setActivityName(AUDIO_PLAYER_METRIC_PREFIX + "ASSOCIATION");
+    metricBuilder.setMetricContext(MetricContext{avsCommon::avs::AgentId::getAlexaAgentId()});
     metricBuilder.addDataPoint(
         DataPointStringBuilder{}.setName(METRIC_KEY_ASSOCIATE_FROM).setValue(associateFrom).build());
     metricBuilder.addDataPoint(DataPointStringBuilder{}.setName(METRIC_KEY_ASSOCIATE_TO).setValue(associateTo).build());
@@ -500,6 +504,7 @@ std::shared_ptr<acsdkAudioPlayerInterfaces::AudioPlayerInterface> AudioPlayer::c
     const std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface>& contextManager,
     const std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>& exceptionSender,
     const std::shared_ptr<avsCommon::sdkInterfaces::PlaybackRouterInterface>& playbackRouter,
+    const std::shared_ptr<registrationManager::CustomerDataManagerInterface>& customerDataManager,
     const std::shared_ptr<captions::CaptionManagerInterface>& captionManager,
     const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder,
     const std::shared_ptr<acsdkShutdownManagerInterfaces::ShutdownNotifierInterface>& shutdownNotifier,
@@ -526,6 +531,7 @@ std::shared_ptr<acsdkAudioPlayerInterfaces::AudioPlayerInterface> AudioPlayer::c
         contextManager,
         exceptionSender,
         playbackRouter,
+        customerDataManager,
         captionManager,
         metricRecorder);
 
@@ -548,6 +554,7 @@ std::shared_ptr<AudioPlayer> AudioPlayer::create(
     std::shared_ptr<ContextManagerInterface> contextManager,
     std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
     std::shared_ptr<PlaybackRouterInterface> playbackRouter,
+    std::shared_ptr<registrationManager::CustomerDataManagerInterface> customerDataManager,
     std::shared_ptr<captions::CaptionManagerInterface> captionManager,
     std::shared_ptr<MetricRecorderInterface> metricRecorder) {
     if (nullptr == mediaResourceProvider) {
@@ -568,6 +575,9 @@ std::shared_ptr<AudioPlayer> AudioPlayer::create(
     } else if (nullptr == playbackRouter) {
         ACSDK_ERROR(LX("createFailed").d("reason", "nullPlaybackRouter"));
         return nullptr;
+    } else if (nullptr == customerDataManager) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullCustomerDataManager"));
+        return nullptr;
     }
 
     auto audioChannelVolumeInterfaces = mediaResourceProvider->getSpeakers();
@@ -583,6 +593,7 @@ std::shared_ptr<AudioPlayer> AudioPlayer::create(
         contextManager,
         exceptionSender,
         playbackRouter,
+        customerDataManager,
         audioChannelVolumeInterfaces,
         captionManager,
         metricRecorder));
@@ -692,7 +703,7 @@ void AudioPlayer::cancelDirective(std::shared_ptr<DirectiveInfo> info) {
             for (auto it = m_audioPlayQueue.begin(); it != m_audioPlayQueue.end(); it++) {
                 if (messageId == (*it)->messageId) {
                     if (it->get()->mediaPlayer) {
-                        stopAndReleaseMediaPlayer(*it);
+                        stopAndReleaseMediaPlayer(*it, false);
                     }
                     m_audioPlayQueue.erase(it);
                     break;
@@ -1003,10 +1014,12 @@ AudioPlayer::AudioPlayer(
     std::shared_ptr<ContextManagerInterface> contextManager,
     std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
     std::shared_ptr<PlaybackRouterInterface> playbackRouter,
+    std::shared_ptr<registrationManager::CustomerDataManagerInterface> customerDataManager,
     std::vector<std::shared_ptr<ChannelVolumeInterface>> audioChannelVolumeInterfaces,
     std::shared_ptr<captions::CaptionManagerInterface> captionManager,
     std::shared_ptr<MetricRecorderInterface> metricRecorder) :
         CapabilityAgent{NAMESPACE, exceptionSender},
+        CustomerDataHandler{std::move(customerDataManager)},
         RequiresShutdown{"AudioPlayer"},
         m_mediaResourceProvider{std::move(mediaResourceProvider)},
         m_messageSender{messageSender},
@@ -1020,6 +1033,7 @@ AudioPlayer::AudioPlayer(
         m_currentlyPlaying(std::make_shared<PlayDirectiveInfo>("", "")),
         m_offset{std::chrono::milliseconds{std::chrono::milliseconds::zero()}},
         m_playNextItemAfterStopped{false},
+        m_releaseWhenStopped{false},
         m_isStopCalled{false},
         m_okToRequestNextTrack{false},
         m_isAcquireChannelRequestPending{false},
@@ -2028,6 +2042,10 @@ void AudioPlayer::executeOnPlaybackStopped(SourceId id, const MediaPlayerState&
                 }
             }
             m_isStopCalled = false;
+            if (m_releaseWhenStopped) {
+                m_releaseWhenStopped = false;
+                releaseMediaPlayer(m_currentlyPlaying);
+            }
             return;
         case AudioPlayerState::IDLE:
         case AudioPlayerState::STOPPED:
@@ -2355,12 +2373,12 @@ void AudioPlayer::clearPlayQueue(const bool stopCurrentPlayer) {
     // release all MediaPlayers on the play queue
     for (auto& it : m_audioPlayQueue) {
         if (it->mediaPlayer) {
-            stopAndReleaseMediaPlayer(it);
+            stopAndReleaseMediaPlayer(it, false);
         }
     }
     m_audioPlayQueue.clear();
     if (stopCurrentPlayer) {
-        stopAndReleaseMediaPlayer(m_currentlyPlaying);
+        stopAndReleaseMediaPlayer(m_currentlyPlaying, true);
 
         // Play queue and currently playing item are stopped and released.
         // Do not send PNF anymore.
@@ -2373,14 +2391,24 @@ void AudioPlayer::clearPlayQueue(const bool stopCurrentPlayer) {
     }
 }
 
-void AudioPlayer::stopAndReleaseMediaPlayer(std::shared_ptr<PlayDirectiveInfo> playbackItem) {
+void AudioPlayer::stopAndReleaseMediaPlayer(std::shared_ptr<PlayDirectiveInfo> playbackItem, bool waitForStopped) {
+    bool active = false;
+    if (m_isStartingPlayback || m_isPausingPlayback || m_currentState == AudioPlayerState::BUFFER_UNDERRUN || m_currentState == AudioPlayerState::PLAYING || m_currentState == AudioPlayerState::PAUSED) {
+        active = true;
+    }
+    m_releaseWhenStopped = waitForStopped && active;
+
     m_isStartingPlayback = false;
     m_isPausingPlayback = false;
 
     if (playbackItem->mediaPlayer) {
         playbackItem->mediaPlayer->stop(playbackItem->sourceId);
     }
-    releaseMediaPlayer(playbackItem);
+    if (!m_releaseWhenStopped) {
+        releaseMediaPlayer(playbackItem);
+    } else {
+        m_playNextItemAfterStopped = false;
+    }
 }
 
 void AudioPlayer::releaseMediaPlayer(std::shared_ptr<PlayDirectiveInfo> playbackItem) {
@@ -3430,6 +3458,13 @@ std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> Aud
     return m_capabilityConfigurations;
 }
 
+void AudioPlayer::clearData() {
+    ACSDK_DEBUG5(LX(__func__));
+    m_executor.submit([this] {
+        clearPlayQueue(true);
+    });
+}
+
 void AudioPlayer::attachPlaybackAttributesIfAvailable(
     rapidjson::Value& parent,
     rapidjson::Document::AllocatorType& allocator) {
diff --git a/capabilities/AudioPlayer/acsdkAudioPlayer/src/AudioPlayerComponent.cpp b/capabilities/AudioPlayer/acsdkAudioPlayer/src/AudioPlayerComponent.cpp
index 1e7312e5..56b4f8ae 100644
--- a/capabilities/AudioPlayer/acsdkAudioPlayer/src/AudioPlayerComponent.cpp
+++ b/capabilities/AudioPlayer/acsdkAudioPlayer/src/AudioPlayerComponent.cpp
@@ -124,6 +124,7 @@ Component<
     Import<std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface>>,
     Import<std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface>>,
     Import<std::shared_ptr<avsCommon::sdkInterfaces::PlaybackRouterInterface>>,
+    Import<std::shared_ptr<registrationManager::CustomerDataManagerInterface>>,
     Import<std::shared_ptr<captions::CaptionManagerInterface>>,
     Import<std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>>,
     Import<std::shared_ptr<acsdkShutdownManagerInterfaces::ShutdownNotifierInterface>>,
@@ -145,6 +146,7 @@ Component<
     Import<std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface>>,
     Import<std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface>>,
     Import<std::shared_ptr<avsCommon::sdkInterfaces::PlaybackRouterInterface>>,
+    Import<std::shared_ptr<registrationManager::CustomerDataManagerInterface>>,
     Import<std::shared_ptr<captions::CaptionManagerInterface>>,
     Import<std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>>,
     Import<std::shared_ptr<acsdkShutdownManagerInterfaces::ShutdownNotifierInterface>>,
diff --git a/capabilities/AudioPlayer/acsdkAudioPlayer/src/CMakeLists.txt b/capabilities/AudioPlayer/acsdkAudioPlayer/src/CMakeLists.txt
index d9a871dc..a763c821 100644
--- a/capabilities/AudioPlayer/acsdkAudioPlayer/src/CMakeLists.txt
+++ b/capabilities/AudioPlayer/acsdkAudioPlayer/src/CMakeLists.txt
@@ -11,6 +11,7 @@ add_library(acsdkAudioPlayer
 
 target_include_directories(acsdkAudioPlayer PUBLIC
     "${acsdkAudioPlayer_SOURCE_DIR}/include"
+    "${RegistrationManager_SOURCE_DIR}/include"
     "${CRYPTO_INCLUDE_DIRS}")
 target_link_libraries(acsdkAudioPlayer
     acsdkAudioPlayerInterfaces
@@ -19,6 +20,7 @@ target_link_libraries(acsdkAudioPlayer
     acsdkShutdownManagerInterfaces
     Captions
     AVSCommon
+    RegistrationManager
     "${CRYPTO_LDFLAGS}")
 
 
diff --git a/capabilities/AudioPlayer/acsdkAudioPlayer/test/AudioPlayerTest.cpp b/capabilities/AudioPlayer/acsdkAudioPlayer/test/AudioPlayerTest.cpp
index 6b42bfad..51f576b2 100644
--- a/capabilities/AudioPlayer/acsdkAudioPlayer/test/AudioPlayerTest.cpp
+++ b/capabilities/AudioPlayer/acsdkAudioPlayer/test/AudioPlayerTest.cpp
@@ -43,6 +43,7 @@
 #include <AVSCommon/Utils/Memory/Memory.h>
 #include <AVSCommon/Utils/Metrics/MockMetricRecorder.h>
 #include <MockCaptionManager.h>
+#include <RegistrationManager/MockCustomerDataManager.h>
 
 #include "acsdkAudioPlayer/AudioPlayer.h"
 
@@ -662,6 +663,9 @@ public:
     /// A mock @c CaptionManager instance to handle captions parsing.
     std::shared_ptr<MockCaptionManager> m_mockCaptionManager;
 
+    /// A mock @c CustomerDataManager instance to manage customer sensitive data.
+    std::shared_ptr<registrationManager::MockCustomerDataManager> m_mockCustomerDataManager;
+
     /// Attachment manager used to create a reader.
     std::shared_ptr<AttachmentManager> m_attachmentManager;
 
@@ -891,6 +895,7 @@ void AudioPlayerTest::SetUp() {
     m_attachmentManager = std::make_shared<AttachmentManager>(AttachmentManager::AttachmentType::IN_PROCESS);
     m_mockChannelVolume = std::make_shared<NiceMock<MockChannelVolumeInterface>>();
     m_mockPlaybackRouter = std::make_shared<NiceMock<MockPlaybackRouter>>();
+    m_mockCustomerDataManager = std::make_shared<NiceMock<registrationManager::MockCustomerDataManager>>();
     m_mockMediaPlayer = MockMediaPlayer::create();
     ASSERT_TRUE(m_mockMediaPlayer);
     m_mockMediaPlayerTrack2 = MockMediaPlayer::create();
@@ -911,6 +916,7 @@ void AudioPlayerTest::SetUp() {
         m_mockContextManager,
         m_mockExceptionSender,
         m_mockPlaybackRouter,
+        m_mockCustomerDataManager,
         m_mockCaptionManager,
         m_mockMetricRecorder);
 
@@ -955,6 +961,7 @@ void AudioPlayerTest::reSetUp(int numberOfPlayers) {
         m_mockContextManager,
         m_mockExceptionSender,
         m_mockPlaybackRouter,
+        m_mockCustomerDataManager,
         m_mockCaptionManager,
         m_mockMetricRecorder);
 
@@ -1373,6 +1380,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockContextManager,
         m_mockExceptionSender,
         m_mockPlaybackRouter,
+        m_mockCustomerDataManager,
         m_mockCaptionManager,
         m_mockMetricRecorder);
     EXPECT_EQ(testAudioPlayer, nullptr);
@@ -1386,6 +1394,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockContextManager,
         m_mockExceptionSender,
         m_mockPlaybackRouter,
+        m_mockCustomerDataManager,
         m_mockCaptionManager,
         m_mockMetricRecorder);
     EXPECT_EQ(testAudioPlayer, nullptr);
@@ -1399,6 +1408,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockContextManager,
         m_mockExceptionSender,
         m_mockPlaybackRouter,
+        m_mockCustomerDataManager,
         m_mockCaptionManager,
         m_mockMetricRecorder);
     EXPECT_EQ(testAudioPlayer, nullptr);
@@ -1412,6 +1422,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         nullptr,
         m_mockExceptionSender,
         m_mockPlaybackRouter,
+        m_mockCustomerDataManager,
         m_mockCaptionManager,
         m_mockMetricRecorder);
     EXPECT_EQ(testAudioPlayer, nullptr);
@@ -1425,6 +1436,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockContextManager,
         nullptr,
         m_mockPlaybackRouter,
+        m_mockCustomerDataManager,
         m_mockCaptionManager,
         m_mockMetricRecorder);
     EXPECT_EQ(testAudioPlayer, nullptr);
@@ -1438,6 +1450,21 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockContextManager,
         m_mockExceptionSender,
         nullptr,
+        m_mockCustomerDataManager,
+        m_mockCaptionManager,
+        m_mockMetricRecorder);
+    EXPECT_EQ(testAudioPlayer, nullptr);
+
+    m_mockMediaResourceProvider = PooledMediaResourceProvider::createPooledMediaResourceProviderInterface(
+        pool, {m_mockChannelVolume}, FINGERPRINT);
+    testAudioPlayer = AudioPlayer::create(
+        m_mockMediaResourceProvider,
+        m_mockMessageSender,
+        m_mockFocusManager,
+        m_mockContextManager,
+        m_mockExceptionSender,
+        m_mockPlaybackRouter,
+        nullptr,
         m_mockCaptionManager,
         m_mockMetricRecorder);
     EXPECT_EQ(testAudioPlayer, nullptr);
diff --git a/capabilities/AudioPlayer/acsdkAudioPlayer/test/CMakeLists.txt b/capabilities/AudioPlayer/acsdkAudioPlayer/test/CMakeLists.txt
index 9e8044c3..3d68eefd 100644
--- a/capabilities/AudioPlayer/acsdkAudioPlayer/test/CMakeLists.txt
+++ b/capabilities/AudioPlayer/acsdkAudioPlayer/test/CMakeLists.txt
@@ -5,4 +5,4 @@ set(INCLUDE_PATH
 	"${AVSCommon_SOURCE_DIR}/Utils/test"
 	"${CaptionsTestLib_INCLUDE_DIRS}")
 
-discover_unit_tests("${INCLUDE_PATH}" "acsdkAudioPlayer;CaptionsTestLib;UtilsCommonTestLib;AVSCommon;SDKInterfacesTests")
+discover_unit_tests("${INCLUDE_PATH}" "acsdkAudioPlayer;CaptionsTestLib;UtilsCommonTestLib;AVSCommon;SDKInterfacesTests;RegistrationManagerTestUtils")
diff --git a/capabilities/DeviceSetup/acsdkDeviceSetup/include/acsdkDeviceSetup/DeviceSetupFactory.h b/capabilities/DeviceSetup/acsdkDeviceSetup/include/acsdkDeviceSetup/DeviceSetupFactory.h
new file mode 100644
index 00000000..eebe0078
--- /dev/null
+++ b/capabilities/DeviceSetup/acsdkDeviceSetup/include/acsdkDeviceSetup/DeviceSetupFactory.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDKDEVICESETUP_DEVICESETUPFACTORY_H_
+#define ACSDKDEVICESETUP_DEVICESETUPFACTORY_H_
+
+#include <memory>
+
+#include <acsdkDeviceSetupInterfaces/DeviceSetupInterface.h>
+
+#include <AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h>
+#include <AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h>
+#include <AVSCommon/SDKInterfaces/MessageSenderInterface.h>
+#include <AVSCommon/Utils/Optional.h>
+
+namespace alexaClientSDK {
+namespace acsdkDeviceSetup {
+
+/// This structure contains the interfaces to interact with the InputController Capability Agent.
+struct DeviceSetupFactoryInterfaces {
+    /// Instance of DeviceSetup.
+    std::shared_ptr<acsdkDeviceSetupInterfaces::DeviceSetupInterface> deviceSetup;
+};
+
+/**
+ * Creates a new DeviceSetup instance.
+ *
+ * @param messageSender Used for sending events.
+ * @return An @c Optional @c DeviceSetupFactoryInterfaces object.
+ */
+avsCommon::utils::Optional<DeviceSetupFactoryInterfaces> createDeviceSetup(
+    const std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface>& messageSender);
+
+}  // namespace acsdkInteractionModel
+}  // namespace alexaClientSDK
+
+#endif  // ACSDKDEVICESETUP_DEVICESETUPFACTORY_H_
diff --git a/capabilities/DeviceSetup/acsdkDeviceSetup/src/CMakeLists.txt b/capabilities/DeviceSetup/acsdkDeviceSetup/src/CMakeLists.txt
index 5039ccce..28e475ce 100644
--- a/capabilities/DeviceSetup/acsdkDeviceSetup/src/CMakeLists.txt
+++ b/capabilities/DeviceSetup/acsdkDeviceSetup/src/CMakeLists.txt
@@ -3,6 +3,7 @@ add_definitions("-DACSDK_LOG_MODULE=acsdkDeviceSetup")
 add_library(
     acsdkDeviceSetup
     DeviceSetup.cpp
+    DeviceSetupFactory.cpp
     DeviceSetupMessageRequest.cpp
     DeviceSetupComponent.cpp
 )
diff --git a/capabilities/DeviceSetup/acsdkDeviceSetup/src/DeviceSetupFactory.cpp b/capabilities/DeviceSetup/acsdkDeviceSetup/src/DeviceSetupFactory.cpp
new file mode 100644
index 00000000..4516a871
--- /dev/null
+++ b/capabilities/DeviceSetup/acsdkDeviceSetup/src/DeviceSetupFactory.cpp
@@ -0,0 +1,38 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include "acsdkDeviceSetup/DeviceSetup.h"
+#include "acsdkDeviceSetup/DeviceSetupFactory.h"
+
+namespace alexaClientSDK {
+namespace acsdkDeviceSetup {
+
+using namespace avsCommon::utils;
+
+Optional<DeviceSetupFactoryInterfaces> createDeviceSetup(
+    const std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface>& messageSender) {
+    auto deviceSetup = DeviceSetup::createDeviceSetupInterface(messageSender);
+    if (!deviceSetup) {
+        return Optional<DeviceSetupFactoryInterfaces>();
+    }
+
+    DeviceSetupFactoryInterfaces interfaces;
+    interfaces.deviceSetup = deviceSetup;
+
+    return Optional<DeviceSetupFactoryInterfaces>(interfaces);
+}
+
+}  // namespace acsdkDeviceSetup
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/capabilities/DoNotDisturb/acsdkDoNotDisturb/include/acsdkDoNotDisturb/DoNotDisturbCapabilityAgent.h b/capabilities/DoNotDisturb/acsdkDoNotDisturb/include/acsdkDoNotDisturb/DoNotDisturbCapabilityAgent.h
index 2c3188fa..dd04cd4f 100644
--- a/capabilities/DoNotDisturb/acsdkDoNotDisturb/include/acsdkDoNotDisturb/DoNotDisturbCapabilityAgent.h
+++ b/capabilities/DoNotDisturb/acsdkDoNotDisturb/include/acsdkDoNotDisturb/DoNotDisturbCapabilityAgent.h
@@ -252,6 +252,9 @@ private:
     /// Mutex to synchronize operations related to connection state.
     std::mutex m_connectedStateMutex;
 
+    /// Mutex to synchronize operations related to dndModeSetting.
+    mutable std::mutex m_dndModeSettingMutex;
+
     /// Flag indicating whether there were changes made to the DND status while being offline.
     std::atomic_bool m_hasOfflineChanges;
 
diff --git a/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DNDSettingProtocol.cpp b/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DNDSettingProtocol.cpp
index 82222807..035ea063 100644
--- a/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DNDSettingProtocol.cpp
+++ b/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DNDSettingProtocol.cpp
@@ -179,15 +179,11 @@ bool DNDSettingProtocol::avsChange(
         return false;
     }
 
-    std::promise<bool> requestSaved;
-    auto future = requestSaved.get_future();
-    m_executor.submit([this, applyChange, revertChange, notifyObservers, &requestSaved]() {
+    m_executor.submit([this, applyChange, revertChange, notifyObservers]() {
         // Log request before setting the value for recovery.
         if (!m_storage->updateSettingStatus(m_key, SettingStatus::AVS_CHANGE_IN_PROGRESS)) {
-            requestSaved.set_value(false);
             return;
         }
-        requestSaved.set_value(true);
 
         notifyObservers(SettingNotifications::AVS_CHANGE_IN_PROGRESS);
 
@@ -217,7 +213,7 @@ bool DNDSettingProtocol::avsChange(
             ACSDK_ERROR(LX("avsChangeFailed").d("reason", "cannotUpdateStatus"));
         }
     });
-    return future.get();
+    return true;
 }
 
 bool DNDSettingProtocol::restoreValue(ApplyDbChangeFunction applyChange, SettingNotificationFunction notifyObservers) {
diff --git a/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DoNotDisturbCapabilityAgent.cpp b/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DoNotDisturbCapabilityAgent.cpp
index 16106158..dabc3b24 100644
--- a/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DoNotDisturbCapabilityAgent.cpp
+++ b/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DoNotDisturbCapabilityAgent.cpp
@@ -173,6 +173,7 @@ DoNotDisturbCapabilityAgent::DoNotDisturbCapabilityAgent(
 }
 
 std::shared_ptr<settings::DoNotDisturbSetting> DoNotDisturbCapabilityAgent::getDoNotDisturbSetting() const {
+    std::lock_guard<std::mutex> lock(m_dndModeSettingMutex);
     return m_dndModeSetting;
 }
 
@@ -186,6 +187,7 @@ bool DoNotDisturbCapabilityAgent::initialize(
     const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder) {
     auto metadata = getDoNotDisturbEventsMetadata();
     auto protocol = DNDSettingProtocol::create(metadata, shared_from_this(), settingsStorage, metricRecorder);
+    std::lock_guard<std::mutex> lock(m_dndModeSettingMutex);
     m_dndModeSetting = settings::Setting<bool>::create(false, std::move(protocol));
     return m_dndModeSetting != nullptr;
 }
@@ -299,6 +301,7 @@ void DoNotDisturbCapabilityAgent::doShutdown() {
 
     m_executor.waitForSubmittedTasks();
     m_executor.shutdown();
+    std::lock_guard<std::mutex> lock(m_dndModeSettingMutex);
     m_dndModeSetting.reset();
 }
 
@@ -313,7 +316,7 @@ bool DoNotDisturbCapabilityAgent::handleSetDoNotDisturbDirective(
         sendExceptionEncounteredAndReportFailed(info, errorMessage);
         return false;
     }
-
+    std::lock_guard<std::mutex> lock(m_dndModeSettingMutex);
     m_dndModeSetting->setAvsChange(state);
 
     return true;
@@ -352,6 +355,7 @@ std::shared_future<bool> DoNotDisturbCapabilityAgent::sendChangedEvent(const std
 
     // Avoid a race condition where doShutdown() resets the m_dndModeSetting pointer
     // while the lambda executes, causing a segfault if m_dndModeSetting is dereferenced.
+    std::lock_guard<std::mutex> lock(m_dndModeSettingMutex);
     auto dndModeSetting = m_dndModeSetting;
 
     // Sequentialize event processing so that no directive or another event would be handled while we sending this event
@@ -430,8 +434,15 @@ void DoNotDisturbCapabilityAgent::onConnectionStatusChanged(
     const ConnectionStatusObserverInterface::Status status,
     const ConnectionStatusObserverInterface::ChangedReason reason) {
     std::lock_guard<std::mutex> guard(m_connectedStateMutex);
+    std::lock_guard<std::mutex> lock(m_dndModeSettingMutex);
 
     m_isConnected = status == ConnectionStatusObserverInterface::Status::CONNECTED;
+
+    //Check if doShutdown() reset the m_dndModeSetting pointer and return
+    if (m_dndModeSetting == nullptr){
+        ACSDK_ERROR(LX("connectionUpdateFailed").d("reason", "DoNotDisturbCapabilityAgentShutdown"));
+        return;
+    }
     if (m_isConnected) {
         std::string modeString = m_dndModeSetting->get() ? "true" : "false";
         if (m_hasOfflineChanges) {
diff --git a/capabilities/MultiRoomMusic/acsdkMultiRoomMusic/include/acsdkMultiRoomMusic/MRMCapabilityAgent.h b/capabilities/MultiRoomMusic/acsdkMultiRoomMusic/include/acsdkMultiRoomMusic/MRMCapabilityAgent.h
index 8a89eb53..d9287182 100644
--- a/capabilities/MultiRoomMusic/acsdkMultiRoomMusic/include/acsdkMultiRoomMusic/MRMCapabilityAgent.h
+++ b/capabilities/MultiRoomMusic/acsdkMultiRoomMusic/include/acsdkMultiRoomMusic/MRMCapabilityAgent.h
@@ -116,6 +116,7 @@ public:
     /// @name Overridden @c DialogUXStateChanged methods.
     /// @{
     void onDialogUXStateChanged(
+        avsCommon::avs::AgentId::IdType agentId,
         avsCommon::sdkInterfaces::DialogUXStateObserverInterface::DialogUXState newState) override;
     /// @}
 
diff --git a/capabilities/MultiRoomMusic/acsdkMultiRoomMusic/src/MRMCapabilityAgent.cpp b/capabilities/MultiRoomMusic/acsdkMultiRoomMusic/src/MRMCapabilityAgent.cpp
index ee148b6c..bc5192f3 100644
--- a/capabilities/MultiRoomMusic/acsdkMultiRoomMusic/src/MRMCapabilityAgent.cpp
+++ b/capabilities/MultiRoomMusic/acsdkMultiRoomMusic/src/MRMCapabilityAgent.cpp
@@ -250,6 +250,7 @@ void MRMCapabilityAgent::onCallStateChange(avsCommon::sdkInterfaces::CallStateOb
 }
 
 void MRMCapabilityAgent::onDialogUXStateChanged(
+    avsCommon::avs::AgentId::IdType agentId,
     avsCommon::sdkInterfaces::DialogUXStateObserverInterface::DialogUXState state) {
     ACSDK_DEBUG5(LX(__func__).d("state", state));
     m_delayedTaskTimer.submitTask(DIALOG_STATE_UPDATE_DELAY, [this, state]() { executeOnDialogUXStateChanged(state); });
diff --git a/capabilities/Notifications/acsdkNotifications/include/acsdkNotifications/NotificationsCapabilityAgent.h b/capabilities/Notifications/acsdkNotifications/include/acsdkNotifications/NotificationsCapabilityAgent.h
index ed94f6d7..cb9a4101 100644
--- a/capabilities/Notifications/acsdkNotifications/include/acsdkNotifications/NotificationsCapabilityAgent.h
+++ b/capabilities/Notifications/acsdkNotifications/include/acsdkNotifications/NotificationsCapabilityAgent.h
@@ -93,6 +93,29 @@ public:
             avsCommon::sdkInterfaces::endpoints::EndpointCapabilitiesRegistrarInterface> endpointCapabilitiesRegistrar,
         const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder);
 
+    /**
+     * Creates a new @c NotificationsCapabilityAgent instance.
+     *
+     * @param notificationsStorage The storage interface to the NotificationIndicator database.
+     * @param renderer The instance of the @c NotificationRendererInterface used to play assets associated with
+     * notifications.
+     * @param contextManager The AVS Context manager used to generate system context for events.
+     * @param exceptionSender The object to use for sending AVS Exception messages.
+     * @param notificationsAudioFactory The audio factory object to produce the default notification sound.
+     * @param observers The set of observers that will be notified of IndicatorState changes.
+     * @param dataManager A dataManager object that will track the CustomerDataHandler.
+     * @param metricRecorder The metric recorder.
+     * @return A @c std::shared_ptr to the new @c NotificationsCapabilityAgent instance.
+     */
+    static std::shared_ptr<NotificationsCapabilityAgent> create(
+        std::shared_ptr<acsdkNotificationsInterfaces::NotificationsStorageInterface> notificationsStorage,
+        std::shared_ptr<acsdkNotificationsInterfaces::NotificationRendererInterface> renderer,
+        std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
+        std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
+        std::shared_ptr<avsCommon::sdkInterfaces::audio::NotificationsAudioFactoryInterface> notificationsAudioFactory,
+        std::shared_ptr<registrationManager::CustomerDataManagerInterface> dataManager,
+        std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder = nullptr);
+
     /**
      * Gets the @c NotificationsNotifierInterface that can relay notification changes to observers.
      *
diff --git a/capabilities/Notifications/acsdkNotifications/src/NotificationsCapabilityAgent.cpp b/capabilities/Notifications/acsdkNotifications/src/NotificationsCapabilityAgent.cpp
index dabde16f..651d0e41 100644
--- a/capabilities/Notifications/acsdkNotifications/src/NotificationsCapabilityAgent.cpp
+++ b/capabilities/Notifications/acsdkNotifications/src/NotificationsCapabilityAgent.cpp
@@ -163,6 +163,55 @@ std::shared_ptr<NotificationsCapabilityAgent> NotificationsCapabilityAgent::crea
     return notificationsCapabilityAgent;
 }
 
+std::shared_ptr<NotificationsCapabilityAgent> NotificationsCapabilityAgent::create(
+    std::shared_ptr<acsdkNotificationsInterfaces::NotificationsStorageInterface> notificationsStorage,
+    std::shared_ptr<acsdkNotificationsInterfaces::NotificationRendererInterface> renderer,
+    std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
+    std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
+    std::shared_ptr<avsCommon::sdkInterfaces::audio::NotificationsAudioFactoryInterface> notificationsAudioFactory,
+    std::shared_ptr<registrationManager::CustomerDataManagerInterface> dataManager,
+    std::shared_ptr<MetricRecorderInterface> metricRecorder) {
+    if (nullptr == notificationsStorage) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullNotificationsStorage"));
+        return nullptr;
+    }
+    if (nullptr == renderer) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullRenderer"));
+        return nullptr;
+    }
+    if (nullptr == contextManager) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullContextManager"));
+        return nullptr;
+    }
+    if (nullptr == exceptionSender) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullExceptionSender"));
+        return nullptr;
+    }
+    if (nullptr == notificationsAudioFactory) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullNotificationsAudioFactory"));
+        return nullptr;
+    }
+    if (nullptr == dataManager) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullDataManager"));
+        return nullptr;
+    }
+
+    auto notificationsCapabilityAgent = std::shared_ptr<NotificationsCapabilityAgent>(new NotificationsCapabilityAgent(
+        notificationsStorage,
+        renderer,
+        contextManager,
+        exceptionSender,
+        notificationsAudioFactory,
+        dataManager,
+        metricRecorder));
+
+    if (!notificationsCapabilityAgent->init()) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "initFailed"));
+        return nullptr;
+    }
+    return notificationsCapabilityAgent;
+}
+
 NotificationsCapabilityAgent::NotificationsCapabilityAgent(
     std::shared_ptr<acsdkNotificationsInterfaces::NotificationsStorageInterface> notificationsStorage,
     std::shared_ptr<acsdkNotificationsInterfaces::NotificationRendererInterface> renderer,
diff --git a/cmakeBuild/BuildDefaults.cmake b/cmakeBuild/BuildDefaults.cmake
index 742297e5..6f5c200b 100644
--- a/cmakeBuild/BuildDefaults.cmake
+++ b/cmakeBuild/BuildDefaults.cmake
@@ -22,6 +22,11 @@ macro(include_once module)
     endif()
 endmacro()
 
+if(ACSDK_ENABLE_CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE)
+    message(STATUS "Enabling curl http version 2 prior knowledge")
+    add_definitions(-DACSDK_ENABLE_CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE)
+endif()
+
 # Disallow out-of-source-builds.
 include_once(DisallowOutOfSourceBuilds)
 
diff --git a/cmakeBuild/cmake/BuildOptions.cmake b/cmakeBuild/cmake/BuildOptions.cmake
index 245ec1ac..aa6cb638 100644
--- a/cmakeBuild/cmake/BuildOptions.cmake
+++ b/cmakeBuild/cmake/BuildOptions.cmake
@@ -16,7 +16,7 @@ if(NOT CMAKE_BUILD_TYPE)
 endif()
 
 # Verify the build type is valid.
-set(buildTypes DEBUG RELEASE MINSIZEREL)
+set(buildTypes DEBUG RELEASE MINSIZEREL RELWITHDEBINFO)
 
 string(TOUPPER "${CMAKE_BUILD_TYPE}" buildType)
 
@@ -31,8 +31,8 @@ if (buildTypeFound EQUAL -1)
     message("###############################################################################")
     message("#                                                                             #")
     message("# ERROR:                                                                      #")
-    message("# Unknown build type selected. Please select from DEBUG, RELEASE, or          #")
-    message("# MINSIZEREL.                                                                 #")
+    message("# Unknown build type selected. Please select from DEBUG, RELEASE, MINSIZEREL, #")
+    message("# or RELWITHDEBINFO.                                                          #")
     message("#                                                                             #")
     message("# Build Type:                                                                 #")
     message("#     ${buildType}${buildTypePad}#")
@@ -63,26 +63,36 @@ if (NOT MSVC)
     set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG      "-DDEBUG -DACSDK_LOG_ENABLED -DACSDK_DEBUG_LOG_ENABLED -Wall -Werror -Wsign-compare -g")
     set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE    "-DNDEBUG -Wall -Werror -O2")
     set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "-DNDEBUG -Wall -Werror -Os")
+    set(CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO "-DNDEBUG -Wall -Werror -O2 -g")
     if (CMAKE_COMPILER_IS_GNUCXX AND (NOT (CMAKE_CXX_COMPILER_VERSION VERSION_LESS "8.0")))
         set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG "${CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG} -Wno-error=class-memaccess")
         set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE "${CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE} -Wno-error=class-memaccess")
         set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "${CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL} -Wno-error=class-memaccess")
+        set(CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO "${CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO} -Wno-error=class-memaccess")
     endif()
     if (CMAKE_COMPILER_IS_GNUCXX AND (NOT (CMAKE_CXX_COMPILER_VERSION VERSION_LESS "9.0")))
         set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG "${CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG} -Wno-error=deprecated-copy")
         set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE "${CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE} -Wno-error=deprecated-copy")
         set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "${CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL} -Wno-error=deprecated-copy")
+        set(CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO "${CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO} -Wno-error=deprecated-copy")
     endif()
     if (MINGW)
         # Debug build on MinGW needs O1 optimzation to reduce the code size. This is to get around GCC's string table overflow issue on MinGW.
         set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG "${CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG} -O1 -fuse-ld=lld")
         set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE "${CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE} -fuse-ld=lld")
         set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "${CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL} -fuse-ld=lld")
+        set(CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO "${CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO} -fuse-ld=lld")
     endif()
+    # Security flags
+    set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG "${CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG} -fstack-protector-strong -Wformat -Wformat-security -Werror=format-security")
+    set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE "${CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE} -fstack-protector-strong -Wformat -Wformat-security -Werror=format-security -D_FORTIFY_SOURCE=2")
+    set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "${CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL} -fstack-protector-strong -Wformat -Wformat-security -Werror=format-security -D_FORTIFY_SOURCE=2")
+    set(CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO "${CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO} -fstack-protector-strong -Wformat -Wformat-security -Werror=format-security -D_FORTIFY_SOURCE=2")
 else()
     set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG      "/DDEBUG /D_SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING -DACSDK_LOG_ENABLED -DACSDK_DEBUG_LOG_ENABLED /W4 /Zi /VZ /ZW /Od /MDd")
     set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE    "/DNDEBUG /D_SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING /W4 /O2 /VZ /ZW /MD")
     set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "/DNDEBUG /D_SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING /W4 /O1 /VZ /ZW /MD")
+    set(CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO    "/DNDEBUG /D_SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING /W4 /O2 /VZ /ZW /MD /Zi")
     add_definitions("-DNOMINMAX")
     add_definitions("-D_CRT_SECURE_NO_WARNINGS")
     set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)
@@ -92,10 +102,12 @@ if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
     set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG "${CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG} -Wconditional-uninitialized -Wsometimes-uninitialized -Wuninitialized")
     set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE "${CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE} -Wconditional-uninitialized -Wsometimes-uninitialized -Wuninitialized")
     set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "${CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL} -Wconditional-uninitialized -Wsometimes-uninitialized -Wuninitialized")
+    set(CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO "${CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO} -Wconditional-uninitialized -Wsometimes-uninitialized -Wuninitialized")
     if (MINGW)
         set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG "${CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG} -Wno-error=sentinel")
         set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE "${CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE} -Wno-error=sentinel")
         set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "${CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL} -Wno-error=sentinel")
+        set(CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO "${CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO} -Wno-error=sentinel")
     endif()
 endif()
 # Debug build, default.
@@ -117,3 +129,15 @@ else()
     set(ACSDK_CONFIG_STATIC_LIBS ON CACHE INTERNAL "Flag for SDKConfig.h.in" FORCE)
     set(ACSDK_CONFIG_SHARED_LIBS OFF CACHE INTERNAL "Flag for SDKConfig.h.in" FORCE)
 endif()
+
+# Release build with debug info.
+set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO} -DRAPIDJSON_HAS_STDSTRING" CACHE INTERNAL "Flags used for RELWITHDEBINFO builds" FORCE)
+set(CMAKE_C_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -g" CACHE INTERNAL "Flags used for RELWITHDEBINFO builds" FORCE)
+
+# Linker flags
+if(CMAKE_SYSTEM_NAME MATCHES "^(Linux|Android|QNX)$")
+    set(CMAKE_SHARED_LINKER_FLAGS_DEBUG "-Wl,-z,relro,-z,now -Wl,-z,noexecstack")
+    set(CMAKE_SHARED_LINKER_FLAGS_RELEASE "-Wl,-z,relro,-z,now -Wl,-z,noexecstack")
+    set(CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL "-Wl,-z,relro,-z,now -Wl,-z,noexecstack")
+    set(CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO "-Wl,-z,relro,-z,now -Wl,-z,noexecstack")
+endif()
diff --git a/cmakeBuild/cmake/Crypto.cmake b/cmakeBuild/cmake/Crypto.cmake
index 5f995d66..81e0c7a2 100644
--- a/cmakeBuild/cmake/Crypto.cmake
+++ b/cmakeBuild/cmake/Crypto.cmake
@@ -13,8 +13,11 @@ set(CRYPTO_INCLUDE_DIR "" CACHE PATH "Crypto include directory.")
 mark_as_advanced(CRYPTO_INCLUDE_DIR CRYPTO_LIBRARY)
 
 if (("${CRYPTO_LIBRARY}" STREQUAL "") OR ("${CRYPTO_INCLUDE_DIR}" STREQUAL ""))
-    find_package(PkgConfig)
-    pkg_check_modules(CRYPTO REQUIRED libcrypto)
+    find_package(OpenSSL ${OPENSSL_PACKAGE_CONFIG})
+    set(CRYPTO_LDFLAGS ${OpenSSL_LIBS})
+    set(CRYPTO_INCLUDE_DIRS ${OpenSSL_SSL_INCLUDE_DIR})
+    message("CRYPTO LIBRARY IS: ${CRYPTO_LDFLAGS}")
+    message("CRYPTO INCLUDE DIR IS: ${CRYPTO_INCLUDE_DIRS}")
 else()
     set(CRYPTO_LDFLAGS ${CRYPTO_LIBRARY})
     set(CRYPTO_INCLUDE_DIRS ${CRYPTO_INCLUDE_DIR})
diff --git a/cmakeBuild/cmake/Sqlite.cmake b/cmakeBuild/cmake/Sqlite.cmake
index 6c78dd29..a33df62c 100644
--- a/cmakeBuild/cmake/Sqlite.cmake
+++ b/cmakeBuild/cmake/Sqlite.cmake
@@ -13,8 +13,11 @@ set(SQLITE_INCLUDE_DIR "" CACHE PATH "SQLITE include directory.")
 mark_as_advanced(SQLITE_INCLUDE_DIR SQLITE_LIBRARY)
 
 if (("${SQLITE_LIBRARY}" STREQUAL "") OR ("${SQLITE_INCLUDE_DIR}" STREQUAL ""))
-    find_package(PkgConfig)
-    pkg_check_modules(SQLITE REQUIRED sqlite3)
+    find_package(SQLite3 ${SQLITE3_PACKAGE_CONFIG})
+    set(SQLITE_LDFLAGS ${SQLite_LIBRARIES})
+    set(SQLITE_INCLUDE_DIRS ${SQLite_INCLUDE_DIR})
+    message("SQLITE LIBRARY IS: ${SQLITE_LDFLAGS}")
+    message("SQLITE INCLUDE DIR IS: ${SQLITE_INCLUDE_DIRS}")
 else()
     set(SQLITE_LDFLAGS ${SQLITE_LIBRARY})
     set(SQLITE_INCLUDE_DIRS ${SQLITE_INCLUDE_DIR})
diff --git a/core/Authorization/acsdkAuthorization/include/acsdkAuthorization/LWA/LWAAuthorizationStorage.h b/core/Authorization/acsdkAuthorization/include/acsdkAuthorization/LWA/LWAAuthorizationStorage.h
index 4ae48fe5..ed5ee584 100644
--- a/core/Authorization/acsdkAuthorization/include/acsdkAuthorization/LWA/LWAAuthorizationStorage.h
+++ b/core/Authorization/acsdkAuthorization/include/acsdkAuthorization/LWA/LWAAuthorizationStorage.h
@@ -115,6 +115,7 @@ private:
         const std::shared_ptr<avsCommon::utils::configuration::ConfigurationNode>& configurationRoot,
         const std::string& storageRootKey);
 
+#if defined(FILE_SYSTEM_UTILS_ENABLED)
     /**
      * @brief Create database file.
      *
@@ -128,6 +129,7 @@ private:
      * @return True if file already exists, or a new empty file created and permissions were set.
      */
     static bool createStorageFileAndSetPermissions(const std::string& filepath) noexcept;
+#endif
 
     /**
      * Constructor.
diff --git a/core/Authorization/acsdkAuthorization/src/LWA/LWAAuthorizationStorage.cpp b/core/Authorization/acsdkAuthorization/src/LWA/LWAAuthorizationStorage.cpp
index 28b9648f..6fd43931 100644
--- a/core/Authorization/acsdkAuthorization/src/LWA/LWAAuthorizationStorage.cpp
+++ b/core/Authorization/acsdkAuthorization/src/LWA/LWAAuthorizationStorage.cpp
@@ -55,6 +55,7 @@ std::shared_ptr<LWAAuthorizationStorageInterface> LWAAuthorizationStorage::creat
     return std::shared_ptr<LWAAuthorizationStorageInterface>(new LWAAuthorizationStorage(propertiesFactory));
 }
 
+#if defined(FILE_SYSTEM_UTILS_ENABLED)
 bool LWAAuthorizationStorage::createStorageFileAndSetPermissions(const std::string& filepath) noexcept {
     using namespace avsCommon::utils::filesystem;
 
@@ -81,6 +82,7 @@ bool LWAAuthorizationStorage::createStorageFileAndSetPermissions(const std::stri
 
     return true;
 }
+#endif
 
 std::shared_ptr<storage::sqliteStorage::SQLiteMiscStorage> LWAAuthorizationStorage::createSQLiteStorage(
     const std::shared_ptr<avsCommon::utils::configuration::ConfigurationNode>& configurationRoot,
@@ -108,11 +110,13 @@ std::shared_ptr<storage::sqliteStorage::SQLiteMiscStorage> LWAAuthorizationStora
         return nullptr;
     }
 
+#if defined(FILE_SYSTEM_UTILS_ENABLED)
     if (!createStorageFileAndSetPermissions(databaseFilePath)) {
         ACSDK_ERROR(
             LX("createSQLiteStorageFailed").d("reason", "failedToCreateDBFile").sensitive("path", databaseFilePath));
         return nullptr;
     }
+#endif
 
     auto storage = storage::sqliteStorage::SQLiteMiscStorage::create(databaseFilePath);
     if (!storage || !storage->open()) {
diff --git a/core/Authorization/acsdkAuthorization/test/LWAAuthorizationAdapterTest.cpp b/core/Authorization/acsdkAuthorization/test/LWAAuthorizationAdapterTest.cpp
index 1ec62226..c859808f 100644
--- a/core/Authorization/acsdkAuthorization/test/LWAAuthorizationAdapterTest.cpp
+++ b/core/Authorization/acsdkAuthorization/test/LWAAuthorizationAdapterTest.cpp
@@ -293,7 +293,7 @@ void LWAAuthorizationAdapterTest::setCBLExpectations(
     }
 
     if (NULL_HTTP_RESPONSE.code != customerProfileResponse.code) {
-        EXPECT_CALL(*m_httpGet, doGet(HasSubstr("access_token=" + ACCESS_TOKEN), _))
+        EXPECT_CALL(*m_httpGet, doGet(HasSubstr("access_token=" + ACCESS_TOKEN), _, _))
             .Times(AnyNumber())
             .WillRepeatedly(InvokeWithoutArgs([customerProfileResponse] { return customerProfileResponse; }));
     }
diff --git a/core/CMakeLists.txt b/core/CMakeLists.txt
index 20fed9cf..6c54b6f5 100644
--- a/core/CMakeLists.txt
+++ b/core/CMakeLists.txt
@@ -1,14 +1,13 @@
 cmake_minimum_required(VERSION 3.1 FATAL_ERROR)
 
-add_subdirectory("acsdkAlexaEventProcessedNotifierInterfaces")
-add_subdirectory("acsdkCodecUtils")
-add_subdirectory("acsdkCore")
-add_subdirectory("acsdkPostConnectOperationProviderRegistrar")
-add_subdirectory("acsdkPostConnectOperationProviderRegistrarInterfaces")
-add_subdirectory("acsdkRegistrationManager")
-add_subdirectory("acsdkRegistrationManagerInterfaces")
-add_subdirectory("acsdkSystemClockMonitor")
-add_subdirectory("acsdkSystemClockMonitorInterfaces")
-add_subdirectory("Authorization")
-add_subdirectory("Crypto")
-add_subdirectory("Properties")
+# Add all subdirectories within the current path
+file(GLOB DIRECTORY_ENTRIES "${CMAKE_CURRENT_LIST_DIR}/*/")
+foreach(DIRECTORY IN LISTS DIRECTORY_ENTRIES)
+    if(IS_DIRECTORY "${DIRECTORY}")
+        if(EXISTS "${DIRECTORY}/CMakeLists.txt")
+            add_subdirectory("${DIRECTORY}")
+        else()
+            message(WARNING "Could not find CMakeLists.txt within ${DIRECTORY}")
+        endif()
+    endif()
+endforeach()
\ No newline at end of file
diff --git a/core/Crypto/acsdkPkcs11/src/CMakeLists.txt b/core/Crypto/acsdkPkcs11/src/CMakeLists.txt
index b38bfea4..210f85a1 100644
--- a/core/Crypto/acsdkPkcs11/src/CMakeLists.txt
+++ b/core/Crypto/acsdkPkcs11/src/CMakeLists.txt
@@ -23,8 +23,8 @@ target_include_directories(acsdkPkcs11 PUBLIC "${acsdkPkcs11_SOURCE_DIR}/include
 target_include_directories(acsdkPkcs11 PRIVATE "${acsdkPkcs11_SOURCE_DIR}/privateInclude")
 target_link_libraries(acsdkPkcs11 PUBLIC acsdkCryptoInterfaces AVSCommon)
 target_link_libraries(acsdkPkcs11 PRIVATE pkcs11-api-2.40)
-if(UNIX)
+if(UNIX AND NOT ${CMAKE_SYSTEM_NAME} MATCHES "QNX")
     target_link_libraries(acsdkPkcs11 PRIVATE dl)
-endif(UNIX)
+endif()
 # install target
 asdk_install()
diff --git a/core/MultiAgent/CMakeLists.txt b/core/MultiAgent/CMakeLists.txt
new file mode 100644
index 00000000..0372bee7
--- /dev/null
+++ b/core/MultiAgent/CMakeLists.txt
@@ -0,0 +1,5 @@
+cmake_minimum_required(VERSION 3.0 FATAL_ERROR)
+
+add_subdirectory("MultiAgent")
+add_subdirectory("MultiAgentInterface")
+
diff --git a/core/MultiAgent/MultiAgent/.clang-format b/core/MultiAgent/MultiAgent/.clang-format
new file mode 100644
index 00000000..5752e40b
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/.clang-format
@@ -0,0 +1,102 @@
+---
+Language:        Cpp
+BasedOnStyle:  Google
+AccessModifierOffset: -4
+AlignAfterOpenBracket: AlwaysBreak
+#AlignConsecutiveAssignments: false
+#AlignConsecutiveDeclarations: false
+#AlignEscapedNewlines: Left
+#AlignOperands:   true
+#AlignTrailingComments: true
+AllowAllParametersOfDeclarationOnNextLine: false
+#AllowShortBlocksOnASingleLine: false
+#AllowShortCaseLabelsOnASingleLine: false
+AllowShortFunctionsOnASingleLine: None
+#AllowShortIfStatementsOnASingleLine: true
+#AllowShortLoopsOnASingleLine: true
+#AlwaysBreakAfterDefinitionReturnType: None
+#AlwaysBreakAfterReturnType: None
+#AlwaysBreakBeforeMultilineStrings: true
+#AlwaysBreakTemplateDeclarations: true
+BinPackArguments: false
+BinPackParameters: false
+#BraceWrapping:   
+#  AfterClass:      false
+#  AfterControlStatement: false
+#  AfterEnum:       false
+#  AfterFunction:   false
+#  AfterNamespace:  false
+#  AfterObjCDeclaration: false
+#  AfterStruct:     false
+#  AfterUnion:      false
+#  BeforeCatch:     false
+#  BeforeElse:      false
+#  IndentBraces:    false
+#  SplitEmptyFunctionBody: true
+#BreakBeforeBinaryOperators: None
+#BreakBeforeBraces: Attach
+BreakBeforeInheritanceComma: true
+#BreakBeforeTernaryOperators: true
+#BreakConstructorInitializersBeforeComma: false
+BreakConstructorInitializers: AfterColon
+#BreakAfterJavaFieldAnnotations: false
+#BreakStringLiterals: true
+ColumnLimit:     120
+#CommentPragmas:  '^ IWYU pragma:'
+#CompactNamespaces: false
+#ConstructorInitializerAllOnOneLineOrOnePerLine: true
+ConstructorInitializerIndentWidth: 8
+#ContinuationIndentWidth: 4
+#Cpp11BracedListStyle: true
+DerivePointerAlignment: false
+#DisableFormat:   false
+#ExperimentalAutoDetectBinPacking: false
+#FixNamespaceComments: true
+#ForEachMacros:   [ foreach, Q_FOREACH, BOOST_FOREACH ]
+#IncludeCategories: 
+#  - Regex:           '^<.*\.h>'
+#    Priority:        1
+#  - Regex:           '^<.*'
+#    Priority:        2
+#  - Regex:           '.*'
+#    Priority:        3
+#IncludeIsMainRegex: '([-_](test|unittest))?$'
+#IndentCaseLabels: true
+IndentWidth:     4
+#IndentWrappedFunctionNames: false
+#JavaScriptQuotes: Leave
+#JavaScriptWrapImports: true
+#KeepEmptyLinesAtTheStartOfBlocks: false
+#MacroBlockBegin: ''
+#MacroBlockEnd:   ''
+#MaxEmptyLinesToKeep: 1
+#NamespaceIndentation: None
+#ObjCBlockIndentWidth: 2
+#ObjCSpaceAfterProperty: false
+#ObjCSpaceBeforeProtocolList: false
+#PenaltyBreakAssignment: 2
+#PenaltyBreakBeforeFirstCallParameter: 1
+#PenaltyBreakComment: 300
+#PenaltyBreakFirstLessLess: 120
+#PenaltyBreakString: 1000
+#PenaltyExcessCharacter: 1000000
+PenaltyReturnTypeOnItsOwnLine: 20000
+#PointerAlignment: Left
+#ReflowComments:  true
+SortIncludes:    false
+#SpaceAfterCStyleCast: false
+#SpaceAfterTemplateKeyword: true
+#SpaceBeforeAssignmentOperators: true
+#SpaceBeforeParens: ControlStatements
+#SpaceInEmptyParentheses: false
+#SpacesBeforeTrailingComments: 2
+#SpacesInAngles:  false
+#SpacesInContainerLiterals: true
+#SpacesInCStyleCastParentheses: false
+#SpacesInParentheses: false
+#SpacesInSquareBrackets: false
+#Standard:        Auto
+#TabWidth:        8
+#UseTab:          Never
+...
+
diff --git a/core/MultiAgent/MultiAgent/AgentConfigurations/AgentConfigurationsExample.json b/core/MultiAgent/MultiAgent/AgentConfigurations/AgentConfigurationsExample.json
new file mode 100644
index 00000000..d2755031
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/AgentConfigurations/AgentConfigurationsExample.json
@@ -0,0 +1,77 @@
+{
+  "agents": [
+    {
+      "id": 2,
+      "name": "Alexa",
+      "serviceConfiguration": {
+        "protocol": "AVS",
+        "baseURL": "https://alexa.na.gateway.devices.a2z.com"
+      },
+      "authorizationConfiguration": {
+        "protocol": "OAUTH2",
+        "baseURL": "https://api.amazon.com/auth/o2/"
+      },
+      "avsInterfaces": [
+        {
+          "interfaceName": "*"
+        }
+      ],
+      "locales": [
+        {
+          "locale": "en-US",
+          "wakeWords": [
+            "Alexa",
+            "Amazon",
+            "Computer",
+            "Ziggy"
+          ]
+        },
+        {
+          "locale": "de-DE",
+          "wakeWords": [
+            "Alexa"
+          ]
+        }
+      ]
+    },
+
+    {
+      "id": 42,
+      "name": "Deep Thought",
+      "serviceConfiguration": {
+        "protocol": "AVS",
+        "baseURL": "https://avs.magrathea.net"
+      },
+      "avsInterfaces": [
+        {
+          "interfaceName": "SpeechRecognizer",
+          "minimumInterfaceVersion": "2.3",
+          "events": [
+            "Recognize"
+          ],
+          "directives": [
+            "StopCapture",
+            "ExpectSpeech"
+          ]
+        },
+        {
+          "interfaceName": "SpeechSynthesizer",
+          "minimumInterfaceVersion": "1.3",
+          "events": [],
+          "directives": [
+            "Speak"
+          ]
+        }
+      ],
+      "locales": [
+        {
+          "locale": "mg-MG",
+          "wakeWords": [
+            "Deep Thought"
+          ]
+        }
+      ]
+    }
+
+  ]
+}
diff --git a/core/MultiAgent/MultiAgent/AgentConfigurations/AlexaAgentConfiguration.json b/core/MultiAgent/MultiAgent/AgentConfigurations/AlexaAgentConfiguration.json
new file mode 100644
index 00000000..0ae23c88
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/AgentConfigurations/AlexaAgentConfiguration.json
@@ -0,0 +1,98 @@
+{
+  "agents": [
+    {
+      "id": 2,
+      "name": "Alexa",
+      "serviceConfiguration": {
+        "protocol": "AVS",
+        "baseURL": "https://alexa.na.gateway.devices.a2z.com"
+      },
+      "authorizationConfiguration": {
+        "protocol": "OAUTH2",
+        "baseURL": "https://api.amazon.com/auth/o2/"
+      },
+      "avsInterfaces": [
+        {
+          "interfaceName": "*"
+        }
+      ],
+      "locales": [
+        {
+          "locale": "de-DE",
+          "wakeWords": [
+            "Alexa"
+          ]
+        },
+        {
+          "locale": "en-AU",
+          "wakeWords": [
+            "Alexa"
+          ]
+        },
+        {
+          "locale": "en-CA",
+          "wakeWords": [
+            "Alexa"
+          ]
+        },
+        {
+          "locale": "en-GB",
+          "wakeWords": [
+            "Alexa"
+          ]
+        },
+        {
+          "locale": "en-IN",
+          "wakeWords": [
+            "Alexa"
+          ]
+        },
+        {
+          "locale": "en-US",
+          "wakeWords": [
+            "Alexa",
+            "Amazon",
+            "Computer",
+            "Ziggy"
+          ]
+        },
+        {
+          "locale": "es-ES",
+          "wakeWords": [
+            "Alexa"
+          ]
+        },
+        {
+          "locale": "es-MX",
+          "wakeWords": [
+            "Alexa"
+          ]
+        },
+        {
+          "locale": "fr-CA",
+          "wakeWords": [
+            "Alexa"
+          ]
+        },
+        {
+          "locale": "fr-FR",
+          "wakeWords": [
+            "Alexa"
+          ]
+        },
+        {
+          "locale": "it-IT",
+          "wakeWords": [
+            "Alexa"
+          ]
+        },
+        {
+          "locale": "ja-JP",
+          "wakeWords": [
+            "Alexa"
+          ]
+        }
+      ]
+    }
+  ]
+}
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgent/AgentConfigurations/README.md b/core/MultiAgent/MultiAgent/AgentConfigurations/README.md
new file mode 100644
index 00000000..9ec72761
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/AgentConfigurations/README.md
@@ -0,0 +1,119 @@
+# Introduction
+
+This README describes how the json of an Agent Configuration should be structured 
+and the meanings of its fields.
+
+This README assumes this json is expressed in a file named 'AgentConfigurations.json' for
+ease of explanation, although the file may be named differently in practice, or may even
+be provided as a data stream from an external source.
+
+An AgentConfigurations.json file describes the characteristics of agents a customer may interact 
+with in a device-independent and customer-independent manner. In this spirit, this file does not 
+express 'default' values or settings, since these may vary across devices and customers. Instead, 
+it is expected that this json file shall be read to instantiate agents on a given device, and then 
+device software shall update those runtime agents dynamically, for example to enable or disable them, 
+or set currently active locales.
+
+An Agent Configuration defines how a device may make an agent available to a customer, similar to
+how knowing a phone number allows the call to be made from any telephone. We therefore decouple any
+device-side, or customer-specific, data from an Agent Configuration to maximize its usage.
+
+We now outline each field within this file:
+
+
+## agents
+
+This is an array of device-independent expressions of agents which a customer may
+interact with. Each agent object may contain the following elements.
+
+### id
+
+**Required.**
+
+The id of an agent. This id must align with traffic metadata and any other agent configurations known
+to the same device. Within the AgentConfigurations.json file every agent id must be unique. Agent id
+must also not conflict with the reserved values 0 or 1, which are interpreted to mean 'no agent' and
+'all agents' respectively by device software.
+
+The agent id is the only element which is required to be unique across all agents in any 
+AgentConfigurations.json file.
+
+### name
+
+**Required.**
+
+A string identifier for an agent, intended primarily for development and debugging purposes. This name 
+may differ from the possible wake words for the agent. This name may never be shown directly to the 
+customer, since such display may also require localization (for example, different character sets are 
+required to display an agent's name in English versus Japanese). Such concerns are beyond the scope of 
+an AgentConfigurations.json file, since any displayable aspect of an agent shares the same concerns 
+(for example, supported locales, wake words within those locales, and any custom agent settings which 
+the customer might have reason to view). It is expected that some other solution will solve for such 
+rendering for customers when provided an agent's id.
+
+The name of an agent **need not** be unique with respect to the names of other agents in an 
+AgentConfigurations.json file, although this is preferable.
+
+### serviceConfiguration
+
+**Required.**
+
+Expresses where the agent service is located, and its protocol. Protocol definition is **required**.
+baseURL is **optional**, and if not provided, it is assumed the agent service is locally 
+known to the device which has read the given AgentConfigurations.json.
+
+### authorizationConfiguration
+
+**Optional**
+
+Expresses where the agent's identity service is located, and its protocol. This is an optional field, and
+if not provided it is assumed the agent service does not require authorization for connection and usage.
+
+### avsInterfaces
+
+**Required.**
+
+Expresses the AVS Interfaces with which the agent service may interact with a given device. This object 
+has a mix of required and optional fields to allow ease of expression of the wide range of possible 
+AVS Interfaces an agent might support, which could include all of them.
+
+To express support for all AVS Interfaces, then a single element should be listed with the interfaceName '\*', 
+without any other fields in the object. This will mean that the agent service supports all AVS Interfaces
+with backwards compatibility support for all versions. If other fields in this single object are presented,
+they will be ignored, as will any additional elements in this list.
+
+Otherwise, the minimumInterfaceVersion field is **required**, whereas the supported Events and Directives
+are **optional**. If Events and Directives are not provided, then it will be assumed the agent can support
+all such messages within the given version of the Interface. This object may also list only Events or
+Directives for the Interface, for example if an agent only supports the SoftwareInfo Event within the
+System Interface, but no Directives.
+
+The minimumInterfaceVersion field ensures that a device's implementation of a given AVS Interface 
+meets the minimum version that the agent's cloud service can support. If the minimumInterfaceVersion for a 
+given Interface within this configuration is higher than the version of the Interface as implemented by 
+the device, then the device must not connect to the agent service, since in this case the agent service and
+the device will not fully understand each other's messages. Otherwise, it is assumed that agent service is 
+fully backwards compatible on their cloud service to the minimumInterfaceVersion as stated in each Interface
+within the avsInterfaces list.
+
+Presentation of '\*' as interfaceName will be an error if it occurs after the first element, and the
+device should fail to parse the Agent Configuration.
+
+### locales
+
+**Required**
+
+Expresses the locales an agent understands, which includes possible wake words which may be used to invoke 
+that agent by voice in that locale. Each locale name must be unique in the list of locales.
+
+The inclusion of wakeWords in a locale is **optional**, since an agent service might not support or require
+named invocation on a device, for example work via tap-to-talk gesture only. This agent service however 
+might still understand many languages, hence the requirement for locale definition. It is required that every
+agent supports at least one locale, since otherwise it is not meaningful as a voice agent.
+
+If provided, wakeWords within a locale must be unique within that list, however need not be unique 
+across multiple locales for the same agent. For example, "Alexa" may be a wakeWord in the locales 
+"en-US" and "en-CA" for the same agent.
+
+Wake words must not collide between agents, so if two Agent Configurations define the same wake word
+in any of their locales, then the device should fail to parse the colliding Agent Configuration.
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgent/CMakeLists.txt b/core/MultiAgent/MultiAgent/CMakeLists.txt
new file mode 100644
index 00000000..71c3c53d
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/CMakeLists.txt
@@ -0,0 +1,7 @@
+cmake_minimum_required(VERSION 3.1 FATAL_ERROR)
+project(MultiAgent LANGUAGES CXX)
+
+include(${AVS_CMAKE_BUILD}/BuildDefaults.cmake)
+
+add_subdirectory("src")
+add_subdirectory("test")
diff --git a/core/MultiAgent/MultiAgent/README.md b/core/MultiAgent/MultiAgent/README.md
new file mode 100644
index 00000000..269b0a6f
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/README.md
@@ -0,0 +1,2 @@
+This is the beginning of the Mini-MAX Repository
+
diff --git a/core/MultiAgent/MultiAgent/include/acsdk/MultiAgent/AgentManagerFactory.h b/core/MultiAgent/MultiAgent/include/acsdk/MultiAgent/AgentManagerFactory.h
new file mode 100644
index 00000000..89cc651e
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/include/acsdk/MultiAgent/AgentManagerFactory.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENT_AGENTMANAGERFACTORY_H_
+#define ACSDK_MULTIAGENT_AGENTMANAGERFACTORY_H_
+
+#include <acsdk/MultiAgentInterface/AgentManagerInterface.h>
+
+#include <istream>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+
+/**
+ * A class for instantiating an @c AgentManager. This allows decoupling of a specific implementation from this Interface
+ * package.
+ */
+class AgentManagerFactory {
+public:
+    /**
+     * Creates a new @c AgentManager.
+     *
+     * @param agentConfigurationsStream The JSON input stream which should contain the descriptions of agents to be
+     * managed.
+     * @return A new @c AgentManager if the JSON stream is valid, else nullptr.
+     */
+    static std::shared_ptr<multiAgentInterface::AgentManagerInterface> create(std::istream& agentConfigurationsStream);
+};
+
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENT_AGENTMANAGERFACTORY_H_
diff --git a/core/MultiAgent/MultiAgent/include/acsdk/MultiAgent/Connection/AlexaAgentConnectionManagerFactory.h b/core/MultiAgent/MultiAgent/include/acsdk/MultiAgent/Connection/AlexaAgentConnectionManagerFactory.h
new file mode 100644
index 00000000..cd11b7e7
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/include/acsdk/MultiAgent/Connection/AlexaAgentConnectionManagerFactory.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENT_CONNECTION_ALEXAAGENTCONNECTIONMANAGERFACTORY_H_
+#define ACSDK_MULTIAGENT_CONNECTION_ALEXAAGENTCONNECTIONMANAGERFACTORY_H_
+
+#include <AVSCommon/SDKInterfaces/AVSConnectionManagerInterface.h>
+#include <acsdk/MultiAgentInterface/Connection/AgentConnectionManagerInterface.h>
+
+#include <memory>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace connection {
+
+/**
+ * This class allows creation of a AlexaAgentConnectionManager, which serves the purpose of managing a single agent
+ * connection to Alexa via the Alexa Voice Service.
+ */
+class AlexaAgentConnectionManagerFactory {
+public:
+    /**
+     * Creates an @c AlexaAgentConnectionManager.
+     *
+     * @param connectionManager The underlying AVS SDK Connection Manager, typically a wrapper for libCurl.
+     * @return A new @c AlexaAgentConnectionManager if successful, else nullptr.
+     */
+    static std::shared_ptr<multiAgentInterface::connection::AgentConnectionManagerInterface> create(
+        const std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface>& connectionManager);
+};
+
+}  // namespace connection
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENT_CONNECTION_ALEXAAGENTCONNECTIONMANAGERFACTORY_H_
diff --git a/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Agent/AVSInterface.h b/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Agent/AVSInterface.h
new file mode 100644
index 00000000..ae0db313
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Agent/AVSInterface.h
@@ -0,0 +1,130 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENT_AGENT_AVSINTERFACE_H_
+#define ACSDK_MULTIAGENT_AGENT_AVSINTERFACE_H_
+
+#include <set>
+#include <string>
+#include <utility>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace agent {
+
+/**
+ * A class which represents an AVS Interface which an agent service may support. For example, SpeechRecognizer (as
+ * documented here - https://developer.amazon.com/en-US/docs/alexa/alexa-voice-service/speechrecognizer.html) is an AVS
+ * Interface which allows an agent to listen to a customer utterance.
+ *
+ * This class allows expression of such an AVS Interface in terms of its name, its minimum semantic version number which
+ * a given agent service understands, and the supported Events and Directives within the AVS Interface.
+ */
+class AVSInterface {
+public:
+    /**
+     * Constructor. If neither Events or Directives are provided then it is assumed this Interface supports all such
+     * messages. Otherwise, only the provided Events and Directives will be expected to be supported by a given agent
+     * service.
+     *
+     * @param interfaceName The name of the AVS Interface being supported.
+     * @param minimumSemanticVersion The minimum version of the AVS Interface which may be supported.
+     * @param events The Events within the AVS Interface which the agent supports.
+     * @param directives The Directives within the AVS Interface which the agent may send to a device.
+     */
+    AVSInterface(
+        const std::string& interfaceName,
+        const std::pair<int, int>& minimumSemanticVersion,
+        const std::set<std::string>& events = std::set<std::string>(),
+        const std::set<std::string>& directives = std::set<std::string>());
+
+    /**
+     * Returns the name of this AVSInterface.
+     *
+     * @return The name of this AVSInterface.
+     */
+    std::string getName() const;
+
+    /**
+     * Returns the minimum semantic version of this AVSInterface which the agent service understands.
+     *
+     * @return The minimum semantic version of this AVSInterface which the agent service understands.
+     */
+    std::pair<int, int> getMinimumSemanticVersion() const;
+
+    /**
+     * Returns whether the given message is supported by this AVSInterface.
+     *
+     * @param version The Interface version of the message being queried.
+     * @param messageName The name of the Event or Directive being queried.
+     * @return Whether the message type within this AVSInterface is supported.
+     */
+    bool isMessageSupported(
+        const std::pair<int, int>& version = std::pair<int, int>{0, 0},
+        const std::string& messageName = "") const;
+
+    /**
+     * Returns whether all messages are supported within this AVSInterface.
+     *
+     * @return Whether all messages are supported within this AVSInterface.
+     */
+    bool supportsAllMessages() const;
+
+    /**
+     * Returns the Events which the agent service understands within this AVSInterface.
+     *
+     * @return The Events which the agent service understands within this AVSInterface. If this AVSInterface supports
+     * all messages, then an empty set will be returned.
+     */
+    std::set<std::string> getEvents() const;
+
+    /**
+     * Returns the Directives which the agent service may send within this AVSInterface.
+     *
+     * @return The Directives which the agent service may send within this AVSInterface. If this AVSInterface supports
+     * all messages, then an empty set will be returned.
+     */
+    std::set<std::string> getDirectives() const;
+
+    /**
+     * The less-than operator.
+     *
+     * @param rhs The @c AVSInterface to be compared.
+     * @return Whether the current object is semantically less than the object being compared with.
+     */
+    bool operator<(const AVSInterface& rhs) const;
+
+private:
+    /// The name associated with this AVSInterface.
+    const std::string m_name;
+
+    /// The minimum semantic version of this AVS Interface which the agent service supports.
+    const std::pair<int, int> m_minimumSemanticVersion;
+
+    /// Expresses whether all Events and Directives within this AVSInterface is supported by the agent service.
+    bool m_supportsAllMessages;
+
+    /// The Events which the agent service understands within this AVSInterface.
+    const std::set<std::string> m_events;
+
+    /// The Directives which the agent service may send within this AVSInterface.
+    const std::set<std::string> m_directives;
+};
+
+}  // namespace agent
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENT_AGENT_AVSINTERFACE_H_
diff --git a/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Agent/Agent.h b/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Agent/Agent.h
new file mode 100644
index 00000000..91dffaa8
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Agent/Agent.h
@@ -0,0 +1,361 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENT_AGENT_AGENT_H_
+#define ACSDK_MULTIAGENT_AGENT_AGENT_H_
+
+#include <acsdk/MultiAgent/Agent/AVSInterface.h>
+#include <acsdk/MultiAgentInterface/Agent/LocaleInterface.h>
+
+#include <acsdk/MultiAgentInterface/Connection/AgentConnectionManagerInterface.h>
+#include <acsdk/MultiAgentInterface/Connection/AgentConnectionObserverInterface.h>
+
+#include <memory>
+#include <set>
+#include <string>
+#include <utility>
+#include <vector>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace agent {
+
+/**
+ * This class encapsulates an AVS-conformant agent in a device-independent manner. For more details on the semantics of
+ * this class, refer to the AgentConfigurations/REAMDE.md file in this package.
+ */
+class Agent
+        : public multiAgentInterface::connection::AgentConnectionObserverInterface
+        , public std::enable_shared_from_this<Agent> {
+public:
+    /**
+     * A utility structure representing how an agent service may be connected to.
+     */
+    struct ServiceConfiguration {
+        /// Enum representing possible agent service protocols.
+        enum class Protocol {
+            /// The Alexa Voice Service protocol.
+            AVS
+        };
+
+        /**
+         * Constructor.
+         */
+        ServiceConfiguration() : protocol{ServiceConfiguration::Protocol::AVS} {
+        }
+
+        /**
+         * Constructor.
+         */
+        ServiceConfiguration(const std::string& baseURL, ServiceConfiguration::Protocol protocol) :
+                baseURL{baseURL},
+                protocol{protocol} {
+        }
+
+        /// The base URL for the agent service. If this is empty, it is assumed the agent service is locally known.
+        std::string baseURL;
+        /// The protocol of the agent service.
+        Protocol protocol;
+
+        /**
+         * This function converts the provided @c Protocol to a string.
+         *
+         * @param state The @c Protocol to convert to a string.
+         * @return The string conversion of @c protocol.
+         */
+        static std::string protocolToString(Protocol protocol) {
+            switch (protocol) {
+                case Protocol::AVS:
+                    return "AVS";
+            }
+            return "Unknown Protocol";
+        }
+    };
+
+    /**
+     * A utility structure representing how an agent's identity service may be connected to.
+     */
+    struct AuthConfiguration {
+        /// Enum representing possible authorization protocols.
+        enum class Protocol {
+            /// The OAuth2 protocol, as described here - https://datatracker.ietf.org/doc/html/rfc6749.
+            OAUTH2
+        };
+
+        /**
+         * Constructor.
+         */
+        AuthConfiguration() : protocol{AuthConfiguration::Protocol::OAUTH2} {
+        }
+
+        /**
+         * Constructor.
+         */
+        AuthConfiguration(const std::string& baseURL, AuthConfiguration::Protocol protocol) :
+                baseURL{baseURL},
+                protocol{protocol} {
+        }
+
+        /// The base URL for the identity service.
+        std::string baseURL;
+        /// The protocol of the identity service.
+        Protocol protocol;
+
+        /**
+         * This function converts the provided @c Protocol to a string.
+         *
+         * @param state The @c Protocol to convert to a string.
+         * @return The string conversion of @c protocol.
+         */
+        static std::string protocolToString(Protocol protocol) {
+            switch (protocol) {
+                case Protocol::OAUTH2:
+                    return "OAUTH2";
+            }
+            return "Unknown Protocol";
+        }
+    };
+
+    /**
+     * Creates an agent object.
+     *
+     * @param id The id of the agent.
+     * @param name The name of the agent.
+     * @param serviceConfiguration The serviceConfiguration which should be used.
+     * @param authConfiguration The authConfiguration which should be used.
+     * @param avsInterfaces The AVS Interfaces this agent supports.
+     * @param locales The locales which the agent supports.
+     * @return An agent object if the parameters were valid, else nullptr.
+     */
+    static std::shared_ptr<Agent> create(
+        avsCommon::avs::AgentId::IdType id,
+        const std::string& name,
+        const ServiceConfiguration& serviceConfiguration,
+        const AuthConfiguration& authConfiguration,
+        const std::vector<AVSInterface>& avsInterfaces,
+        const std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>>& locales);
+
+    /// @name AgentConnectionObserverInterface method overrides.
+    /// @{
+    void onAgentAvailabilityStateChanged(
+        avsCommon::avs::AgentId::IdType id,
+        multiAgentInterface::connection::AgentConnectionObserverInterface::AvailabilityState status,
+        const std::string& reason) override;
+    /// @}
+
+    /**
+     * Returns the Agent ID for this agent.
+     *
+     * @return The Agent ID for this agent.
+     */
+    avsCommon::avs::AgentId::IdType getId();
+
+    /**
+     * Returns the name of this agent.
+     *
+     * @return The name of this agent.
+     */
+    std::string getName();
+
+    /**
+     * Returns whether this agent is enabled.
+     *
+     * @return Whether this agent is enabled.
+     */
+    bool isEnabled();
+
+    /**
+     * Enables this agent.
+     */
+    void enable();
+
+    /**
+     * Disables this agent.
+     */
+    void disable();
+
+    /**
+     *
+     * @param connectionManager
+     */
+    void setAgentConnectionManager(
+        const std::shared_ptr<multiAgentInterface::connection::AgentConnectionManagerInterface>& connectionManager);
+
+    /**
+     * Returns this agent's current availability state.
+     *
+     * @return This agent's current availability state.
+     */
+    multiAgentInterface::connection::AgentConnectionObserverInterface::AvailabilityState getAvailability();
+
+    /**
+     * Evaluates whether a particular AVS message is supported by this agent.
+     *
+     * @param avsNamespace The AVS Interface name of the message.
+     * @param version The version of the message being evaluated.
+     * @param avsMessageName The Event or Directive name of the message being evaluated.
+     * @return Whether the particular AVS message is supported by this agent.
+     */
+    bool isAVSMessageSupported(
+        const std::string& avsNamespace,
+        std::pair<int, int> version = std::pair<int, int>{0, 0},
+        const std::string& avsMessageName = "");
+
+    /**
+     * Returns all locales which this agent may support.
+     *
+     * @return All locales which this agent may support.
+     */
+    std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>> getLocales();
+
+    /**
+     * Returns the locales which are currently active for this agent.
+     *
+     * @return The locales which are currently active for this agent.
+     */
+    std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>> getActiveLocales();
+
+    /**
+     * Sets the base URL for the agent's service. Expects a non-empty string.
+     *
+     * @param baseURL The URL for the agent's service.
+     */
+    void setServiceBaseURL(const std::string& baseURL);
+
+    /**
+     * Sets the locales which should be made active for this agent.
+     *
+     * @param localeNames The names of the locales to be made active.
+     * @return Whether the requested locales were successfully activated.
+     */
+    bool setActiveLocales(const std::set<std::string>& localeNames);
+
+    /**
+     * Sets the currently active wake words within a locale. The locale must be active before this API may be called.
+     *
+     * @param localeName The locale within which the wake words should be enabled.
+     * @param wakeWords The wake words within the locale to enable.
+     * @return Whether the wake words were successfully enabled within the locale.
+     */
+    bool setActiveWakeWords(const std::string& localeName, const std::set<std::string>& wakeWords);
+
+    /**
+     * Adds a @c AgentConnectionObserverInterface observer.
+     *
+     * @param observer The observer to add.
+     */
+    void addAgentConnectionObserverInterface(
+        const std::shared_ptr<multiAgentInterface::connection::AgentConnectionObserverInterface>& observer);
+
+    /**
+     * Removes a @c AgentConnectionObserverInterface observer.
+     *
+     * @param observer The observer to remove.
+     */
+    void removeAgentConnectionObserverInterface(
+        const std::shared_ptr<multiAgentInterface::connection::AgentConnectionObserverInterface>& observer);
+
+    /**
+     * A utility ostream operator to facilitate debugging.
+     *
+     * @param os The ostream to send output to.
+     * @param agent The agent which should be streamed.
+     * @return The ostream per standard practice.
+     */
+    friend std::ostream& operator<<(std::ostream& os, const Agent& agent);
+
+private:
+    /**
+     * Constructor.
+     *
+     * @param id The id of the agent.
+     * @param name The name of the agent.
+     * @param serviceConfiguration The serviceConfiguration which should be used.
+     * @param authConfiguration The authConfiguration which should be used.
+     * @param avsInterfaces The AVS Interfaces this agent supports.
+     * @param locales The locales which the agent supports.
+     */
+    Agent(
+        avsCommon::avs::AgentId::IdType id,
+        const std::string& name,
+        const ServiceConfiguration& serviceConfiguration,
+        const AuthConfiguration& authConfiguration,
+        const std::vector<AVSInterface>& avsInterfaces,
+        const std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>>& locales);
+
+    /// The id of this agent.
+    const avsCommon::avs::AgentId::IdType m_id;
+
+    /// The name of this agent.
+    const std::string m_name;
+
+    /// Whether this agent is enabled.
+    bool m_isEnabled;
+
+    /// This agent's current availability state.
+    AgentConnectionObserverInterface::AvailabilityState m_availability;
+
+    /// The serviceConfiguration for this agent.
+    ServiceConfiguration m_serviceConfiguration;
+
+    /// The authConfiguration for this agent.
+    AuthConfiguration m_authConfiguration;
+
+    /// Whether this agent supports all AVS Interfaces in all versions.
+    bool m_supportsAllAVSInterfaces;
+
+    /// The AVS Interfaces which this agent supports, should m_supportsAllAVSInterfaces be false.
+    std::set<AVSInterface> m_avsInterfaces;
+
+    /// The locales which may be enabled for this agent.
+    std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>> m_locales;
+
+    /// The currently active locales for this agent.
+    std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>> m_activeLocales;
+
+    /// Our connection observers.
+    std::set<std::shared_ptr<multiAgentInterface::connection::AgentConnectionObserverInterface>> m_connectionObservers;
+
+    /// The connection manager this agent should use.
+    std::shared_ptr<multiAgentInterface::connection::AgentConnectionManagerInterface> m_connectionManager;
+};
+
+/**
+ * Utility stream function to print a particular @c ServiceConfiguration::Protocol value.
+ *
+ * @param stream The stream to send output to.
+ * @param protocol The protocol to print.
+ * @return The ostream per standard practice.
+ */
+inline std::ostream& operator<<(std::ostream& stream, const Agent::ServiceConfiguration::Protocol& protocol) {
+    return stream << Agent::ServiceConfiguration::protocolToString(protocol);
+}
+
+/**
+ * Utility stream function to print a particular @c AuthConfiguration::Protocol value.
+ *
+ * @param stream The stream to send output to.
+ * @param protocol The protocol to print.
+ * @return The ostream per standard practice.
+ */
+inline std::ostream& operator<<(std::ostream& stream, const Agent::AuthConfiguration::Protocol& protocol) {
+    return stream << Agent::AuthConfiguration::protocolToString(protocol);
+}
+
+}  // namespace agent
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENT_AGENT_AGENT_H_
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Agent/ConfigParser.h b/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Agent/ConfigParser.h
new file mode 100644
index 00000000..0928b8c9
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Agent/ConfigParser.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENT_AGENT_CONFIGPARSER_H_
+#define ACSDK_MULTIAGENT_AGENT_CONFIGPARSER_H_
+
+#include "acsdk/MultiAgentInterface/Connection/AgentConnectionManagerInterface.h"
+#include <acsdk/MultiAgent/Agent/Agent.h>
+
+#include <rapidjson/document.h>
+
+#include <memory>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace agent {
+
+/**
+ * A utility class which parses a single Agent element within a larger JSON structure, and ensures that the agent is
+ * correctly expressed. This class does not therefore preform aggregate logic, for example ensuring that multiple agents
+ * read have relatively unique agent ids; this must be handled at a higher level.
+ */
+class ConfigParser {
+public:
+    /**
+     * Parses a single Agent element within a larger JSON structure, and ensures that the agent is correctly expressed.
+     * If so, an instantiation of the agent is returned, otherwise nullptr.
+     *
+     * @param The rapidjson node containing the constructed DOM of the agent object.
+     * @return An instantiation of the agent as described by the JSON. If the agent JSON is invalid, then nullptr.
+     */
+    static std::shared_ptr<Agent> parseJSON(rapidjson::Value::ConstValueIterator& agentNode);
+};
+
+}  // namespace agent
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENT_AGENT_CONFIGPARSER_H_
diff --git a/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Agent/Locale.h b/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Agent/Locale.h
new file mode 100644
index 00000000..51417bba
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Agent/Locale.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENT_AGENT_LOCALE_H_
+#define ACSDK_MULTIAGENT_AGENT_LOCALE_H_
+
+#include <acsdk/MultiAgentInterface/Agent/LocaleInterface.h>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace agent {
+
+/**
+ * An implementation of the LocaleInterface.
+ */
+class Locale : public multiAgentInterface::agent::LocaleInterface {
+public:
+    /**
+     * Utility function to confirm that a given set of wake words is within a given superset.
+     *
+     * @param subset The subset of wake words.
+     * @param superset The superset of wake words.
+     * @return Whether the subset is a true subset of the superset.
+     */
+    static bool verifyWakeWordSubset(const std::set<std::string>& subset, const std::set<std::string>& superset);
+
+    /**
+     * Constructor.
+     *
+     * @param name The name of the locale.
+     * @param wakeWords The wake words within the locale which an agent may be associated with.
+     */
+    Locale(const std::string& name, const std::set<std::string>& wakeWords);
+
+    /// @name LocaleInterface method overrides.
+    /// @{
+    bool setActiveWakeWords(const std::set<std::string>& wakeWords) override;
+    std::string getName() const override;
+    std::set<std::string> getAllWakeWords() const override;
+    std::set<std::string> getActiveWakeWords() const override;
+    bool operator<(const multiAgentInterface::agent::LocaleInterface& rhs) const override;
+    /// @}
+
+private:
+    /// The name of the locale.
+    std::string m_name;
+
+    /// The set of wake words within this locale which may be activated.
+    std::set<std::string> m_wakeWords;
+
+    /// The currently active wake words within this locale.
+    std::set<std::string> m_activeWakeWords;
+};
+
+}  // namespace agent
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENT_AGENT_LOCALE_H_
diff --git a/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/AgentManager.h b/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/AgentManager.h
new file mode 100644
index 00000000..79383202
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/AgentManager.h
@@ -0,0 +1,184 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENT_AGENTMANAGER_H_
+#define ACSDK_MULTIAGENT_AGENTMANAGER_H_
+
+#include "acsdk/MultiAgentInterface/Connection/AgentConnectionObserverInterface.h"
+#include "acsdk/MultiAgentInterface/Observer/AgentEnablementObserverInterface.h"
+#include "acsdk/MultiAgentInterface/Observer/AgentGestureObserverInterface.h"
+#include "acsdk/MultiAgentInterface/Observer/AgentLocaleObserverInterface.h"
+#include <acsdk/MultiAgent/Agent/Agent.h>
+#include <acsdk/MultiAgentInterface/Agent/LocaleInterface.h>
+#include <acsdk/MultiAgentInterface/AgentManagerInterface.h>
+
+#include <istream>
+#include <map>
+#include <memory>
+#include <set>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+
+/**
+ * An implementation of the AgentManagerInterface.
+ */
+class AgentManager
+        : public multiAgentInterface::AgentManagerInterface
+        , public multiAgentInterface::connection::AgentConnectionObserverInterface
+        , public std::enable_shared_from_this<AgentManager> {
+public:
+    /**
+     * Creates an AgentManager, whose purpose is to instantiate agents as expressed in the provided JSON stream, and
+     * which interact with their respective agent services.
+     *
+     * @param agentConfigurationsStream A stream of JSON data which must conform to the specification of the AVS SDK
+     * AgentConfigurations.json template.
+     * @return An AgentManager. If any aspect of parsing or construction fails, then nullptr is returned.
+     */
+    static std::shared_ptr<AgentManager> create(std::istream& agentConfigurationsStream);
+
+    /// @name AgentConnectionObserverInterface method overrides.
+    /// @{
+    void onAgentAvailabilityStateChanged(
+        avsCommon::avs::AgentId::IdType id,
+        multiAgentInterface::connection::AgentConnectionObserverInterface::AvailabilityState status,
+        const std::string& reason) override;
+    /// @}
+
+    /// @name AgentManagerInterface method overrides.
+    /// @{
+    std::set<avsCommon::avs::AgentId::IdType> getAllAgentIds() override;
+    std::string getAgentName(avsCommon::avs::AgentId::IdType id) override;
+    std::set<avsCommon::avs::AgentId::IdType> getAVSInterfaceEnabledAgentIds(
+        const std::string& avsNamespace,
+        const std::string& avsName = "",
+        const std::pair<int, int>& version = std::pair<int, int>{0, 0}) override;
+    std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>> getAgentLocales(
+        avsCommon::avs::AgentId::IdType id) override;
+    std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>> getAgentActiveLocales(
+        avsCommon::avs::AgentId::IdType id) override;
+    std::set<avsCommon::avs::AgentInitiator> getAgentGestures(avsCommon::avs::AgentId::IdType id) override;
+    bool isAgentEnabled(avsCommon::avs::AgentId::IdType id) override;
+    bool enableAgent(avsCommon::avs::AgentId::IdType id) override;
+    bool disableAgent(avsCommon::avs::AgentId::IdType id) override;
+    void setAgentConnectionManager(
+        const std::shared_ptr<multiAgentInterface::connection::AgentConnectionManagerInterface>& connectionManager)
+        override;
+    bool setBaseURL(avsCommon::avs::AgentId::IdType id, const std::string& baseURL) override;
+    bool setActiveLocales(avsCommon::avs::AgentId::IdType id, const std::set<std::string>& localeNames) override;
+    bool setActiveWakeWords(
+        avsCommon::avs::AgentId::IdType id,
+        const std::string& localeName,
+        const std::set<std::string>& wakeWords) override;
+    bool setAgentGesture(avsCommon::avs::AgentId::IdType id, avsCommon::avs::AgentInitiator gesture) override;
+    avsCommon::avs::AgentId::IdType resolveGesture(avsCommon::avs::AgentInitiator gesture) override;
+    avsCommon::avs::AgentId::IdType resolveWakeWord(const std::string& wakeWord) override;
+    void addAgentConnectionObserverInterface(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<multiAgentInterface::connection::AgentConnectionObserverInterface>& observer) override;
+    void removeAgentConnectionObserverInterface(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<multiAgentInterface::connection::AgentConnectionObserverInterface>& observer) override;
+    void addAgentEnablementObserverInterface(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<multiAgentInterface::observer::AgentEnablementObserverInterface>& observer) override;
+    void removeAgentEnablementObserverInterface(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<multiAgentInterface::observer::AgentEnablementObserverInterface>& observer) override;
+    void addAgentGestureObserverInterface(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<multiAgentInterface::observer::AgentGestureObserverInterface>& observer) override;
+    void removeAgentGestureObserverInterface(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<multiAgentInterface::observer::AgentGestureObserverInterface>& observer) override;
+    void addAgentLocaleObserverInterface(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<multiAgentInterface::observer::AgentLocaleObserverInterface>& observer) override;
+    void removeAgentLocaleObserverInterface(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<multiAgentInterface::observer::AgentLocaleObserverInterface>& observer) override;
+    void clearAgents() override;
+    /// @}
+
+    /**
+     * Utility function to print the details of an agent to std::cout.
+     *
+     * @param id The id of the agent to print.
+     */
+    void printAgentDetails(avsCommon::avs::AgentId::IdType id) override;
+
+private:
+    /**
+     * Constructor.
+     */
+    AgentManager();
+
+    /**
+     * Performs initialization given the provided inputs.
+     *
+     * @param agentConfigurationsStream A stream of JSON data which must conform to the specification of the AVS SDK
+     * AgentConfigurations.json template.
+     * @return Whether initialization was successful.
+     */
+    bool initialize(std::istream& agentConfigurationsStream);
+
+    /**
+     * Utility function to assign a gesture to a given agent.
+     *
+     * @param id The id of the agent to which the gesture should be assigned.
+     * @param gesture The gesture to assign.
+     * @return Whether the gesture was successfully assigned.
+     */
+    bool assignGesture(avsCommon::avs::AgentId::IdType id, avsCommon::avs::AgentInitiator gesture);
+
+    /**
+     * Utility function which acquires an agent from our collection.
+     *
+     * @param id The @c agent::Id to be queried.
+     * @return The agent if found, otherwise nullptr.
+     */
+    std::shared_ptr<agent::Agent> getAgent(avsCommon::avs::AgentId::IdType id);
+
+    /// Our collection of agents.
+    std::map<avsCommon::avs::AgentId::IdType, std::shared_ptr<agent::Agent>> m_agentMap;
+
+    /// Our map of gestures to currently assigned agent id, which may also be avsCommon::avs::AgentId::AGENT_ID_NONE.
+    std::map<avsCommon::avs::AgentInitiator, avsCommon::avs::AgentId::IdType> m_assignedGestures;
+
+    /// Utility struct so we may simplify mapping of observers to agents.
+    struct Observers {
+        /// A collection of connection observers.
+        std::set<std::shared_ptr<multiAgentInterface::connection::AgentConnectionObserverInterface>>
+            connectionObservers;
+
+        /// A collection of enablement observers.
+        std::set<std::shared_ptr<multiAgentInterface::observer::AgentEnablementObserverInterface>> enablementObservers;
+
+        /// A collection of gesture observers.
+        std::set<std::shared_ptr<multiAgentInterface::observer::AgentGestureObserverInterface>> gestureObservers;
+
+        /// A collection of wake word configuration observers.
+        std::set<std::shared_ptr<multiAgentInterface::observer::AgentLocaleObserverInterface>> localeObservers;
+    };
+
+    /// Mapping of agent ids to potential observers.
+    std::map<avsCommon::avs::AgentId::IdType, Observers> m_agentObservers;
+};
+
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENT_AGENTMANAGER_H_
diff --git a/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Connection/AlexaAgentConnectionManager.h b/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Connection/AlexaAgentConnectionManager.h
new file mode 100644
index 00000000..b198262d
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Connection/AlexaAgentConnectionManager.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENT_CONNECTION_ALEXAAGENTCONNECTIONMANAGER_H_
+#define ACSDK_MULTIAGENT_CONNECTION_ALEXAAGENTCONNECTIONMANAGER_H_
+
+#include <AVSCommon/SDKInterfaces/AVSConnectionManagerInterface.h>
+#include <acsdk/MultiAgentInterface/Connection/AgentConnectionManagerInterface.h>
+#include <acsdkNotifier/internal/Notifier.h>
+
+#include <memory>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace connection {
+
+/**
+ * An single-agent implementation of the AgentConnectionManagerInterface.
+ *
+ * It manages a handle to an AVS connection, and provides agent availability notifications accordingly.
+ */
+class AlexaAgentConnectionManager
+        : public multiAgentInterface::connection::AgentConnectionManagerInterface
+        , public avsCommon::sdkInterfaces::ConnectionStatusObserverInterface {
+public:
+    /**
+     * Creates a new SingleAgentConnectionManager.
+     *
+     * @param connectionManager The underlying AVS SDK Connection Manager, typically a wrapper for libCurl.
+     * @return A new @c AlexaAgentConnectionManager if successful, else nullptr.
+     */
+    static std::shared_ptr<AlexaAgentConnectionManager> create(
+        const std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface>& connectionManager);
+
+    /// @name AgentConnectionManagerInterface method overrides.
+    /// @{
+    bool configureAgent(avsCommon::avs::AgentId::IdType id, const std::string& avsGateway, const std::string& agentName)
+        override;
+    void removeAgent(avsCommon::avs::AgentId::IdType id) override;
+    void addObserver(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<multiAgentInterface::connection::AgentConnectionObserverInterface>& observer) override;
+    void removeObserver(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<multiAgentInterface::connection::AgentConnectionObserverInterface>& observer) override;
+    /// @}
+
+    /// @name ConnectionStatusObserverInterface method overrides.
+    /// @{
+    void onConnectionStatusChanged(const Status status, const ChangedReason reason) override;
+    void onConnectionStatusChanged(const Status status, const std::vector<EngineConnectionStatus>& engineStatuses)
+        override;
+    /// @}
+
+private:
+    /**
+     * Constructor.
+     *
+     * @param connectionManager The underlying AVS SDK connection manager that should be used.
+     */
+    AlexaAgentConnectionManager(
+        const std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface>& connectionManager);
+
+    /// Our notifier object to simplify the observer pattern.
+    acsdkNotifier::Notifier<multiAgentInterface::connection::AgentConnectionObserverInterface> m_notifier;
+};
+
+}  // namespace connection
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENT_CONNECTION_ALEXAAGENTCONNECTIONMANAGER_H_
diff --git a/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Utils/JSONUtils.h b/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Utils/JSONUtils.h
new file mode 100644
index 00000000..1455c0eb
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/privateInclude/acsdk/MultiAgent/Utils/JSONUtils.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENT_UTILS_JSONUTILS_H_
+#define ACSDK_MULTIAGENT_UTILS_JSONUTILS_H_
+
+#include <AVSCommon/Utils/Optional.h>
+
+#include <set>
+#include <string>
+
+#include <rapidjson/document.h>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace utils {
+namespace json {
+
+/**
+ * Verifies if the given rapidjson node represents an array of objects.
+ *
+ * // TODO : migrate this code to AVSCommon/Utils/JSON.
+ *
+ * @param node The node to test which should contain the array element.
+ * @param arrayKey The name of the array.
+ * @return Whether an array exists within the node.
+ */
+bool validateObjectArray(rapidjson::Value::ConstValueIterator& node, const std::string& arrayKey);
+
+/**
+ * Reads an array of strings within the rapidjson node.
+ *
+ * // TODO : migrate this code to AVSCommon/Utils/JSON.
+ *
+ * @param nodeIter The node which contains the array element.
+ * @param arrayKey The name of the array element.
+ * @return The set of strings within the given array, or an empty optional if the element could not be parsed.
+ */
+avsCommon::utils::Optional<std::set<std::string>> readStringArray(
+    rapidjson::Value::ConstValueIterator& nodeIter,
+    const std::string& arrayKey);
+
+}  // namespace json
+}  // namespace utils
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENT_UTILS_JSONUTILS_H_
diff --git a/core/MultiAgent/MultiAgent/src/Agent/AVSInterface.cpp b/core/MultiAgent/MultiAgent/src/Agent/AVSInterface.cpp
new file mode 100644
index 00000000..e1aa7cf4
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/src/Agent/AVSInterface.cpp
@@ -0,0 +1,99 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <acsdk/MultiAgent/Agent/AVSInterface.h>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace agent {
+
+/// String to identify log entries originating from this file.
+#define TAG "AVSInterface"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+AVSInterface::AVSInterface(
+    const std::string& name,
+    const std::pair<int, int>& minimumSemanticVersion,
+    const std::set<std::string>& events,
+    const std::set<std::string>& directives) :
+        m_name{name},
+        m_minimumSemanticVersion{minimumSemanticVersion},
+        m_supportsAllMessages{false},
+        m_events{events},
+        m_directives{directives} {
+    if (m_events.empty() && m_directives.empty()) {
+        m_supportsAllMessages = true;
+    }
+}
+
+std::string AVSInterface::getName() const {
+    return m_name;
+}
+
+std::pair<int, int> AVSInterface::getMinimumSemanticVersion() const {
+    return m_minimumSemanticVersion;
+}
+
+bool AVSInterface::supportsAllMessages() const {
+    return m_supportsAllMessages;
+}
+
+bool AVSInterface::isMessageSupported(const std::pair<int, int>& version, const std::string& messageName) const {
+    // Check if the default parameter was provided.
+    bool skipVersionTest = (version == std::pair<int, int>(0, 0));
+
+    // the agent service minimum version must be lower than, or equal to, the version of our query
+    if (!skipVersionTest &&
+        ((version.first < m_minimumSemanticVersion.first) ||
+         (version.first == m_minimumSemanticVersion.first && version.second < m_minimumSemanticVersion.second))) {
+        return false;
+    }
+
+    if (supportsAllMessages()) {
+        return true;
+    }
+
+    if (m_events.find(messageName) != m_events.end()) {
+        return true;
+    }
+
+    if (m_directives.find(messageName) != m_directives.end()) {
+        return true;
+    }
+
+    return false;
+}
+
+std::set<std::string> AVSInterface::getEvents() const {
+    return m_events;
+}
+
+std::set<std::string> AVSInterface::getDirectives() const {
+    return m_directives;
+}
+
+bool AVSInterface::operator<(const AVSInterface& rhs) const {
+    return m_name < rhs.m_name;
+}
+
+}  // namespace agent
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgent/src/Agent/Agent.cpp b/core/MultiAgent/MultiAgent/src/Agent/Agent.cpp
new file mode 100644
index 00000000..29329faa
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/src/Agent/Agent.cpp
@@ -0,0 +1,340 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <acsdk/MultiAgent/Agent/Agent.h>
+#include <acsdk/MultiAgent/Agent/Locale.h>
+
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+#include <iostream>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace agent {
+
+/// Static definition of wildcard symbol string.
+static const char AVS_INTERFACE_WILDCARD[] = "*";
+
+using namespace avsCommon::avs;
+using namespace multiAgentInterface;
+
+/// String to identify log entries originating from this file.
+#define TAG "Agent"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/**
+ * Utility function to acquire a locale from a particular set, if it is present.
+ *
+ * @param locales The set of locales to query.
+ * @param localeName The name of the locale we are looking for.
+ * @return The locale if found, otherwise nullptr.
+ */
+static std::shared_ptr<multiAgentInterface::agent::LocaleInterface> getLocale(
+    std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>> locales,
+    const std::string& localeName) {
+    for (const auto& locale : locales) {
+        if (locale->getName() == localeName) {
+            return locale;
+        }
+    }
+
+    return nullptr;
+}
+
+std::shared_ptr<Agent> Agent::create(
+    AgentId::IdType id,
+    const std::string& name,
+    const ServiceConfiguration& serviceConfiguration,
+    const AuthConfiguration& authConfiguration,
+    const std::vector<AVSInterface>& avsInterfaces,
+    const std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>>& locales) {
+    if (AgentId::AGENT_ID_NONE == id) {
+        ACSDK_ERROR(LX("createFailed").m("invalid Agent id (AGENT_ID_NONE) used."));
+        return nullptr;
+    }
+    if (AgentId::AGENT_ID_ALL == id) {
+        ACSDK_ERROR(LX("createFailed").m("invalid Agent id (AGENT_ID_ALL) used."));
+        return nullptr;
+    }
+    if (name.empty()) {
+        ACSDK_ERROR(LX("createFailed").m("empty agent name used."));
+        return nullptr;
+    }
+    if (avsInterfaces.empty()) {
+        ACSDK_ERROR(LX("createFailed").m("no AVS interfaces provided."));
+        return nullptr;
+    }
+    if (locales.empty()) {
+        ACSDK_ERROR(LX("createFailed").m("no locales provided."));
+        return nullptr;
+    }
+
+    // validate usage of AVS Interface wildcard.
+    if (avsInterfaces.size() > 1 && avsInterfaces[0].getName() != AVS_INTERFACE_WILDCARD) {
+        for (auto iter = avsInterfaces.begin() + 1; iter != avsInterfaces.end(); iter++) {
+            if (iter->getName() == AVS_INTERFACE_WILDCARD) {
+                ACSDK_ERROR(LX("createFailed").m("wildcard AVS Interface is only valid as the first AVS Interface."));
+                return nullptr;
+            }
+        }
+    }
+
+    return std::shared_ptr<Agent>(new Agent(id, name, serviceConfiguration, authConfiguration, avsInterfaces, locales));
+}
+
+Agent::Agent(
+    AgentId::IdType id,
+    const std::string& name,
+    const ServiceConfiguration& serviceConfiguration,
+    const AuthConfiguration& authConfiguration,
+    const std::vector<AVSInterface>& avsInterfaces,
+    const std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>>& locales) :
+        m_id{id},
+        m_name{name},
+        m_isEnabled{false},
+        m_availability{AgentConnectionObserverInterface::AvailabilityState::UNAVAILABLE},
+        m_serviceConfiguration{serviceConfiguration},
+        m_authConfiguration{authConfiguration},
+        m_supportsAllAVSInterfaces{false},
+        m_avsInterfaces{avsInterfaces.begin(), avsInterfaces.end()},
+        m_locales{locales} {
+    // our wildcard support for all AVS Interfaces.
+    if ((m_avsInterfaces.size() == 1) && (AVS_INTERFACE_WILDCARD == m_avsInterfaces.begin()->getName())) {
+        m_avsInterfaces.clear();
+        m_supportsAllAVSInterfaces = true;
+    }
+}
+
+void Agent::onAgentAvailabilityStateChanged(
+    AgentId::IdType id,
+    connection::AgentConnectionObserverInterface::AvailabilityState status,
+    const std::string& reason) {
+    m_availability = status;
+    for (const auto& observer : m_connectionObservers) {
+        observer->onAgentAvailabilityStateChanged(id, m_availability, reason);
+    }
+}
+
+AgentId::IdType Agent::getId() {
+    return m_id;
+}
+
+std::string Agent::getName() {
+    return m_name;
+}
+
+bool Agent::isEnabled() {
+    return m_isEnabled;
+}
+
+std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>> Agent::getLocales() {
+    return m_locales;
+}
+
+std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>> Agent::getActiveLocales() {
+    return m_activeLocales;
+}
+
+bool Agent::isAVSMessageSupported(
+    const std::string& avsNamespace,
+    std::pair<int, int> version,
+    const std::string& avsMessageName) {
+    if (avsNamespace.empty()) {
+        ACSDK_ERROR(LX("isAVSMessageSupportedFailed").m("empty avsNamespace string provided."));
+        return false;
+    }
+
+    if (m_supportsAllAVSInterfaces) {
+        return true;
+    }
+
+    for (const auto& interface : m_avsInterfaces) {
+        if (interface.getName() == avsNamespace) {
+            if (interface.supportsAllMessages()) {
+                return true;
+            }
+
+            return (interface.isMessageSupported(version, avsMessageName));
+        }
+    }
+
+    return false;
+}
+
+void Agent::enable() {
+    m_isEnabled = true;
+}
+
+void Agent::disable() {
+    m_isEnabled = false;
+}
+
+void Agent::setAgentConnectionManager(
+    const std::shared_ptr<multiAgentInterface::connection::AgentConnectionManagerInterface>& connectionManager) {
+    m_connectionManager = connectionManager;
+    if (m_connectionManager) {
+        m_connectionManager->addObserver(m_id, shared_from_this());
+    }
+}
+
+multiAgentInterface::connection::AgentConnectionObserverInterface::AvailabilityState Agent::getAvailability() {
+    return m_availability;
+}
+
+void Agent::setServiceBaseURL(const std::string& baseURL) {
+    if (!m_connectionManager) {
+        ACSDK_ERROR(LX("setServiceBaseURLFailed").m("ConnectionManager is nullptr."));
+        return;
+    }
+
+    m_serviceConfiguration.baseURL = baseURL;
+    m_connectionManager->configureAgent(m_id, m_serviceConfiguration.baseURL, m_name);
+}
+
+bool Agent::setActiveLocales(const std::set<std::string>& localeNames) {
+    // verify localeNames are valid
+    for (const auto& localeName : localeNames) {
+        if (!getLocale(m_locales, localeName)) {
+            ACSDK_ERROR(LX("setActiveLocalesFailed").m("locales are not a valid subset."));
+            return false;
+        }
+    }
+
+    // determine locales which will no longer be active
+    auto localesToDeactivate = m_activeLocales;
+    for (const auto& localeName : localeNames) {
+        auto locale = getLocale(m_activeLocales, localeName);
+        if (locale) {
+            localesToDeactivate.erase(locale);
+        }
+    }
+
+    // disable wake words for removed locales, and remove those locales from the active set
+    for (const auto& locale : localesToDeactivate) {
+        locale->setActiveWakeWords(std::set<std::string>());
+        m_activeLocales.erase(locale);
+    }
+
+    // trivially ensure the new locale set is included in the active working set
+    for (const auto& localeName : localeNames) {
+        m_activeLocales.insert(getLocale(m_locales, localeName));
+    }
+
+    return true;
+}
+
+bool Agent::setActiveWakeWords(const std::string& localeName, const std::set<std::string>& wakeWords) {
+    auto locale = getLocale(m_activeLocales, localeName);
+    if (!locale) {
+        ACSDK_ERROR(LX("setActiveWakeWordsFailed").m("Unable to find active locale:" + localeName));
+        return false;
+    }
+
+    return locale->setActiveWakeWords(wakeWords);
+}
+
+void Agent::addAgentConnectionObserverInterface(
+    const std::shared_ptr<connection::AgentConnectionObserverInterface>& observer) {
+    m_connectionObservers.insert(observer);
+    observer->onAgentAvailabilityStateChanged(m_id, m_availability, "observer registration with Agent.");
+}
+
+void Agent::removeAgentConnectionObserverInterface(
+    const std::shared_ptr<connection::AgentConnectionObserverInterface>& observer) {
+    m_connectionObservers.erase(observer);
+}
+
+std::ostream& operator<<(std::ostream& os, const Agent& a) {
+    os << "+-----------------------------------------------------+" << std::endl
+       << "|                    Agent Details                    |" << std::endl
+       << "+-----------------------------------------------------+" << std::endl
+       << "| name:    " << a.m_name << std::endl
+       << "| id:      " << a.m_id << std::endl
+       << "| enabled: " << (a.m_isEnabled ? "true" : "false") << std::endl
+       << "| service configuration" << std::endl
+       << "|    protocol: " << a.m_serviceConfiguration.protocol << std::endl
+       << "|    baseURL:  " << a.m_serviceConfiguration.baseURL << std::endl
+       << "| auth configuration" << std::endl
+       << "|    protocol: " << a.m_authConfiguration.protocol << std::endl
+       << "|    baseURL:  " << a.m_authConfiguration.baseURL << std::endl
+       << "| AVS Interfaces (" << a.m_avsInterfaces.size() << ")" << std::endl
+       << "|    supports all:" << (a.m_supportsAllAVSInterfaces ? "true" : "false") << std::endl;
+
+    for (const auto& interface : a.m_avsInterfaces) {
+        auto version = interface.getMinimumSemanticVersion();
+        os << "| AVS Interface" << std::endl
+           << "|    interface: " << interface.getName() << std::endl
+           << "|    minimum version: " << version.first << "." << version.second << std::endl;
+
+        if (interface.supportsAllMessages()) {
+            os << "|    supports all messages" << std::endl;
+        } else {
+            if (!interface.getEvents().empty()) {
+                os << "|    events: " << std::endl;
+                for (const auto& event : interface.getEvents()) {
+                    os << "|       " << event << std::endl;
+                }
+            }
+
+            if (!interface.getDirectives().empty()) {
+                os << "|    directives: " << std::endl;
+                for (const auto& directive : interface.getDirectives()) {
+                    os << "|       " << directive << std::endl;
+                }
+            }
+        }
+    }
+
+    os << "| locales (" << a.m_locales.size() << ")" << std::endl;
+
+    if (!a.m_locales.empty()) {
+        for (const auto& locale : a.m_locales) {
+            os << "| locale " << std::endl
+               << "|    name: " << locale->getName() << std::endl
+               << "|    wake words (" << locale->getAllWakeWords().size() << ")" << std::endl;
+
+            for (const auto& ww : locale->getAllWakeWords()) {
+                os << "|        " << ww << std::endl;
+            }
+        }
+    }
+
+    os << "| enabled locales (" << a.m_activeLocales.size() << ")" << std::endl;
+    if (!a.m_activeLocales.empty()) {
+        for (const auto& locale : a.m_activeLocales) {
+            os << "| locale " << std::endl
+               << "|    name: " << locale->getName() << std::endl
+               << "|    active wake words (" << locale->getActiveWakeWords().size() << ")" << std::endl;
+
+            for (const auto& ww : locale->getActiveWakeWords()) {
+                os << "|        " << ww << std::endl;
+            }
+        }
+    }
+
+    os << "+-----------------------------------------------------+" << std::endl;
+
+    return os;
+}
+
+}  // namespace agent
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgent/src/Agent/ConfigParser.cpp b/core/MultiAgent/MultiAgent/src/Agent/ConfigParser.cpp
new file mode 100644
index 00000000..5ca5add8
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/src/Agent/ConfigParser.cpp
@@ -0,0 +1,416 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <acsdk/MultiAgent/Agent/ConfigParser.h>
+#include <acsdk/MultiAgent/Agent/Locale.h>
+#include <acsdk/MultiAgent/Utils/JSONUtils.h>
+
+#include <AVSCommon/Utils/JSON/JSONUtils.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+#include <AVSCommon/Utils/Optional.h>
+
+#include <vector>
+
+/// The key used to identify an agent id within a parsed JSON DOM
+static const char AGENT_CONFIGURATION_JSON_AGENT_ID_KEY[] = "id";
+
+/// The key used to identify an agent name within a parsed JSON DOM
+static const char AGENT_CONFIGURATION_JSON_AGENT_NAME_KEY[] = "name";
+
+/// The key used to identify agent locales within a parsed JSON DOM
+static const char AGENT_CONFIGURATION_JSON_AGENT_LOCALES_KEY[] = "locales";
+
+/// The key used to identify an agent locale within a parsed JSON DOM
+static const char AGENT_CONFIGURATION_JSON_AGENT_LOCALE_KEY[] = "locale";
+
+/// The key used to identify a locale's wake words within a parsed JSON DOM
+static const char AGENT_CONFIGURATION_JSON_AGENT_WAKEWORDS_KEY[] = "wakeWords";
+
+/// The key used to identify an agent service configuration within a parsed JSON DOM
+static const char AGENT_CONFIGURATION_JSON_SERVICE_CONFIGURATION_KEY[] = "serviceConfiguration";
+
+/// The key used to identify a service configuration protocol within a parsed JSON DOM
+static const char AGENT_CONFIGURATION_JSON_SERVICE_CONFIGURATION_PROTOCOL_KEY[] = "protocol";
+
+/// The key used to identify a service configuration base URL within a parsed JSON DOM
+static const char AGENT_CONFIGURATION_JSON_SERVICE_CONFIGURATION_BASE_URL_KEY[] = "baseURL";
+
+/// The key used to identify an agent authorization configuration within a parsed JSON DOM
+static const char AGENT_CONFIGURATION_JSON_AUTHORIZATION_CONFIGURATION_KEY[] = "authorizationConfiguration";
+
+/// The key used to identify an authorization configuration protocol within a parsed JSON DOM
+static const char AGENT_CONFIGURATION_JSON_AUTHORIZATION_CONFIGURATION_PROTOCOL_KEY[] = "protocol";
+
+/// The key used to identify an agent authorization configuration base URL within a parsed JSON DOM
+static const char AGENT_CONFIGURATION_JSON_AUTHORIZATION_CONFIGURATION_BASE_URL_KEY[] = "baseURL";
+
+/// The key used to identify an agent's AVS Interfaces within a parsed JSON DOM
+static const char AGENT_CONFIGURATION_JSON_AVS_INTERFACES_KEY[] = "avsInterfaces";
+
+/// The key used to identify an AVS Interface name within a parsed JSON DOM
+static const char AGENT_CONFIGURATION_JSON_AVS_INTERFACES_INTERFACE_NAME_KEY[] = "interfaceName";
+
+/// Definition of the asterisk value used to express all interfaces.
+static const char AGENT_CONFIGURATION_JSON_AVS_INTERFACES_INTERFACE_ASTERISK[] = "*";
+
+/// The key used to identify an AVS Interface minimum supported version within a parsed JSON DOM
+static const char AGENT_CONFIGURATION_JSON_AVS_INTERFACES_MINIMUM_INTERFACE_VERSION_KEY[] = "minimumInterfaceVersion";
+
+/// The key used to identify an AVS Interface events within a parsed JSON DOM
+static const char AGENT_CONFIGURATION_JSON_AVS_INTERFACES_EVENTS_KEY[] = "events";
+
+/// The key used to identify an AVS Interface directives within a parsed JSON DOM
+static const char AGENT_CONFIGURATION_JSON_AVS_INTERFACES_DIRECTIVES_KEY[] = "directives";
+
+/// Definition of the AVS protocol string
+static const char AGENT_SERVICE_PROTOCOL_AVS[] = "AVS";
+
+/// Definition of the OAUTH2 protocol string
+static const char AGENT_AUTHORIZATION_PROTOCOL_OAUTH2[] = "OAUTH2";
+
+/// String to identify log entries originating from this file.
+#define TAG "ConfigParser"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace agent {
+
+using namespace rapidjson;
+using namespace alexaClientSDK::avsCommon::utils;
+using namespace alexaClientSDK::avsCommon::utils::json;
+
+/**
+ * Utility function which parses the Agent serviceConfiguration object from the JSON DOM.
+ *
+ * @param serviceConfigNode The rapidjson node of the object containing the serviceConfiguration.
+ * @return An optional ServiceConfiguration object, if the JSON is successfully parsed.
+ */
+static Optional<Agent::ServiceConfiguration> parseJSONServiceConfiguration(const Value& serviceConfigNode) {
+    Optional<Agent::ServiceConfiguration> emptyOptional;
+    std::string protocolString;
+    std::string baseURLString;
+
+    if (!jsonUtils::retrieveValue(
+            serviceConfigNode, AGENT_CONFIGURATION_JSON_SERVICE_CONFIGURATION_PROTOCOL_KEY, &(protocolString))) {
+        ACSDK_ERROR(LX("parseJSONServiceConfigurationFailed")
+                        .m("serviceConfiguration missing a required element:" +
+                           std::string(AGENT_CONFIGURATION_JSON_SERVICE_CONFIGURATION_PROTOCOL_KEY)));
+        return emptyOptional;
+    }
+
+    if (!jsonUtils::retrieveValue(
+            serviceConfigNode, AGENT_CONFIGURATION_JSON_SERVICE_CONFIGURATION_BASE_URL_KEY, &(baseURLString))) {
+        ACSDK_DEBUG9(
+            LX("serviceConfiguration missing an optional element:" +
+               std::string(AGENT_CONFIGURATION_JSON_SERVICE_CONFIGURATION_BASE_URL_KEY)));
+        // ensure rapidjson didn't modify the empty string.
+        baseURLString = "";
+    }
+
+    Agent::ServiceConfiguration::Protocol protocol;
+    if (AGENT_SERVICE_PROTOCOL_AVS == protocolString) {
+        protocol = Agent::ServiceConfiguration::Protocol::AVS;
+    } else {
+        ACSDK_ERROR(
+            LX("parseJSONServiceConfigurationFailed").m("Invalid serviceConfiguration protocol:" + protocolString));
+        return emptyOptional;
+    }
+
+    return Optional<Agent::ServiceConfiguration>(Agent::ServiceConfiguration(baseURLString, protocol));
+}
+
+/**
+ * Utility function which parses the Agent authorizationConfiguration object from the JSON DOM.
+ *
+ * @param authConfigNode The rapidjson node of the object containing the authorizationConfiguration.
+ * @return An optional AuthConfiguration object, if the JSON is successfully parsed.
+ */
+static Optional<Agent::AuthConfiguration> parseJSONAuthConfiguration(const Value& authConfigNode) {
+    Optional<Agent::AuthConfiguration> emptyOptional;
+    std::string protocolString;
+    std::string baseURLString;
+
+    if (!jsonUtils::retrieveValue(
+            authConfigNode, AGENT_CONFIGURATION_JSON_AUTHORIZATION_CONFIGURATION_PROTOCOL_KEY, &(protocolString))) {
+        ACSDK_ERROR(LX("parseJSONAuthConfigurationFailed")
+                        .m("authConfiguration missing a required element:" +
+                           std::string(AGENT_CONFIGURATION_JSON_AUTHORIZATION_CONFIGURATION_PROTOCOL_KEY)));
+        return emptyOptional;
+    }
+
+    if (!jsonUtils::retrieveValue(
+            authConfigNode, AGENT_CONFIGURATION_JSON_AUTHORIZATION_CONFIGURATION_BASE_URL_KEY, &(baseURLString))) {
+        ACSDK_ERROR(LX("parseJSONAuthConfigurationFailed")
+                        .m("authConfiguration missing a required element:" +
+                           std::string(AGENT_CONFIGURATION_JSON_AUTHORIZATION_CONFIGURATION_BASE_URL_KEY)));
+        return emptyOptional;
+    }
+
+    Agent::AuthConfiguration::Protocol protocol;
+    if (AGENT_AUTHORIZATION_PROTOCOL_OAUTH2 == protocolString) {
+        protocol = Agent::AuthConfiguration::Protocol::OAUTH2;
+    } else {
+        ACSDK_ERROR(LX("parseJSONAuthConfigurationFailed").m("Invalid AuthConfiguration protocol:" + protocolString));
+        return emptyOptional;
+    }
+
+    return Optional<Agent::AuthConfiguration>(Agent::AuthConfiguration(baseURLString, protocol));
+}
+
+/**
+ * Parses a semantic version, expressed as two integers in the form MAJOR.minor, for example "2.10".
+ *
+ * @param semanticVersionString The string to be parsed.
+ * @return An optional pair of integers reflecting the parsed semantic version.
+ */
+static Optional<std::pair<int, int>> parseSemanticVersion(const std::string& semanticVersionString) {
+    Optional<std::pair<int, int>> emptyOptional;
+
+    auto periodLocation = semanticVersionString.find('.');
+    if (std::string::npos == periodLocation) {
+        ACSDK_ERROR(LX("parseSemanticVersionFailed").m("Could not parse valid interface version - missing period."));
+        return emptyOptional;
+    }
+
+    if (0 == periodLocation) {
+        ACSDK_ERROR(
+            LX("parseSemanticVersionFailed").m("Could not parse valid interface version - missing first token."));
+        return emptyOptional;
+    }
+
+    if (periodLocation >= semanticVersionString.size()) {
+        ACSDK_ERROR(
+            LX("parseSemanticVersionFailed").m("Could not parse valid interface version - missing last token."));
+        return emptyOptional;
+    }
+
+    auto semanticMajorNumberString = semanticVersionString.substr(0, periodLocation);
+    if (semanticMajorNumberString.empty()) {
+        ACSDK_ERROR(
+            LX("parseSemanticVersionFailed").m("Could not parse valid interface version - missing major number."));
+        return emptyOptional;
+    }
+
+    if (!std::all_of(semanticMajorNumberString.begin(), semanticMajorNumberString.end(), ::isdigit)) {
+        ACSDK_ERROR(
+            LX("parseSemanticVersionFailed").m("Could not parse valid interface version - invalid major number."));
+        return emptyOptional;
+    }
+
+    int semanticMajorNumber = std::stoi(semanticMajorNumberString);
+
+    auto semanticMinorNumberString = semanticVersionString.substr(periodLocation + 1);
+    if (semanticMinorNumberString.empty()) {
+        ACSDK_ERROR(
+            LX("parseSemanticVersionFailed").m("Could not parse valid interface version - missing minor number."));
+        return emptyOptional;
+    }
+
+    if (!std::all_of(semanticMinorNumberString.begin(), semanticMinorNumberString.end(), ::isdigit)) {
+        ACSDK_ERROR(
+            LX("parseSemanticVersionFailed").m("Could not parse valid interface version - invalid minor number."));
+        return emptyOptional;
+    }
+
+    int semanticMinorNumber = std::stoi(semanticMinorNumberString);
+
+    return Optional<std::pair<int, int>>(std::pair<int, int>(semanticMajorNumber, semanticMinorNumber));
+}
+
+/**
+ * Parses an AVSInterface from the rapidjson DOM structure.
+ *
+ * @param interfaceIter The node to parse.
+ * @return An AVSInterface object, else nullptr if the object could not be parsed.
+ */
+static std::unique_ptr<AVSInterface> parseJSONAVSInterface(Value::ConstValueIterator& interfaceIter) {
+    std::string interfaceNameString;
+    if (!jsonUtils::retrieveValue(
+            *interfaceIter, AGENT_CONFIGURATION_JSON_AVS_INTERFACES_INTERFACE_NAME_KEY, &(interfaceNameString))) {
+        ACSDK_ERROR(
+            LX("Capability missing a required element:" +
+               std::string(AGENT_CONFIGURATION_JSON_AVS_INTERFACES_INTERFACE_NAME_KEY)));
+        return nullptr;
+    }
+
+    if (AGENT_CONFIGURATION_JSON_AVS_INTERFACES_INTERFACE_ASTERISK == interfaceNameString) {
+        // special case - this single capability expresses support for all capabilities. No other fields are required in
+        // this parsed object.
+
+        return std::unique_ptr<AVSInterface>(new AVSInterface(
+            AGENT_CONFIGURATION_JSON_AVS_INTERFACES_INTERFACE_ASTERISK,
+            std::pair<int, int>(0, 0),
+            std::set<std::string>(),
+            std::set<std::string>()));
+    }
+
+    // otherwise, minimumInterfaceVersion is required, but Events & Directives remain optional.
+
+    std::string minimumInterfaceVersionString;
+    if (!jsonUtils::retrieveValue(
+            *interfaceIter,
+            AGENT_CONFIGURATION_JSON_AVS_INTERFACES_MINIMUM_INTERFACE_VERSION_KEY,
+            &(minimumInterfaceVersionString))) {
+        ACSDK_ERROR(
+            LX("Capability missing a required element:" +
+               std::string(AGENT_CONFIGURATION_JSON_AVS_INTERFACES_MINIMUM_INTERFACE_VERSION_KEY)));
+        return nullptr;
+    }
+
+    auto semanticVersionOptional = parseSemanticVersion(minimumInterfaceVersionString);
+    if (!semanticVersionOptional.hasValue()) {
+        ACSDK_ERROR(LX("Semantic version could not be parsed correctly:" + minimumInterfaceVersionString));
+        return nullptr;
+    }
+    auto semanticVersion = semanticVersionOptional.value();
+
+    std::set<std::string> events;
+    auto optionalEvents =
+        utils::json::readStringArray(interfaceIter, AGENT_CONFIGURATION_JSON_AVS_INTERFACES_EVENTS_KEY);
+    if (optionalEvents.hasValue()) {
+        events = optionalEvents.value();
+    }
+
+    std::set<std::string> directives;
+    auto optionalDirectives =
+        utils::json::readStringArray(interfaceIter, AGENT_CONFIGURATION_JSON_AVS_INTERFACES_DIRECTIVES_KEY);
+    if (optionalDirectives.hasValue()) {
+        directives = optionalDirectives.value();
+    }
+
+    return std::unique_ptr<AVSInterface>(new AVSInterface(interfaceNameString, semanticVersion, events, directives));
+}
+
+/**
+ * Parses a @c LocaleInterface object from a rapidjson parsed DOM structure.
+ *
+ * @param localeIter The node to parse.
+ * @return a @c LocaleInterface, or nullptr if the locale could not be parsed.
+ */
+std::shared_ptr<multiAgentInterface::agent::LocaleInterface> parseJSONLocale(Value::ConstValueIterator& localeIter) {
+    std::string localeName;
+    if (!jsonUtils::retrieveValue(*localeIter, AGENT_CONFIGURATION_JSON_AGENT_LOCALE_KEY, &(localeName))) {
+        ACSDK_ERROR(LX(
+            "AgentConfiguration missing a required element:" + std::string(AGENT_CONFIGURATION_JSON_AGENT_LOCALE_KEY)));
+        return nullptr;
+    }
+
+    auto wakeWords = utils::json::readStringArray(localeIter, AGENT_CONFIGURATION_JSON_AGENT_WAKEWORDS_KEY);
+    if (!wakeWords.hasValue()) {
+        ACSDK_ERROR(LX("Unable to parse string array:" + std::string(AGENT_CONFIGURATION_JSON_AGENT_WAKEWORDS_KEY)));
+        return nullptr;
+    }
+
+    std::shared_ptr<multiAgentInterface::agent::LocaleInterface> locale =
+        std::make_shared<agent::Locale>(localeName, wakeWords.value());
+
+    return locale;
+}
+
+std::shared_ptr<Agent> ConfigParser::parseJSON(Value::ConstValueIterator& agentNode) {
+    uint64_t agentId = 0;
+    std::string agentName;
+    std::vector<AVSInterface> interfaces;
+    std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>> locales;
+
+    if (!jsonUtils::retrieveValue(*agentNode, AGENT_CONFIGURATION_JSON_AGENT_ID_KEY, &(agentId))) {
+        ACSDK_ERROR(LX("parseJSONFailed")
+                        .m("AgentConfiguration missing a required element:" +
+                           std::string(AGENT_CONFIGURATION_JSON_AGENT_ID_KEY)));
+        return nullptr;
+    }
+
+    if (!jsonUtils::retrieveValue(*agentNode, AGENT_CONFIGURATION_JSON_AGENT_NAME_KEY, &(agentName))) {
+        ACSDK_ERROR(LX("parseJSONFailed")
+                        .m("AgentConfiguration missing a required element:" +
+                           std::string(AGENT_CONFIGURATION_JSON_AGENT_NAME_KEY)));
+        return nullptr;
+    }
+
+    Value::ConstMemberIterator nodeSearchIter;
+    if (!jsonUtils::findNode(*agentNode, AGENT_CONFIGURATION_JSON_SERVICE_CONFIGURATION_KEY, &nodeSearchIter)) {
+        ACSDK_ERROR(LX("parseJSONFailed")
+                        .m("Missing element: " + std::string(AGENT_CONFIGURATION_JSON_SERVICE_CONFIGURATION_KEY)));
+        return nullptr;
+    }
+    const Value& serviceConfigNode = (*agentNode)[AGENT_CONFIGURATION_JSON_SERVICE_CONFIGURATION_KEY];
+    auto serviceConfigOptional = parseJSONServiceConfiguration(serviceConfigNode);
+    if (!serviceConfigOptional.hasValue()) {
+        ACSDK_ERROR(LX("parseJSONFailed").m("Unable to parse Agent Configuration Service Configuration."));
+        return nullptr;
+    }
+    auto serviceConfig = serviceConfigOptional.value();
+
+    Optional<Agent::AuthConfiguration> authConfigOptional;
+    if (jsonUtils::findNode(*agentNode, AGENT_CONFIGURATION_JSON_AUTHORIZATION_CONFIGURATION_KEY, &nodeSearchIter)) {
+        const Value& authConfigNode = (*agentNode)[AGENT_CONFIGURATION_JSON_AUTHORIZATION_CONFIGURATION_KEY];
+        authConfigOptional = parseJSONAuthConfiguration(authConfigNode);
+        if (!authConfigOptional.hasValue()) {
+            ACSDK_ERROR(LX("parseJSONFailed").m("Unable to parse Agent Configuration Auth Configuration."));
+            return nullptr;
+        }
+    }
+    auto authConfig = authConfigOptional.value();
+
+    if (!utils::json::validateObjectArray(agentNode, AGENT_CONFIGURATION_JSON_AVS_INTERFACES_KEY)) {
+        ACSDK_ERROR(LX("parseJSONFailed")
+                        .m("AgentConfiguration missing a required element:" +
+                           std::string(AGENT_CONFIGURATION_JSON_AVS_INTERFACES_KEY)));
+        return nullptr;
+    }
+
+    const Value& interfacesArray = (*agentNode)[AGENT_CONFIGURATION_JSON_AVS_INTERFACES_KEY];
+    for (Value::ConstValueIterator iterator = interfacesArray.Begin(); iterator != interfacesArray.End(); ++iterator) {
+        auto interface = parseJSONAVSInterface(iterator);
+        if (!interface) {
+            ACSDK_ERROR(LX("parseJSONFailed").m("Problem reading AVS Interface."));
+            return nullptr;
+        }
+
+        interfaces.push_back(*interface);
+    }
+
+    if (!utils::json::validateObjectArray(agentNode, AGENT_CONFIGURATION_JSON_AGENT_LOCALES_KEY)) {
+        ACSDK_ERROR(LX("parseJSONFailed")
+                        .m("AgentConfiguration missing a required element:" +
+                           std::string(AGENT_CONFIGURATION_JSON_AGENT_LOCALES_KEY)));
+        return nullptr;
+    }
+
+    const Value& localeArray = (*agentNode)[AGENT_CONFIGURATION_JSON_AGENT_LOCALES_KEY];
+    for (Value::ConstValueIterator iterator = localeArray.Begin(); iterator != localeArray.End(); ++iterator) {
+        auto locale = parseJSONLocale(iterator);
+        if (!locale) {
+            ACSDK_ERROR(LX("parseJSONFailed").m("Could not parse locale."));
+            return nullptr;
+        }
+
+        locales.insert(locale);
+    }
+
+    return Agent::create(agentId, agentName, serviceConfig, authConfig, interfaces, locales);
+}
+
+}  // namespace agent
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgent/src/Agent/Locale.cpp b/core/MultiAgent/MultiAgent/src/Agent/Locale.cpp
new file mode 100644
index 00000000..f21a1e69
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/src/Agent/Locale.cpp
@@ -0,0 +1,80 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <acsdk/MultiAgent/Agent/Locale.h>
+
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace agent {
+
+/// String to identify log entries originating from this file.
+#define TAG "Locale"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+bool Locale::verifyWakeWordSubset(const std::set<std::string>& subset, const std::set<std::string>& superset) {
+    for (const auto& ww : subset) {
+        if (superset.find(ww) == superset.end()) {
+            ACSDK_ERROR(LX("verifyWakeWordSubsetFailed").m("wake word was not found in the superset:" + ww));
+            return false;
+        }
+    }
+
+    return true;
+}
+
+Locale::Locale(const std::string& name, const std::set<std::string>& wakeWords) : m_name{name}, m_wakeWords{wakeWords} {
+    // ensure empty string is not present in our set.
+    if (m_wakeWords.find("") != m_wakeWords.end()) {
+        m_wakeWords.erase("");
+    }
+}
+
+std::string Locale::getName() const {
+    return m_name;
+}
+
+std::set<std::string> Locale::getAllWakeWords() const {
+    return m_wakeWords;
+}
+std::set<std::string> Locale::getActiveWakeWords() const {
+    return m_activeWakeWords;
+}
+
+bool Locale::setActiveWakeWords(const std::set<std::string>& wakeWords) {
+    if (!verifyWakeWordSubset(wakeWords, m_wakeWords)) {
+        ACSDK_DEBUG9(LX("setActiveWakeWordsFailed").m("Could not verify subset."));
+        return false;
+    }
+
+    m_activeWakeWords = wakeWords;
+
+    return true;
+}
+
+bool Locale::operator<(const multiAgentInterface::agent::LocaleInterface& rhs) const {
+    return m_name < rhs.getName();
+}
+
+}  // namespace agent
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgent/src/AgentManager.cpp b/core/MultiAgent/MultiAgent/src/AgentManager.cpp
new file mode 100644
index 00000000..f39c43d7
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/src/AgentManager.cpp
@@ -0,0 +1,679 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <acsdk/MultiAgent/AgentManager.h>
+#include <acsdk/MultiAgent/Agent/Agent.h>
+#include <acsdk/MultiAgent/Agent/ConfigParser.h>
+#include "acsdk/MultiAgentInterface/Connection/AgentConnectionManagerInterface.h"
+#include <acsdk/MultiAgent/Utils/JSONUtils.h>
+
+#include <AVSCommon/Utils/JSON/JSONUtils.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+#include <AVSCommon/Utils/Optional.h>
+
+#include <string>
+
+#include <rapidjson/document.h>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+
+/// JSON key to get the array of Agent objects within the configuration stream.
+static const char AGENT_CONFIGURATION_JSON_AGENTS_KEY[] = "agents";
+
+/// String to identify log entries originating from this file.
+#define TAG "AgentManager"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/**
+ * Utility function which takes an input string of JSON data, as well as a configured AgentConnectionManagerInterface,
+ * and parses the JSON to construct Agent objects.
+ *
+ * @param unparsedText A string of JSON data which must conform to the specification of the AVS SDK
+ * AgentConfigurations.json template.
+ *
+ * // todo: what is a better way to describe this when we externalize?
+ *
+ * @param connectionManager A connection manager which the instantiated Agents may use to connect to their respective
+ * cloud services.
+ * @return An optional set of Agents. If any aspect of parsing or construction fails, the optional will hold no value.
+ */
+static avsCommon::utils::Optional<std::set<std::shared_ptr<agent::Agent>>> parseAgentsConfig(
+    const std::string& unparsedText) {
+    // local aliases
+    using AgentSet = std::set<std::shared_ptr<agent::Agent>>;
+    using OptionalType = avsCommon::utils::Optional<AgentSet>;
+
+    OptionalType emptyOptional;
+    rapidjson::Document document;
+
+    // invoke parse with a flag which supports double-slash comments within JSON.
+    document.Parse<rapidjson::kParseCommentsFlag>(unparsedText.c_str());
+
+    if (document.HasParseError()) {
+        std::stringstream ss;
+        ss << "Error parsing document at offset:" << document.GetErrorOffset()
+           << ", error:" << rapidjson::GetParseErrorFunc(document.GetParseError());
+        ACSDK_ERROR(LX("parseAgentsConfigFailed").m(ss.str()));
+        return emptyOptional;
+    }
+
+    if (!avsCommon::utils::json::jsonUtils::jsonArrayExists(document, AGENT_CONFIGURATION_JSON_AGENTS_KEY)) {
+        ACSDK_ERROR(
+            LX("parseAgentsConfigFailed").m("Missing element: " + std::string(AGENT_CONFIGURATION_JSON_AGENTS_KEY)));
+        return emptyOptional;
+    }
+
+    rapidjson::Value::ConstMemberIterator agentsArrayIter;
+    if (!avsCommon::utils::json::jsonUtils::findNode(document, AGENT_CONFIGURATION_JSON_AGENTS_KEY, &agentsArrayIter)) {
+        ACSDK_ERROR(
+            LX("parseAgentsConfigFailed").m("Missing element: " + std::string(AGENT_CONFIGURATION_JSON_AGENTS_KEY)));
+        return emptyOptional;
+    }
+
+    const rapidjson::Value& agentsArray = document[AGENT_CONFIGURATION_JSON_AGENTS_KEY];
+    if (!agentsArray.IsArray()) {
+        ACSDK_ERROR(LX("parseAgentsConfigFailed")
+                        .m(std::string(AGENT_CONFIGURATION_JSON_AGENTS_KEY) + " config element is not a JSON array."));
+        return emptyOptional;
+    }
+
+    AgentSet agents;
+    for (rapidjson::Value::ConstValueIterator iterator = agentsArray.Begin(); iterator != agentsArray.End();
+         ++iterator) {
+        auto agent = agent::ConfigParser::parseJSON(iterator);
+        if (!agent) {
+            ACSDK_ERROR(LX("parseAgentsConfigFailed").m("Unable to parse Agent from config."));
+            return emptyOptional;
+        }
+
+        agents.insert(agent);
+    }
+
+    return OptionalType(agents);
+}
+
+std::shared_ptr<AgentManager> AgentManager::create(std::istream& agentConfigurationsStream) {
+    if (!agentConfigurationsStream.good()) {
+        ACSDK_ERROR(LX("createFailed").m("AgentConfigurations stream is not valid."));
+        return nullptr;
+    }
+
+    auto agentManager = std::shared_ptr<AgentManager>(new AgentManager());
+    if (!agentManager->initialize(agentConfigurationsStream)) {
+        ACSDK_ERROR(LX("createFailed").m("Could not initialize AgentManager."));
+        return nullptr;
+    }
+
+    return agentManager;
+}
+
+void AgentManager::onAgentAvailabilityStateChanged(
+    avsCommon::avs::AgentId::IdType id,
+    multiAgentInterface::connection::AgentConnectionObserverInterface::AvailabilityState status,
+    const std::string& reason) {
+    for (const auto& observer : m_agentObservers[id].connectionObservers) {
+        observer->onAgentAvailabilityStateChanged(id, status, reason);
+    }
+}
+
+bool AgentManager::initialize(std::istream& agentConfigurationsStream) {
+    auto fileText =
+        std::string((std::istreambuf_iterator<char>(agentConfigurationsStream)), std::istreambuf_iterator<char>());
+    auto optionalAgents = parseAgentsConfig(fileText);
+    if (!optionalAgents.hasValue()) {
+        ACSDK_ERROR(LX("initializeFailed").m("Unable to parse Agents from the provided JSON."));
+        return false;
+    }
+
+    // ensure agent ids are unique, and do not conflict with pre-defined symbols.
+    std::set<avsCommon::avs::AgentId::IdType> agentIds;
+    for (const auto& agent : optionalAgents.value()) {
+        avsCommon::avs::AgentId::IdType testId = agent->getId();
+        if (agentIds.find(testId) != agentIds.end()) {
+            ACSDK_ERROR(LX("initializeFailed").m("Duplicate agent id detected:" + std::to_string(testId)));
+            return false;
+        }
+        agentIds.insert(testId);
+    }
+
+    if (agentIds.find(avsCommon::avs::AgentId::AGENT_ID_NONE) != agentIds.end()) {
+        ACSDK_ERROR(LX("initializeFailed")
+                        .m("Invalid agent id used (collides with 'AGENT_ID_NONE'):" +
+                           std::to_string(avsCommon::avs::AgentId::AGENT_ID_NONE)));
+        return false;
+    }
+    if (agentIds.find(avsCommon::avs::AgentId::AGENT_ID_ALL) != agentIds.end()) {
+        ACSDK_ERROR(LX("initializeFailed")
+                        .m("Invalid agent id used (collides with 'AGENT_ID_ALL'):" +
+                           std::to_string(avsCommon::avs::AgentId::AGENT_ID_ALL)));
+        return false;
+    }
+
+    // ensure there is no conflict between wake words across different agents.
+    std::set<std::string> allWakeWords;
+    for (const auto& agent : optionalAgents.value()) {
+        // first, collapse ww across the locales for the same agent, since the same ww may exist in multiple locales.
+        std::set<std::string> agentWakeWords;
+        auto locales = agent->getLocales();
+        for (const auto& locale : locales) {
+            auto wakeWords = locale->getAllWakeWords();
+            agentWakeWords.insert(wakeWords.begin(), wakeWords.end());
+        }
+
+        // now test this against the complete set.
+        for (const auto& ww : agentWakeWords) {
+            if (allWakeWords.find(ww) != allWakeWords.end()) {
+                ACSDK_ERROR(LX("initializeFailed").m("Colliding wake word across agents:" + ww));
+                return false;
+            }
+            allWakeWords.insert(ww);
+        }
+    }
+
+    // good - let's populate our agent objects and the observer map.
+    for (const auto& agent : optionalAgents.value()) {
+        auto agentId = agent->getId();
+        m_agentMap[agentId] = agent;
+        m_agentObservers[agentId] = Observers();
+        m_agentMap[agentId]->addAgentConnectionObserverInterface(shared_from_this());
+    }
+
+    // set gestures to no agent.
+    assignGesture(avsCommon::avs::AgentId::AGENT_ID_NONE, avsCommon::avs::AgentInitiator::PRESS_AND_HOLD);
+    assignGesture(avsCommon::avs::AgentId::AGENT_ID_NONE, avsCommon::avs::AgentInitiator::TAP);
+
+    return true;
+}
+
+std::set<avsCommon::avs::AgentId::IdType> AgentManager::getAllAgentIds() {
+    std::set<avsCommon::avs::AgentId::IdType> ids;
+    for (const auto& mapPair : m_agentMap) {
+        ids.insert(mapPair.first);
+    }
+    return ids;
+}
+
+std::string AgentManager::getAgentName(avsCommon::avs::AgentId::IdType id) {
+    auto agent = getAgent(id);
+    if (!agent) {
+        ACSDK_ERROR(LX("getAgentNameFailed").m("Unable to find agent."));
+        return "";
+    }
+
+    return agent->getName();
+}
+
+std::set<avsCommon::avs::AgentId::IdType> AgentManager::getAVSInterfaceEnabledAgentIds(
+    const std::string& avsNamespace,
+    const std::string& avsName,
+    const std::pair<int, int>& version) {
+    std::set<avsCommon::avs::AgentId::IdType> ids;
+
+    for (const auto& pair : m_agentMap) {
+        auto agent = pair.second;
+        if (agent->isAVSMessageSupported(avsNamespace, version, avsName)) {
+            ids.insert(agent->getId());
+        }
+    }
+
+    return ids;
+}
+
+std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>> AgentManager::getAgentLocales(
+    avsCommon::avs::AgentId::IdType id) {
+    auto agent = getAgent(id);
+    if (!agent) {
+        ACSDK_ERROR(LX("getAgentLocalesFailed").m("Unable to find agent."));
+        return std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>>();
+    }
+
+    return agent->getLocales();
+}
+
+std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>> AgentManager::getAgentActiveLocales(
+    avsCommon::avs::AgentId::IdType id) {
+    auto agent = getAgent(id);
+    if (!agent) {
+        ACSDK_ERROR(LX("getAgentLocalesFailed").m("Unable to find agent."));
+        return std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>>();
+    }
+
+    return agent->getActiveLocales();
+}
+
+std::set<avsCommon::avs::AgentInitiator> AgentManager::getAgentGestures(avsCommon::avs::AgentId::IdType id) {
+    if (!getAgent(id)) {
+        ACSDK_ERROR(LX("getAgentGesturesFailed").m("Unable to find agent."));
+        return std::set<avsCommon::avs::AgentInitiator>();
+    }
+
+    std::set<avsCommon::avs::AgentInitiator> gestures;
+
+    if (m_assignedGestures[avsCommon::avs::AgentInitiator::PRESS_AND_HOLD] == id) {
+        gestures.insert(avsCommon::avs::AgentInitiator::PRESS_AND_HOLD);
+    }
+
+    if (m_assignedGestures[avsCommon::avs::AgentInitiator::TAP] == id) {
+        gestures.insert(avsCommon::avs::AgentInitiator::TAP);
+    }
+
+    return gestures;
+}
+
+bool AgentManager::isAgentEnabled(avsCommon::avs::AgentId::IdType id) {
+    auto agent = getAgent(id);
+    if (!agent) {
+        ACSDK_ERROR(LX("isAgentEnabledFailed").m("Unable to find agent."));
+        return false;
+    }
+
+    return agent->isEnabled();
+}
+
+bool AgentManager::enableAgent(avsCommon::avs::AgentId::IdType id) {
+    auto agent = getAgent(id);
+    if (!agent) {
+        ACSDK_ERROR(LX("enableAgentFailed").m("Unable to find agent."));
+        return false;
+    }
+
+    agent->enable();
+    for (const auto& observer : m_agentObservers[id].enablementObservers) {
+        observer->onEnabled(id);
+    }
+
+    return true;
+}
+
+bool AgentManager::disableAgent(avsCommon::avs::AgentId::IdType id) {
+    auto agent = getAgent(id);
+    if (!agent) {
+        ACSDK_ERROR(LX("disableAgentFailed").m("Unable to find agent."));
+        return false;
+    }
+
+    agent->disable();
+
+    for (const auto& observer : m_agentObservers[id].enablementObservers) {
+        observer->onDisabled(id);
+    }
+
+    return true;
+}
+
+void AgentManager::setAgentConnectionManager(
+    const std::shared_ptr<multiAgentInterface::connection::AgentConnectionManagerInterface>& connectionManager) {
+    for (const auto& mapPair : m_agentMap) {
+        mapPair.second->setAgentConnectionManager(connectionManager);
+    }
+}
+
+bool AgentManager::setBaseURL(avsCommon::avs::AgentId::IdType id, const std::string& baseURL) {
+    auto agent = getAgent(id);
+    if (!agent) {
+        ACSDK_ERROR(LX("disableAgentFailed").m("Unable to find agent."));
+        return false;
+    }
+
+    agent->setServiceBaseURL(baseURL);
+
+    return true;
+}
+
+bool AgentManager::setActiveLocales(avsCommon::avs::AgentId::IdType id, const std::set<std::string>& localeNames) {
+    auto agent = getAgent(id);
+    if (!agent) {
+        ACSDK_ERROR(LX("setActiveLocalesFailed").m("Unable to find agent."));
+        return false;
+    }
+
+    if (agent->setActiveLocales(localeNames)) {
+        for (const auto& observer : m_agentObservers[id].localeObservers) {
+            // TODO - turn into deep copy to ensure observers don't accidentally modify the locales.
+            observer->onLocalesChanged(id, agent->getActiveLocales());
+        }
+        return true;
+    }
+
+    return false;
+}
+
+bool AgentManager::setActiveWakeWords(
+    avsCommon::avs::AgentId::IdType id,
+    const std::string& localeName,
+    const std::set<std::string>& wakeWords) {
+    auto agent = getAgent(id);
+    if (!agent) {
+        ACSDK_ERROR(LX("setActiveWakeWordsFailed").m("Unable to find agent."));
+        return false;
+    }
+
+    if (agent->setActiveWakeWords(localeName, wakeWords)) {
+        for (const auto& observer : m_agentObservers[id].localeObservers) {
+            // TODO - turn into deep copy to ensure observers don't accidentally modify the locales.
+            observer->onLocalesChanged(id, agent->getActiveLocales());
+        }
+        return true;
+    }
+
+    return false;
+}
+
+bool AgentManager::setAgentGesture(avsCommon::avs::AgentId::IdType id, avsCommon::avs::AgentInitiator gesture) {
+    if (assignGesture(id, gesture)) {
+        std::set<avsCommon::avs::AgentInitiator> gestures;
+        if (id == m_assignedGestures[avsCommon::avs::AgentInitiator::PRESS_AND_HOLD]) {
+            gestures.insert(avsCommon::avs::AgentInitiator::PRESS_AND_HOLD);
+        }
+        if (id == m_assignedGestures[avsCommon::avs::AgentInitiator::TAP]) {
+            gestures.insert(avsCommon::avs::AgentInitiator::TAP);
+        }
+        for (const auto& observer : m_agentObservers[id].gestureObservers) {
+            observer->onGesturesChanged(id, gestures);
+        }
+        return true;
+    }
+
+    return false;
+}
+
+avsCommon::avs::AgentId::IdType AgentManager::resolveGesture(avsCommon::avs::AgentInitiator gesture) {
+    if (gesture != avsCommon::avs::AgentInitiator::PRESS_AND_HOLD && gesture != avsCommon::avs::AgentInitiator::TAP) {
+        return avsCommon::avs::AgentId::AGENT_ID_NONE;
+    }
+
+    return m_assignedGestures[gesture];
+}
+
+avsCommon::avs::AgentId::IdType AgentManager::resolveWakeWord(const std::string& wakeWord) {
+    for (const auto& agentPair : m_agentMap) {
+        auto agent = agentPair.second;
+        auto activeLocales = agent->getActiveLocales();
+        for (const auto& locale : activeLocales) {
+            auto activeWakeWords = locale->getActiveWakeWords();
+            for (const auto& ww : activeWakeWords) {
+                if (ww == wakeWord) {
+                    return agentPair.first;
+                }
+            }
+        }
+    }
+
+    return avsCommon::avs::AgentId::AGENT_ID_NONE;
+}
+
+void AgentManager::addAgentConnectionObserverInterface(
+    avsCommon::avs::AgentId::IdType id,
+    const std::shared_ptr<multiAgentInterface::connection::AgentConnectionObserverInterface>& observer) {
+    if (avsCommon::avs::AgentId::AGENT_ID_NONE == id) {
+        ACSDK_ERROR(LX("addAgentConnectionObserverInterfaceFailed").m("Invalid agent id (AGENT_ID_NONE) provided."));
+        return;
+    }
+
+    if (avsCommon::avs::AgentId::AGENT_ID_ALL == id) {
+        for (auto& mapPair : m_agentObservers) {
+            mapPair.second.connectionObservers.insert(observer);
+        }
+    } else {
+        m_agentObservers[id].connectionObservers.insert(observer);
+    }
+
+    if (avsCommon::avs::AgentId::AGENT_ID_ALL == id) {
+        for (const auto& agentPair : m_agentMap) {
+            observer->onAgentAvailabilityStateChanged(
+                agentPair.first, agentPair.second->getAvailability(), "observer registration with AgentManager.");
+        }
+    } else {
+        auto agent = getAgent(id);
+        if (!agent) {
+            ACSDK_ERROR(LX("addAgentConnectionObserverInterfaceFailed").m("Unable to find agent."));
+            return;
+        }
+        observer->onAgentAvailabilityStateChanged(
+            id, agent->getAvailability(), "observer registration with AgentManager.");
+    }
+}
+
+void AgentManager::removeAgentConnectionObserverInterface(
+    avsCommon::avs::AgentId::IdType id,
+    const std::shared_ptr<multiAgentInterface::connection::AgentConnectionObserverInterface>& observer) {
+    if (avsCommon::avs::AgentId::AGENT_ID_NONE == id) {
+        ACSDK_ERROR(LX("removeAgentConnectionObserverInterfaceFailed").m("Invalid agent id (AGENT_ID_NONE) provided."));
+        return;
+    }
+
+    if (avsCommon::avs::AgentId::AGENT_ID_ALL == id) {
+        for (auto& mapPair : m_agentObservers) {
+            mapPair.second.connectionObservers.erase(observer);
+        }
+    } else {
+        m_agentObservers[id].connectionObservers.erase(observer);
+    }
+}
+
+void AgentManager::addAgentEnablementObserverInterface(
+    avsCommon::avs::AgentId::IdType id,
+    const std::shared_ptr<multiAgentInterface::observer::AgentEnablementObserverInterface>& observer) {
+    if (avsCommon::avs::AgentId::AGENT_ID_NONE == id) {
+        ACSDK_ERROR(LX("addAgentEnablementObserverInterfaceFailed").m("Invalid agent id (AGENT_ID_NONE) provided."));
+        return;
+    }
+
+    if (avsCommon::avs::AgentId::AGENT_ID_ALL == id) {
+        for (auto& mapPair : m_agentObservers) {
+            mapPair.second.enablementObservers.insert(observer);
+        }
+    } else {
+        m_agentObservers[id].enablementObservers.insert(observer);
+    }
+
+    if (avsCommon::avs::AgentId::AGENT_ID_ALL == id) {
+        for (const auto& agentPair : m_agentMap) {
+            if (agentPair.second->isEnabled()) {
+                observer->onEnabled(agentPair.first);
+            } else {
+                observer->onDisabled(agentPair.first);
+            }
+        }
+    } else {
+        auto agent = getAgent(id);
+        if (!agent) {
+            ACSDK_ERROR(LX("addAgentEnablementObserverInterfaceFailed").m("Unable to find agent."));
+            return;
+        }
+
+        if (agent->isEnabled()) {
+            observer->onEnabled(id);
+        } else {
+            observer->onDisabled(id);
+        }
+    }
+}
+
+void AgentManager::removeAgentEnablementObserverInterface(
+    avsCommon::avs::AgentId::IdType id,
+    const std::shared_ptr<multiAgentInterface::observer::AgentEnablementObserverInterface>& observer) {
+    if (avsCommon::avs::AgentId::AGENT_ID_NONE == id) {
+        ACSDK_ERROR(LX("removeAgentEnablementObserverInterfaceFailed").m("Invalid agent id (AGENT_ID_NONE) provided."));
+        return;
+    }
+
+    if (avsCommon::avs::AgentId::AGENT_ID_ALL == id) {
+        for (auto& mapPair : m_agentObservers) {
+            mapPair.second.enablementObservers.erase(observer);
+        }
+    } else {
+        m_agentObservers[id].enablementObservers.erase(observer);
+    }
+}
+
+void AgentManager::addAgentGestureObserverInterface(
+    avsCommon::avs::AgentId::IdType id,
+    const std::shared_ptr<multiAgentInterface::observer::AgentGestureObserverInterface>& observer) {
+    if (avsCommon::avs::AgentId::AGENT_ID_NONE == id) {
+        ACSDK_ERROR(LX("addAgentGestureObserverInterfaceFailed").m("Invalid agent id (AGENT_ID_NONE) provided."));
+        return;
+    }
+
+    if (avsCommon::avs::AgentId::AGENT_ID_ALL == id) {
+        for (auto& mapPair : m_agentObservers) {
+            mapPair.second.gestureObservers.insert(observer);
+        }
+    } else {
+        m_agentObservers[id].gestureObservers.insert(observer);
+    }
+
+    if (avsCommon::avs::AgentId::AGENT_ID_ALL == id) {
+        for (const auto& agentPair : m_agentMap) {
+            observer->onGesturesChanged(agentPair.first, getAgentGestures(agentPair.first));
+        }
+    } else {
+        auto agent = getAgent(id);
+        if (!agent) {
+            ACSDK_ERROR(LX("addAgentGestureObserverInterfaceFailed").m("Unable to find agent."));
+            return;
+        }
+
+        observer->onGesturesChanged(id, getAgentGestures(id));
+    }
+}
+
+void AgentManager::removeAgentGestureObserverInterface(
+    avsCommon::avs::AgentId::IdType id,
+    const std::shared_ptr<multiAgentInterface::observer::AgentGestureObserverInterface>& observer) {
+    if (avsCommon::avs::AgentId::AGENT_ID_NONE == id) {
+        ACSDK_ERROR(LX("removeAgentGestureObserverInterfaceFailed").m("Invalid agent id (AGENT_ID_NONE) provided."));
+        return;
+    }
+
+    if (avsCommon::avs::AgentId::AGENT_ID_ALL == id) {
+        for (auto& mapPair : m_agentObservers) {
+            mapPair.second.gestureObservers.erase(observer);
+        }
+    } else {
+        m_agentObservers[id].gestureObservers.erase(observer);
+    }
+}
+
+void AgentManager::addAgentLocaleObserverInterface(
+    avsCommon::avs::AgentId::IdType id,
+    const std::shared_ptr<multiAgentInterface::observer::AgentLocaleObserverInterface>& observer) {
+    if (avsCommon::avs::AgentId::AGENT_ID_NONE == id) {
+        ACSDK_ERROR(LX("addAgentLocaleObserverInterfaceFailed").m("Invalid agent id (AGENT_ID_NONE) provided."));
+        return;
+    }
+
+    if (avsCommon::avs::AgentId::AGENT_ID_ALL == id) {
+        for (auto& mapPair : m_agentObservers) {
+            mapPair.second.localeObservers.insert(observer);
+        }
+    } else {
+        m_agentObservers[id].localeObservers.insert(observer);
+    }
+
+    if (avsCommon::avs::AgentId::AGENT_ID_ALL == id) {
+        for (const auto& agentPair : m_agentMap) {
+            observer->onLocalesChanged(agentPair.first, agentPair.second->getActiveLocales());
+        }
+    } else {
+        auto agent = getAgent(id);
+        if (!agent) {
+            ACSDK_ERROR(LX("addAgentLocaleObserverInterfaceFailed").m("Unable to find agent."));
+            return;
+        }
+
+        observer->onLocalesChanged(id, agent->getActiveLocales());
+    }
+}
+
+void AgentManager::removeAgentLocaleObserverInterface(
+    avsCommon::avs::AgentId::IdType id,
+    const std::shared_ptr<multiAgentInterface::observer::AgentLocaleObserverInterface>& observer) {
+    if (avsCommon::avs::AgentId::AGENT_ID_NONE == id) {
+        ACSDK_ERROR(LX("removeAgentLocaleObserverInterfaceFailed").m("Invalid agent id (AGENT_ID_NONE) provided."));
+        return;
+    }
+
+    if (avsCommon::avs::AgentId::AGENT_ID_ALL == id) {
+        for (auto& mapPair : m_agentObservers) {
+            mapPair.second.localeObservers.erase(observer);
+        }
+    } else {
+        m_agentObservers[id].localeObservers.erase(observer);
+    }
+}
+
+void AgentManager::printAgentDetails(avsCommon::avs::AgentId::IdType id) {
+    auto agent = getAgent(id);
+    if (!agent) {
+        ACSDK_ERROR(LX("printAgentDetailsFailed").m("Unable to find agent."));
+    }
+
+    std::cout << *agent;
+}
+
+AgentManager::AgentManager() {
+}
+
+std::shared_ptr<agent::Agent> AgentManager::getAgent(avsCommon::avs::AgentId::IdType id) {
+    if (avsCommon::avs::AgentId::AGENT_ID_NONE == id) {
+        ACSDK_ERROR(LX("getAgentFailed").m("Invalid agent id - conflicts with symbol AGENT_ID_NONE"));
+        return nullptr;
+    }
+
+    if (avsCommon::avs::AgentId::AGENT_ID_ALL == id) {
+        ACSDK_ERROR(LX("getAgentFailed").m("Invalid agent id - conflicts with symbol AGENT_ID_ALL"));
+        return nullptr;
+    }
+
+    if (m_agentMap.find(id) == m_agentMap.end()) {
+        ACSDK_ERROR(LX("getAgentFailed").m("Invalid agent id - could not be found:" + std::to_string(id)));
+        return nullptr;
+    }
+
+    return m_agentMap[id];
+}
+
+bool AgentManager::assignGesture(avsCommon::avs::AgentId::IdType id, avsCommon::avs::AgentInitiator gesture) {
+    if (gesture != avsCommon::avs::AgentInitiator::PRESS_AND_HOLD && gesture != avsCommon::avs::AgentInitiator::TAP) {
+        ACSDK_ERROR(LX("assignGestureFailed").m("Invalid gesture:" + avsCommon::avs::initiatorToString(gesture)));
+        return false;
+    }
+
+    if (avsCommon::avs::AgentId::AGENT_ID_NONE == id || getAgent(id)) {
+        m_assignedGestures[gesture] = id;
+        return true;
+    }
+
+    ACSDK_ERROR(LX("assignGestureFailed").m("Invalid agent id used:" + std::to_string(id)));
+    return false;
+}
+
+void AgentManager::clearAgents() {
+    m_agentMap.clear();
+    m_agentObservers.clear();
+    m_assignedGestures[avsCommon::avs::AgentInitiator::PRESS_AND_HOLD] = avsCommon::avs::AgentId::AGENT_ID_NONE;
+    m_assignedGestures[avsCommon::avs::AgentInitiator::TAP] = avsCommon::avs::AgentId::AGENT_ID_NONE;
+}
+
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgent/src/AgentManagerFactory.cpp b/core/MultiAgent/MultiAgent/src/AgentManagerFactory.cpp
new file mode 100644
index 00000000..a4ff61a1
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/src/AgentManagerFactory.cpp
@@ -0,0 +1,38 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <acsdk/MultiAgent/AgentManager.h>
+#include <acsdk/MultiAgent/AgentManagerFactory.h>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+
+/// String to identify log entries originating from this file.
+#define TAG "AgentManagerFactory"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+std::shared_ptr<multiAgentInterface::AgentManagerInterface> AgentManagerFactory::create(
+    std::istream& agentConfigurationsStream) {
+    return AgentManager::create(agentConfigurationsStream);
+}
+
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgent/src/CMakeLists.txt b/core/MultiAgent/MultiAgent/src/CMakeLists.txt
new file mode 100644
index 00000000..cc770303
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/src/CMakeLists.txt
@@ -0,0 +1,26 @@
+add_definitions("-DACSDK_LOG_MODULE=MultiAgent")
+
+add_library(MultiAgent
+        AgentManager.cpp
+        AgentManagerFactory.cpp
+        Agent/Agent.cpp
+        Agent/AVSInterface.cpp
+        Agent/ConfigParser.cpp
+        Agent/Locale.cpp
+        Connection/AlexaAgentConnectionManager.cpp
+        Connection/AlexaAgentConnectionManagerFactory.cpp
+        Utils/JSONUtils.cpp)
+
+target_include_directories(MultiAgent PUBLIC
+        "${MultiAgent_SOURCE_DIR}/include")
+
+target_include_directories(MultiAgent PRIVATE
+        "${MultiAgent_SOURCE_DIR}/privateInclude")
+
+target_link_libraries(MultiAgent
+        MultiAgentInterface
+        acsdkNotifier
+        AVSCommon)
+
+# install target
+asdk_install()
diff --git a/core/MultiAgent/MultiAgent/src/Connection/AlexaAgentConnectionManager.cpp b/core/MultiAgent/MultiAgent/src/Connection/AlexaAgentConnectionManager.cpp
new file mode 100644
index 00000000..47b5a8d3
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/src/Connection/AlexaAgentConnectionManager.cpp
@@ -0,0 +1,105 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+#include "acsdk/MultiAgent/Connection/AlexaAgentConnectionManager.h"
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace connection {
+
+using namespace avsCommon::sdkInterfaces;
+using namespace multiAgentInterface::connection;
+
+/// String to identify log entries originating from this file.
+#define TAG "AlexaAgentConnectionManager"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+std::shared_ptr<AlexaAgentConnectionManager> AlexaAgentConnectionManager::create(
+    const std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface>& connectionManager) {
+    if (!connectionManager) {
+        ACSDK_ERROR(LX("createFailed").d("reasons", "nullConnectionManager"));
+        return nullptr;
+    }
+
+    auto singleConnectionManager =
+        std::shared_ptr<AlexaAgentConnectionManager>(new AlexaAgentConnectionManager(connectionManager));
+    connectionManager->addConnectionStatusObserver(singleConnectionManager);
+
+    return singleConnectionManager;
+}
+
+AlexaAgentConnectionManager::AlexaAgentConnectionManager(
+    const std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface>& connectionManager) {
+}
+
+bool AlexaAgentConnectionManager::configureAgent(
+    avsCommon::avs::AgentId::IdType id,
+    const std::string& avsGateway,
+    const std::string& agentName) {
+    ACSDK_DEBUG9(LX("currently ignoring configureAgent call for the single-agent AVS case."));
+    return true;
+}
+
+void AlexaAgentConnectionManager::removeAgent(avsCommon::avs::AgentId::IdType id) {
+    ACSDK_DEBUG9(LX("currently ignoring removeAgent call for the single-agent AVS case."));
+}
+
+void AlexaAgentConnectionManager::addObserver(
+    avsCommon::avs::AgentId::IdType id,
+    const std::shared_ptr<multiAgentInterface::connection::AgentConnectionObserverInterface>& observer) {
+    // simple case - we ignore the agent id.
+    m_notifier.addWeakPtrObserver(observer);
+}
+
+void AlexaAgentConnectionManager::removeObserver(
+    avsCommon::avs::AgentId::IdType id,
+    const std::shared_ptr<multiAgentInterface::connection::AgentConnectionObserverInterface>& observer) {
+    // simple case - we ignore the agent id.
+    m_notifier.removeWeakPtrObserver(observer);
+}
+
+void AlexaAgentConnectionManager::onConnectionStatusChanged(const Status status, const ChangedReason reason) {
+    ACSDK_DEBUG9(
+        LX("Deprecated API call. Connection notifications should occur "
+           "on the engine variant of this API."));
+}
+
+void AlexaAgentConnectionManager::onConnectionStatusChanged(
+    const Status status,
+    const std::vector<EngineConnectionStatus>& engineStatuses) {
+    auto availabilityState = (Status::CONNECTED == status)
+                                 ? AgentConnectionObserverInterface::AvailabilityState::AVAILABLE
+                                 : AgentConnectionObserverInterface::AvailabilityState::UNAVAILABLE;
+
+    m_notifier.notifyObservers(
+        [availabilityState](
+            const std::shared_ptr<multiAgentInterface::connection::AgentConnectionObserverInterface>& observer) {
+            std::string availabilityReason = "AlexaAgentConnectionManager notification.";
+            observer->onAgentAvailabilityStateChanged(
+                avsCommon::avs::AgentId::getAlexaAgentId(), availabilityState, availabilityReason);
+        });
+}
+
+}  // namespace connection
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgent/src/Connection/AlexaAgentConnectionManagerFactory.cpp b/core/MultiAgent/MultiAgent/src/Connection/AlexaAgentConnectionManagerFactory.cpp
new file mode 100644
index 00000000..a359fe11
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/src/Connection/AlexaAgentConnectionManagerFactory.cpp
@@ -0,0 +1,45 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+#include "acsdk/MultiAgent/Connection/AlexaAgentConnectionManager.h"
+#include "acsdk/MultiAgent/Connection/AlexaAgentConnectionManagerFactory.h"
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace connection {
+
+using namespace avsCommon::sdkInterfaces;
+using namespace multiAgentInterface::connection;
+
+/// String to identify log entries originating from this file.
+#define TAG "AlexaAgentConnectionManagerFactory"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+std::shared_ptr<AgentConnectionManagerInterface> AlexaAgentConnectionManagerFactory::create(
+    const std::shared_ptr<AVSConnectionManagerInterface>& connectionManager) {
+    return AlexaAgentConnectionManager::create(connectionManager);
+}
+
+}  // namespace connection
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgent/src/Utils/JSONUtils.cpp b/core/MultiAgent/MultiAgent/src/Utils/JSONUtils.cpp
new file mode 100644
index 00000000..1399cf9b
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/src/Utils/JSONUtils.cpp
@@ -0,0 +1,88 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <acsdk/MultiAgent/Utils/JSONUtils.h>
+
+#include <AVSCommon/Utils/JSON/JSONUtils.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+/// String to identify log entries originating from this file.
+#define TAG "JSONUtils"
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace utils {
+namespace json {
+
+using namespace rapidjson;
+using namespace avsCommon::utils;
+using namespace avsCommon::utils::json;
+
+bool validateObjectArray(Value::ConstValueIterator& node, const std::string& arrayKey) {
+    if (!jsonUtils::jsonArrayExists(*node, arrayKey)) {
+        ACSDK_ERROR(LX("validateObjectArrayFailed").m("Missing element : " + arrayKey));
+        return false;
+    }
+
+    Value::ConstMemberIterator arrayIter;
+    if (!jsonUtils::findNode(*node, arrayKey, &arrayIter)) {
+        ACSDK_ERROR(LX("validateObjectArrayFailed").m("Missing element: " + arrayKey));
+        return false;
+    }
+
+    const Value& objectArray = (*node)[arrayKey];
+    if (!objectArray.IsArray()) {
+        ACSDK_ERROR(LX("validateObjectArrayFailed").m(arrayKey + " config element is not a JSON array."));
+        return false;
+    }
+
+    return true;
+}
+
+Optional<std::set<std::string>> readStringArray(Value::ConstValueIterator& nodeIter, const std::string& arrayKey) {
+    Optional<std::set<std::string>> emptyOptional;
+
+    if (!jsonUtils::jsonArrayExists(*nodeIter, arrayKey)) {
+        ACSDK_ERROR(LX("readStringArrayFailed").m("Missing element : " + arrayKey));
+        return emptyOptional;
+    }
+
+    Value::ConstMemberIterator arrayIter;
+    if (!jsonUtils::findNode(*nodeIter, arrayKey, &arrayIter)) {
+        ACSDK_ERROR(LX("readStringArrayFailed").m("Missing element: " + arrayKey));
+        return emptyOptional;
+    }
+
+    const Value& jsonArray = (*nodeIter)[arrayKey];
+    if (!jsonArray.IsArray()) {
+        ACSDK_ERROR(LX("readStringArrayFailed").m(arrayKey + " config element is not a JSON array."));
+        return emptyOptional;
+    }
+
+    auto stringArray = jsonUtils::retrieveStringArray<std::set<std::string>>(jsonArray);
+    return Optional<std::set<std::string>>(stringArray);
+}
+
+}  // namespace json
+}  // namespace utils
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgent/test/AVSInterfaceTest.cpp b/core/MultiAgent/MultiAgent/test/AVSInterfaceTest.cpp
new file mode 100644
index 00000000..74a5a04d
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/test/AVSInterfaceTest.cpp
@@ -0,0 +1,106 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <acsdk/MultiAgent/Agent/AVSInterface.h>
+#include <gtest/gtest.h>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace agent {
+namespace test {
+
+TEST(AVSInterfaceTest, test_normalConstruction) {
+    std::string testName = "testInterfaceName";
+    std::pair<int, int> testVersion(1, 2);
+    std::pair<int, int> testWrongVersion(3, 4);
+    std::set<std::string> testEvents{"e1", "e2", "e3"};
+    std::set<std::string> testDirectives{"d1", "d2", "d3"};
+
+    // verify members are set correctly
+    AVSInterface interface(testName, testVersion, testEvents, testDirectives);
+    ASSERT_EQ(interface.getName(), testName);
+    ASSERT_EQ(interface.getMinimumSemanticVersion(), testVersion);
+    ASSERT_NE(interface.getMinimumSemanticVersion(), testWrongVersion);
+    ASSERT_EQ(interface.getEvents(), testEvents);
+    ASSERT_EQ(interface.getDirectives(), testDirectives);
+    ASSERT_FALSE(interface.supportsAllMessages());
+}
+
+TEST(AVSInterfaceTest, test_allMessagesConstruction) {
+    std::string testName = "testInterfaceName";
+    std::pair<int, int> testVersion(1, 2);
+
+    // verify members are set correctly
+    AVSInterface interface(testName, testVersion);
+    ASSERT_EQ(interface.getName(), testName);
+    ASSERT_EQ(interface.getMinimumSemanticVersion(), testVersion);
+    ASSERT_TRUE(interface.getEvents().empty());
+    ASSERT_TRUE(interface.getDirectives().empty());
+    ASSERT_TRUE(interface.supportsAllMessages());
+}
+
+TEST(AVSInterfaceTest, test_normalSupportsMessageQuery) {
+    std::string testName = "testInterfaceName";
+    std::pair<int, int> testVersion(2, 3);
+    std::set<std::string> testEvents{"e1", "e2", "e3"};
+    std::set<std::string> testDirectives{"d1", "d2", "d3"};
+
+    AVSInterface interface(testName, testVersion, testEvents, testDirectives);
+
+    // events
+    ASSERT_FALSE(interface.isMessageSupported(std::pair<int, int>(1, 0), "e1"));
+    ASSERT_FALSE(interface.isMessageSupported(std::pair<int, int>(2, 2), "e1"));
+    ASSERT_TRUE(interface.isMessageSupported(std::pair<int, int>(2, 3), "e1"));
+    ASSERT_TRUE(interface.isMessageSupported(std::pair<int, int>(2, 4), "e1"));
+    ASSERT_TRUE(interface.isMessageSupported(std::pair<int, int>(3, 2), "e1"));
+    ASSERT_TRUE(interface.isMessageSupported(std::pair<int, int>(3, 4), "e1"));
+
+    ASSERT_FALSE(interface.isMessageSupported(std::pair<int, int>(1, 0), "e5"));
+    ASSERT_FALSE(interface.isMessageSupported(std::pair<int, int>(2, 3), "e5"));
+    ASSERT_FALSE(interface.isMessageSupported(std::pair<int, int>(3, 4), "e5"));
+
+    // directives
+    ASSERT_FALSE(interface.isMessageSupported(std::pair<int, int>(1, 0), "d1"));
+    ASSERT_FALSE(interface.isMessageSupported(std::pair<int, int>(2, 2), "d1"));
+    ASSERT_TRUE(interface.isMessageSupported(std::pair<int, int>(2, 3), "d1"));
+    ASSERT_TRUE(interface.isMessageSupported(std::pair<int, int>(2, 4), "d1"));
+    ASSERT_TRUE(interface.isMessageSupported(std::pair<int, int>(3, 2), "d1"));
+    ASSERT_TRUE(interface.isMessageSupported(std::pair<int, int>(3, 4), "d1"));
+
+    ASSERT_FALSE(interface.isMessageSupported(std::pair<int, int>(1, 0), "d5"));
+    ASSERT_FALSE(interface.isMessageSupported(std::pair<int, int>(2, 3), "d5"));
+    ASSERT_FALSE(interface.isMessageSupported(std::pair<int, int>(3, 4), "d5"));
+}
+
+TEST(AVSInterfaceTest, test_lessThanOperator) {
+    std::string testName1 = "interfaceA";
+    std::string testName2 = "interfaceB";
+    std::pair<int, int> testVersion(1, 2);
+
+    AVSInterface interface1(testName1, testVersion);
+    AVSInterface interface2(testName2, testVersion);
+
+    ASSERT_TRUE(interface1 < interface2);
+}
+
+}  // namespace test
+}  // namespace agent
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    return RUN_ALL_TESTS();
+}
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgent/test/AgentManagerTest.cpp b/core/MultiAgent/MultiAgent/test/AgentManagerTest.cpp
new file mode 100644
index 00000000..c13f79ea
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/test/AgentManagerTest.cpp
@@ -0,0 +1,103 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <acsdk/MultiAgent/AgentManagerFactory.h>
+
+//#include <acsdk/MultiAgentInterface/MockAgentManager.h>
+#include <acsdk/MultiAgentInterface/Observer/MockAgentEnablementObserver.h>
+#include <gtest/gtest.h>
+
+#include <sstream>
+
+#include "acsdk/MultiAgent/test/AgentConfigStrings.h"
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace agent {
+namespace test {
+
+class DummyConnectionManager : public multiAgentInterface::connection::AgentConnectionManagerInterface {
+public:
+    bool configureAgent(avsCommon::avs::AgentId::IdType id, const std::string& avsGateway, const std::string& agentName)
+        override {
+        return true;
+    }
+    void removeAgent(avsCommon::avs::AgentId::IdType id) override {
+    }
+    void addObserver(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<multiAgentInterface::connection::AgentConnectionObserverInterface>& observer) override {
+    }
+    void removeObserver(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<multiAgentInterface::connection::AgentConnectionObserverInterface>& observer) override {
+    }
+};
+
+TEST(AgentManagerTest, test_normalConstruction) {
+    std::istringstream istream(TWO_AGENTS_GOOD_ALL_CAPABILITIES_JSON);
+    auto agentManager = multiAgent::AgentManagerFactory::create(istream);
+    EXPECT_NE(agentManager, nullptr);
+}
+
+TEST(AgentManagerTest, test_agentEnablementNotifyNormalAgentIds) {
+    std::istringstream istream(TWO_AGENTS_GOOD_ALL_CAPABILITIES_JSON);
+    auto agentManager = multiAgent::AgentManagerFactory::create(istream);
+    auto mockEnablementObserver = std::make_shared<multiAgentInterface::observer::MockAgentEnablementObserver>();
+
+    auto agentIds = agentManager->getAllAgentIds();
+    for (auto id : agentIds) {
+        EXPECT_CALL(*mockEnablementObserver, onDisabled(id)).Times(1);
+        agentManager->addAgentEnablementObserverInterface(id, mockEnablementObserver);
+    }
+
+    agentManager->clearAgents();
+}
+
+TEST(AgentManagerTest, test_agentEnablementNotifyAllAgentIds) {
+    std::istringstream istream(TWO_AGENTS_GOOD_ALL_CAPABILITIES_JSON);
+    auto agentManager = multiAgent::AgentManagerFactory::create(istream);
+    auto mockEnablementObserver = std::make_shared<multiAgentInterface::observer::MockAgentEnablementObserver>();
+
+    auto agentIds = agentManager->getAllAgentIds();
+    auto mockEnablementObserverAll = std::make_shared<multiAgentInterface::observer::MockAgentEnablementObserver>();
+    EXPECT_CALL(*mockEnablementObserverAll, onDisabled(testing::_)).Times(agentIds.size());
+    agentManager->addAgentEnablementObserverInterface(avsCommon::avs::AgentId::AGENT_ID_ALL, mockEnablementObserverAll);
+    agentManager->clearAgents();
+}
+
+TEST(AgentManagerTest, test_agentEnablementRegisterAllEnableOne) {
+    std::istringstream istream(TWO_AGENTS_GOOD_ALL_CAPABILITIES_JSON);
+    auto agentManager = multiAgent::AgentManagerFactory::create(istream);
+
+    auto mockEnablementObserverAll = std::make_shared<multiAgentInterface::observer::MockAgentEnablementObserver>();
+    agentManager->addAgentEnablementObserverInterface(avsCommon::avs::AgentId::AGENT_ID_ALL, mockEnablementObserverAll);
+
+    auto agentIds = agentManager->getAllAgentIds();
+    auto testAgentId = *(agentIds.begin());
+    EXPECT_CALL(*mockEnablementObserverAll, onEnabled(testAgentId)).Times(1);
+    agentManager->enableAgent(testAgentId);
+    agentManager->clearAgents();
+}
+
+}  // namespace test
+}  // namespace agent
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    return RUN_ALL_TESTS();
+}
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgent/test/AgentTest.cpp b/core/MultiAgent/MultiAgent/test/AgentTest.cpp
new file mode 100644
index 00000000..6bf52bcd
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/test/AgentTest.cpp
@@ -0,0 +1,60 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <AVSCommon/AVS/AgentId.h>
+#include <acsdk/MultiAgent/Agent/AVSInterface.h>
+#include <acsdk/MultiAgent/Agent/Agent.h>
+#include <acsdk/MultiAgent/Agent/Locale.h>
+#include <gtest/gtest.h>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace agent {
+namespace test {
+
+TEST(AgentTest, test_normalConstruction) {
+    avsCommon::avs::AgentId::IdType badId1 = avsCommon::avs::AgentId::AGENT_ID_NONE;
+    avsCommon::avs::AgentId::IdType badId2 = avsCommon::avs::AgentId::AGENT_ID_ALL;
+    avsCommon::avs::AgentId::IdType goodId = 2;
+
+    std::vector<AVSInterface> avsInterfaces;
+    avsInterfaces.push_back(
+        AVSInterface("*", std::pair<int, int>(0, 0), std::set<std::string>(), std::set<std::string>()));
+
+    std::set<std::shared_ptr<multiAgentInterface::agent::LocaleInterface>> locales;
+    locales.insert(std::make_shared<multiAgent::agent::Locale>("en-US", std::set<std::string>{"Alexa"}));
+
+    auto agent = Agent::create(
+        badId1, "testName", Agent::ServiceConfiguration(), Agent::AuthConfiguration(), avsInterfaces, locales);
+    ASSERT_EQ(agent, nullptr);
+
+    agent = Agent::create(
+        badId2, "testName", Agent::ServiceConfiguration(), Agent::AuthConfiguration(), avsInterfaces, locales);
+    ASSERT_EQ(agent, nullptr);
+
+    agent = Agent::create(
+        goodId, "testName", Agent::ServiceConfiguration(), Agent::AuthConfiguration(), avsInterfaces, locales);
+    ASSERT_NE(agent, nullptr);
+}
+
+}  // namespace test
+}  // namespace agent
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    return RUN_ALL_TESTS();
+}
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgent/test/CMakeLists.txt b/core/MultiAgent/MultiAgent/test/CMakeLists.txt
new file mode 100644
index 00000000..4df86b1d
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/test/CMakeLists.txt
@@ -0,0 +1,9 @@
+cmake_minimum_required(VERSION 3.1 FATAL_ERROR)
+
+set(INCLUDE_PATH
+        "${MultiAgent_SOURCE_DIR}/include"
+        "${MultiAgent_SOURCE_DIR}/privateInclude"
+        "${MultiAgent_SOURCE_DIR}/test/include")
+
+discover_unit_tests("${INCLUDE_PATH}" "MultiAgent;MultiAgentInterfaceTestUtils" ".")
+
diff --git a/core/MultiAgent/MultiAgent/test/ConfigParserTest.cpp b/core/MultiAgent/MultiAgent/test/ConfigParserTest.cpp
new file mode 100644
index 00000000..7552c052
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/test/ConfigParserTest.cpp
@@ -0,0 +1,188 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <acsdk/MultiAgent/Agent/ConfigParser.h>
+#include <gtest/gtest.h>
+
+#include <utility>
+
+#include "acsdk/MultiAgent/test/AgentConfigStrings.h"
+#include "acsdk/MultiAgentInterface/Connection/AgentConnectionManagerInterface.h"
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace agent {
+namespace test {
+
+class DummyConnectionManager : public multiAgentInterface::connection::AgentConnectionManagerInterface {
+public:
+    bool configureAgent(avsCommon::avs::AgentId::IdType id, const std::string& avsGateway, const std::string& agentName)
+        override {
+        return true;
+    }
+    void removeAgent(avsCommon::avs::AgentId::IdType id) override {
+    }
+    void addObserver(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<multiAgentInterface::connection::AgentConnectionObserverInterface>& observer) override {
+    }
+    void removeObserver(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<multiAgentInterface::connection::AgentConnectionObserverInterface>& observer) override {
+    }
+};
+
+static const std::string g_SpeechSynthesizerNameSpace = "SpeechSynthesizer";
+static const std::string g_SpeechSynthesizerSpeakName = "Speak";
+// static const std::pair<int, int> g_testSpeakVersion(1, 2);
+static const std::string AGENT_CONFIGURATION_JSON_AGENTS_KEY = "agents";
+
+static std::shared_ptr<Agent> parseSingleAgent(const std::string& jsonString) {
+    auto connectionManager = std::make_shared<DummyConnectionManager>();
+    rapidjson::Document document;
+
+    // invoke parse with a flag which supports double-slash comments within JSON.
+    document.Parse<rapidjson::kParseCommentsFlag>(jsonString.c_str());
+    if (document.HasParseError()) {
+        return nullptr;
+    }
+
+    const rapidjson::Value& agentsArray = document[AGENT_CONFIGURATION_JSON_AGENTS_KEY];
+    if (!agentsArray.IsArray()) {
+        return nullptr;
+    }
+
+    std::shared_ptr<Agent> agent;
+    for (rapidjson::Value::ConstValueIterator iterator = agentsArray.Begin(); iterator != agentsArray.End();
+         ++iterator) {
+        agent = agent::ConfigParser::parseJSON(iterator);
+    }
+
+    return agent;
+}
+
+static bool parseMultipleAgents(const std::string& jsonString) {
+    auto connectionManager = std::make_shared<DummyConnectionManager>();
+    rapidjson::Document document;
+
+    // invoke parse with a flag which supports double-slash comments within JSON.
+    document.Parse<rapidjson::kParseCommentsFlag>(jsonString.c_str());
+    if (document.HasParseError()) {
+        return false;
+    }
+
+    const rapidjson::Value& agentsArray = document[AGENT_CONFIGURATION_JSON_AGENTS_KEY];
+    if (!agentsArray.IsArray()) {
+        return false;
+    }
+
+    int counter = 0;
+    std::shared_ptr<Agent> agent;
+    for (rapidjson::Value::ConstValueIterator iterator = agentsArray.Begin(); iterator != agentsArray.End();
+         ++iterator) {
+        agent = agent::ConfigParser::parseJSON(iterator);
+        counter++;
+    }
+
+    return counter > 1;
+}
+
+TEST(ConfigParserTest, test_parseGoodAgentOneCapability) {
+    auto agent = parseSingleAgent(ONE_AGENT_GOOD_ONE_CAPABILITY_JSON);
+    ASSERT_TRUE(nullptr != agent);
+}
+
+TEST(ConfigParserTest, test_parseGoodAgentOneCapabilityBad) {
+    auto agent = parseSingleAgent(ONE_AGENT_GOOD_ONE_CAPABILITY_BAD_A_JSON);
+    ASSERT_TRUE(nullptr == agent);
+    agent = parseSingleAgent(ONE_AGENT_GOOD_ONE_CAPABILITY_BAD_B_JSON);
+    ASSERT_TRUE(nullptr == agent);
+    agent = parseSingleAgent(ONE_AGENT_GOOD_ONE_CAPABILITY_BAD_C_JSON);
+    ASSERT_TRUE(nullptr == agent);
+    agent = parseSingleAgent(ONE_AGENT_GOOD_ONE_CAPABILITY_BAD_D_JSON);
+    ASSERT_TRUE(nullptr == agent);
+    agent = parseSingleAgent(ONE_AGENT_GOOD_ONE_CAPABILITY_BAD_E_JSON);
+    ASSERT_TRUE(nullptr == agent);
+    agent = parseSingleAgent(ONE_AGENT_GOOD_ONE_CAPABILITY_BAD_F_JSON);
+    ASSERT_TRUE(nullptr == agent);
+    agent = parseSingleAgent(ONE_AGENT_GOOD_ONE_CAPABILITY_BAD_G_JSON);
+    ASSERT_TRUE(nullptr == agent);
+}
+
+TEST(ConfigParserTest, test_parseGoodAgentOneCapabilityLimitedFields) {
+    auto agent = parseSingleAgent(ONE_AGENT_GOOD_ONE_CAPABILITY_EVENTS_ONLY_JSON);
+    ASSERT_TRUE(nullptr != agent);
+    agent = parseSingleAgent(ONE_AGENT_GOOD_ONE_CAPABILITY_DIRECTIVES_ONLY_JSON);
+    ASSERT_TRUE(nullptr != agent);
+}
+
+TEST(ConfigParserTest, test_parseGoodAgentAllCapabilities) {
+    auto agent = parseSingleAgent(ONE_AGENT_GOOD_ALL_CAPABILITIES_JSON);
+    ASSERT_TRUE(nullptr != agent);
+}
+
+TEST(ConfigParserTest, test_parseGoodAgentAllCapabilitiesNoServiceURL) {
+    auto agent = parseSingleAgent(ONE_AGENT_GOOD_ALL_CAPABILITIES_NO_SERVICE_URL_JSON);
+    ASSERT_TRUE(nullptr != agent);
+}
+
+TEST(ConfigParserTest, test_parseGoodAgentsAllCapabilities) {
+    ASSERT_TRUE(parseMultipleAgents(TWO_AGENTS_GOOD_ALL_CAPABILITIES_JSON));
+}
+
+TEST(ConfigParserTest, test_parseBadAgentNoId) {
+    auto agent = parseSingleAgent(ONE_AGENT_BAD_NO_ID_JSON);
+    ASSERT_TRUE(nullptr == agent);
+}
+
+TEST(ConfigParserTest, test_parseBadAgentNoName) {
+    auto agent = parseSingleAgent(ONE_AGENT_BAD_NO_NAME_JSON);
+    ASSERT_TRUE(nullptr == agent);
+}
+
+TEST(ConfigParserTest, test_parseBadAgentNoServiceConfig) {
+    auto agent = parseSingleAgent(ONE_AGENT_BAD_NO_SERVICE_CONFIG_JSON);
+    ASSERT_TRUE(nullptr == agent);
+}
+
+TEST(ConfigParserTest, test_parseGoodAgentNoAuthConfig) {
+    auto agent = parseSingleAgent(ONE_AGENT_GOOD_NO_AUTH_CONFIG_JSON);
+    ASSERT_TRUE(nullptr != agent);
+}
+
+TEST(ConfigParserTest, test_parseBadAgentNoCapabilitiesConfig) {
+    auto agent = parseSingleAgent(ONE_AGENT_BAD_NO_CAPABILITIES_JSON);
+    ASSERT_TRUE(nullptr == agent);
+}
+
+TEST(ConfigParserTest, test_parseBadAgentEmptyCapabilitiesConfig) {
+    auto agent = parseSingleAgent(ONE_AGENT_BAD_EMPTY_CAPABILITIES_JSON);
+    ASSERT_TRUE(nullptr == agent);
+}
+
+TEST(ConfigParserTest, test_parseBadAgentNoLocalesConfig) {
+    auto agent = parseSingleAgent(ONE_AGENT_BAD_NO_LOCALES_JSON);
+    ASSERT_TRUE(nullptr == agent);
+}
+
+}  // namespace test
+}  // namespace agent
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    return RUN_ALL_TESTS();
+}
diff --git a/core/MultiAgent/MultiAgent/test/LocaleTest.cpp b/core/MultiAgent/MultiAgent/test/LocaleTest.cpp
new file mode 100644
index 00000000..42c312c8
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/test/LocaleTest.cpp
@@ -0,0 +1,117 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <acsdk/MultiAgent/Agent/Locale.h>
+#include <gtest/gtest.h>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace agent {
+namespace test {
+
+/**
+ * Utility function to confirm two sets of strings contain the same values.
+ *
+ * @param set1 The first set of strings.
+ * @param set2 The second set of strings.
+ * @return Whether both sets contain the same values.
+ */
+static bool confirmStringSetsSame(const std::set<std::string>& set1, const std::set<std::string>& set2) {
+    if (set1.size() != set2.size()) {
+        return false;
+    }
+
+    for (const auto& str : set1) {
+        if (set2.find(str) == set2.end()) {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+TEST(LocaleTest, test_normalConstruction) {
+    std::string testName = "testLocaleName";
+    std::set<std::string> testWakeWords{"ww1", "ww2", "ww3"};
+    Locale locale(testName, testWakeWords);
+
+    // test the name is correctly set.
+    ASSERT_EQ(testName, locale.getName());
+
+    // test wake words are found.
+    auto wakeWords = locale.getAllWakeWords();
+    ASSERT_EQ(testWakeWords.size(), wakeWords.size());
+    ASSERT_TRUE(confirmStringSetsSame(testWakeWords, wakeWords));
+
+    // test that no ww is active by default.
+    auto activeWakeWords = locale.getActiveWakeWords();
+    ASSERT_EQ(0, static_cast<int>(activeWakeWords.size()));
+}
+
+TEST(LocaleTest, test_normalConstructionEmptyWakWordString) {
+    std::string testName = "testLocaleName";
+    std::set<std::string> testWakeWords{""};
+    Locale locale(testName, testWakeWords);
+
+    // test no wake words are found.
+    auto wakeWords = locale.getAllWakeWords();
+    ASSERT_EQ(0, static_cast<int>(wakeWords.size()));
+}
+
+TEST(LocaleTest, test_setActiveWakeWords) {
+    std::string testName = "testLocaleName";
+    std::set<std::string> testWakeWords{"ww1", "ww2", "ww3"};
+    std::set<std::string> testActiveWakeWordsGood{"ww1", "ww2"};
+    std::set<std::string> testActiveWakeWordsBad{"ww4", "ww5", "ww6"};
+
+    // test that setting good wake words works, and does not affect set of all
+    // wake words in the locale
+    Locale locale(testName, testWakeWords);
+    locale.setActiveWakeWords(testActiveWakeWordsGood);
+    auto activeWakeWords = locale.getActiveWakeWords();
+    ASSERT_EQ(testActiveWakeWordsGood.size(), activeWakeWords.size());
+    ASSERT_TRUE(confirmStringSetsSame(testActiveWakeWordsGood, activeWakeWords));
+    ASSERT_EQ(testWakeWords.size(), locale.getAllWakeWords().size());
+
+    // test that setting bad wake words fails, and does not affect set of all wake
+    // words in the locale
+    Locale locale2(testName, testWakeWords);
+    locale.setActiveWakeWords(testActiveWakeWordsBad);
+    ASSERT_EQ(0, static_cast<int>(locale2.getActiveWakeWords().size()));
+    ASSERT_EQ(testWakeWords.size(), locale2.getAllWakeWords().size());
+
+    // test enabling & disabling individual wake words
+    Locale locale3(testName, testWakeWords);
+    locale3.setActiveWakeWords(std::set<std::string>{"ww1", "ww2"});
+    ASSERT_EQ(2, static_cast<int>(locale3.getActiveWakeWords().size()));
+    locale3.setActiveWakeWords(std::set<std::string>{"ww1"});
+    ASSERT_EQ(1, static_cast<int>(locale3.getActiveWakeWords().size()));
+    locale3.setActiveWakeWords(std::set<std::string>());
+    ASSERT_EQ(0, static_cast<int>(locale3.getActiveWakeWords().size()));
+    locale3.setActiveWakeWords(std::set<std::string>{"ww3"});
+    ASSERT_EQ(1, static_cast<int>(locale3.getActiveWakeWords().size()));
+    locale3.setActiveWakeWords(std::set<std::string>{"ww1", "ww2"});
+    ASSERT_EQ(2, static_cast<int>(locale3.getActiveWakeWords().size()));
+}
+
+}  // namespace test
+}  // namespace agent
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    return RUN_ALL_TESTS();
+}
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgent/test/include/acsdk/MultiAgent/test/AgentConfigStrings.h b/core/MultiAgent/MultiAgent/test/include/acsdk/MultiAgent/test/AgentConfigStrings.h
new file mode 100644
index 00000000..873b8044
--- /dev/null
+++ b/core/MultiAgent/MultiAgent/test/include/acsdk/MultiAgent/test/AgentConfigStrings.h
@@ -0,0 +1,646 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENT_TEST_AGENTCONFIGSTRINGS_H_
+#define ACSDK_MULTIAGENT_TEST_AGENTCONFIGSTRINGS_H_
+
+#include <string>
+
+namespace alexaClientSDK {
+namespace multiAgent {
+namespace agent {
+namespace test {
+
+std::string ONE_AGENT_GOOD_ONE_CAPABILITY_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "SpeechRecognizer",
+                  "minimumInterfaceVersion" : "3.2",
+                  "events" : [ "Recognize" ],
+                  "directives" : [ "ExpectSpeech", "StopCapture" ]
+                }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_GOOD_ONE_CAPABILITY_BAD_A_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "SpeechRecognizer",
+                  "events" : [ "Recognize" ],
+                  "directives" : [ "ExpectSpeech", "StopCapture" ]
+                }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_GOOD_ONE_CAPABILITY_BAD_B_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "SpeechRecognizer",
+                  "minimumInterfaceVersion" : "3",
+                  "events" : [ "Recognize" ],
+                  "directives" : [ "ExpectSpeech", "StopCapture" ]
+                }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_GOOD_ONE_CAPABILITY_BAD_C_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "SpeechRecognizer",
+                  "minimumInterfaceVersion" : ".2",
+                  "events" : [ "Recognize" ],
+                  "directives" : [ "ExpectSpeech", "StopCapture" ]
+                }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_GOOD_ONE_CAPABILITY_BAD_D_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "SpeechRecognizer",
+                  "minimumInterfaceVersion" : ".2",
+                  "events" : [ "Recognize" ],
+                  "directives" : [ "ExpectSpeech", "StopCapture" ]
+                }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_GOOD_ONE_CAPABILITY_BAD_E_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "SpeechRecognizer",
+                  "minimumInterfaceVersion" : ".",
+                  "events" : [ "Recognize" ],
+                  "directives" : [ "ExpectSpeech", "StopCapture" ]
+                }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_GOOD_ONE_CAPABILITY_BAD_F_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "SpeechRecognizer",
+                  "minimumInterfaceVersion" : "1.2.3",
+                  "events" : [ "Recognize" ],
+                  "directives" : [ "ExpectSpeech", "StopCapture" ]
+                }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_GOOD_ONE_CAPABILITY_BAD_G_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "SpeechRecognizer",
+                  "minimumInterfaceVersion" : "happy.frog",
+                  "events" : [ "Recognize" ],
+                  "directives" : [ "ExpectSpeech", "StopCapture" ]
+                }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_GOOD_ALL_CAPABILITIES_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "*" }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_GOOD_ALL_CAPABILITIES_NO_SERVICE_URL_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "*" }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string TWO_AGENTS_GOOD_ALL_CAPABILITIES_JSON = R"(
+{
+    "agents": [
+
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "*" }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        },
+
+        {
+            "id" : 3,
+            "name" : "Bob",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://bob.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "*" }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Bob" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_BAD_NO_ID_JSON = R"(
+{
+    "agents": [
+        {
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "*" }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_BAD_NO_NAME_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "*" }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_BAD_NO_SERVICE_CONFIG_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "*" }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_GOOD_NO_AUTH_CONFIG_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "*" }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_BAD_NO_CAPABILITIES_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_BAD_EMPTY_CAPABILITIES_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [ ]
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_BAD_NO_LOCALES_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "*" }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_GOOD_TWO_CAPABILITIES_JSON = R"(
+{
+
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "SpeechSynthesizer",
+                  "minimumInterfaceVersion" : "1.2",
+                  "events" : [ "SpeechStarted", "SpeechFinished" ],
+                  "directives" : [ "Speak" ]
+                },
+                { "interfaceName" : "SpeechRecognizer",
+                  "minimumInterfaceVersion" : "3.0",
+                  "events" : [ "Recognize" ],
+                  "directives" : [ "ExpectSpeech", "StopCapture" ]
+                }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_GOOD_ONE_CAPABILITY_EVENTS_ONLY_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "SpeechSynthesizer",
+                  "minimumInterfaceVersion" : "1.2",
+                  "events" : [ "SpeechStarted", "SpeechFinished" ]
+                }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+std::string ONE_AGENT_GOOD_ONE_CAPABILITY_DIRECTIVES_ONLY_JSON = R"(
+{
+    "agents": [
+        {
+            "id" : 2,
+            "name" : "Alexa",
+            "serviceConfiguration" : {
+                "protocol" : "AVS",
+                "baseURL" : "https://alexa.na.gateway.devices.a2z.com"
+            },
+            "authorizationConfiguration" : {
+                "protocol" : "OAUTH2",
+                "baseURL" : "https://api.amazon.com/auth/o2/"
+            },
+            "avsInterfaces" : [
+                { "interfaceName" : "SpeechSynthesizer",
+                  "minimumInterfaceVersion" : "1.2",
+                  "directives" : [ "Speak" ]
+                }
+            ],
+            "locales" : [
+                {   "locale" : "en-US",
+                    "wakeWords" : [ "Alexa", "Amazon", "Computer", "Ziggy" ]
+                }
+            ]
+        }
+    ]
+}
+)";
+
+}  // namespace test
+}  // namespace agent
+}  // namespace multiAgent
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENT_TEST_AGENTCONFIGSTRINGS_H_
diff --git a/core/MultiAgent/MultiAgentInterface/.clang-format b/core/MultiAgent/MultiAgentInterface/.clang-format
new file mode 100644
index 00000000..5752e40b
--- /dev/null
+++ b/core/MultiAgent/MultiAgentInterface/.clang-format
@@ -0,0 +1,102 @@
+---
+Language:        Cpp
+BasedOnStyle:  Google
+AccessModifierOffset: -4
+AlignAfterOpenBracket: AlwaysBreak
+#AlignConsecutiveAssignments: false
+#AlignConsecutiveDeclarations: false
+#AlignEscapedNewlines: Left
+#AlignOperands:   true
+#AlignTrailingComments: true
+AllowAllParametersOfDeclarationOnNextLine: false
+#AllowShortBlocksOnASingleLine: false
+#AllowShortCaseLabelsOnASingleLine: false
+AllowShortFunctionsOnASingleLine: None
+#AllowShortIfStatementsOnASingleLine: true
+#AllowShortLoopsOnASingleLine: true
+#AlwaysBreakAfterDefinitionReturnType: None
+#AlwaysBreakAfterReturnType: None
+#AlwaysBreakBeforeMultilineStrings: true
+#AlwaysBreakTemplateDeclarations: true
+BinPackArguments: false
+BinPackParameters: false
+#BraceWrapping:   
+#  AfterClass:      false
+#  AfterControlStatement: false
+#  AfterEnum:       false
+#  AfterFunction:   false
+#  AfterNamespace:  false
+#  AfterObjCDeclaration: false
+#  AfterStruct:     false
+#  AfterUnion:      false
+#  BeforeCatch:     false
+#  BeforeElse:      false
+#  IndentBraces:    false
+#  SplitEmptyFunctionBody: true
+#BreakBeforeBinaryOperators: None
+#BreakBeforeBraces: Attach
+BreakBeforeInheritanceComma: true
+#BreakBeforeTernaryOperators: true
+#BreakConstructorInitializersBeforeComma: false
+BreakConstructorInitializers: AfterColon
+#BreakAfterJavaFieldAnnotations: false
+#BreakStringLiterals: true
+ColumnLimit:     120
+#CommentPragmas:  '^ IWYU pragma:'
+#CompactNamespaces: false
+#ConstructorInitializerAllOnOneLineOrOnePerLine: true
+ConstructorInitializerIndentWidth: 8
+#ContinuationIndentWidth: 4
+#Cpp11BracedListStyle: true
+DerivePointerAlignment: false
+#DisableFormat:   false
+#ExperimentalAutoDetectBinPacking: false
+#FixNamespaceComments: true
+#ForEachMacros:   [ foreach, Q_FOREACH, BOOST_FOREACH ]
+#IncludeCategories: 
+#  - Regex:           '^<.*\.h>'
+#    Priority:        1
+#  - Regex:           '^<.*'
+#    Priority:        2
+#  - Regex:           '.*'
+#    Priority:        3
+#IncludeIsMainRegex: '([-_](test|unittest))?$'
+#IndentCaseLabels: true
+IndentWidth:     4
+#IndentWrappedFunctionNames: false
+#JavaScriptQuotes: Leave
+#JavaScriptWrapImports: true
+#KeepEmptyLinesAtTheStartOfBlocks: false
+#MacroBlockBegin: ''
+#MacroBlockEnd:   ''
+#MaxEmptyLinesToKeep: 1
+#NamespaceIndentation: None
+#ObjCBlockIndentWidth: 2
+#ObjCSpaceAfterProperty: false
+#ObjCSpaceBeforeProtocolList: false
+#PenaltyBreakAssignment: 2
+#PenaltyBreakBeforeFirstCallParameter: 1
+#PenaltyBreakComment: 300
+#PenaltyBreakFirstLessLess: 120
+#PenaltyBreakString: 1000
+#PenaltyExcessCharacter: 1000000
+PenaltyReturnTypeOnItsOwnLine: 20000
+#PointerAlignment: Left
+#ReflowComments:  true
+SortIncludes:    false
+#SpaceAfterCStyleCast: false
+#SpaceAfterTemplateKeyword: true
+#SpaceBeforeAssignmentOperators: true
+#SpaceBeforeParens: ControlStatements
+#SpaceInEmptyParentheses: false
+#SpacesBeforeTrailingComments: 2
+#SpacesInAngles:  false
+#SpacesInContainerLiterals: true
+#SpacesInCStyleCastParentheses: false
+#SpacesInParentheses: false
+#SpacesInSquareBrackets: false
+#Standard:        Auto
+#TabWidth:        8
+#UseTab:          Never
+...
+
diff --git a/core/MultiAgent/MultiAgentInterface/CMakeLists.txt b/core/MultiAgent/MultiAgentInterface/CMakeLists.txt
new file mode 100644
index 00000000..ea600d87
--- /dev/null
+++ b/core/MultiAgent/MultiAgentInterface/CMakeLists.txt
@@ -0,0 +1,13 @@
+cmake_minimum_required(VERSION 3.0)
+project(MultiAgentInterface LANGUAGES CXX)
+
+include(${AVS_CMAKE_BUILD}/BuildDefaults.cmake)
+
+add_library(MultiAgentInterface INTERFACE)
+
+target_include_directories(MultiAgentInterface INTERFACE include)
+
+add_subdirectory("test")
+
+# install interface
+asdk_install_interface()
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Agent/LocaleInterface.h b/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Agent/LocaleInterface.h
new file mode 100644
index 00000000..2c1156e6
--- /dev/null
+++ b/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Agent/LocaleInterface.h
@@ -0,0 +1,99 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENTINTERFACE_AGENT_LOCALEINTERFACE_H_
+#define ACSDK_MULTIAGENTINTERFACE_AGENT_LOCALEINTERFACE_H_
+
+#include <set>
+#include <string>
+
+namespace alexaClientSDK {
+namespace multiAgentInterface {
+namespace agent {
+
+/**
+ * A locale expresses a language which an agent understands, and the associated wake works which the agent will
+ * recognize as a potential named invocation of a dialog within that locale. In particular, if a wake word is made
+ * active within a locale, then we expect that a device will activate this wake word in its wake word engine detection,
+ * thus allowing a customer to invoke the agent by voice.
+ *
+ * Locales support the possibility of no wake words, which allows for agents which may only be invoked by a device
+ * gesture such as tap-to-talk. In this case, the locale indicates a language that the customer expects the agent to
+ * understand and also respond in by voice.
+ *
+ * Locales also support the possibility of multiple concurrently enabled wake words within the locale, which is
+ * intuitive if we consider agents are modeled on real people; many people have multiple nicknames; as another example,
+ * a superhero agent would have both a civilian and hero name.
+ *
+ * We assume duplication of values across locales, for example 'Alexa' is the same wake word in US and Canadian English,
+ * however the locales have material differences to the user in terms of language accent and grammar conventions. This
+ * class does not attempt to optimize towards this point. Usage of this class expects this redundancy.
+ *
+ * A locale is an agent-centric notion, rather than device-centric. A device with a wake word engine, which may detect
+ * wake words, is expected to recognize the superset of wake words as expressed in the enabled locales of all enabled
+ * agents that are available to a customer on a device at any given time.
+ */
+class LocaleInterface {
+public:
+    /**
+     * Destructor.
+     */
+    virtual ~LocaleInterface() = default;
+
+    /**
+     * Sets the wake words which may be used to invoke an agent by voice in this locale. The provided wake words must be
+     * a subset within the initial provided set. Providing the empty set disables all wake words in the locale.
+     *
+     * @param wakeWords The wake words to be set as active, which must be a strict subset of the wake words used to
+     * initialize an object of this type.
+     * @return whether the active wake words were successfully updated.
+     */
+    virtual bool setActiveWakeWords(const std::set<std::string>& wakeWords) = 0;
+
+    /**
+     * Returns the name of the locale.
+     *
+     * @return The name of the locale.
+     */
+    virtual std::string getName() const = 0;
+
+    /**
+     * Returns all wake words within the locale which may be activated.
+     *
+     * @return All wake words within the locale which may be activated.
+     */
+    virtual std::set<std::string> getAllWakeWords() const = 0;
+
+    /**
+     * Returns all currently active wake words.
+     *
+     * @return All currently active wake words.
+     */
+    virtual std::set<std::string> getActiveWakeWords() const = 0;
+
+    /**
+     * The less-than operator, allowing management by STL containers.
+     *
+     * @param rhs The object to which this object should be compared.
+     * @return Whether this object is semantically less than the object being compared.
+     */
+    virtual bool operator<(const LocaleInterface& rhs) const = 0;
+};
+
+}  // namespace agent
+}  // namespace multiAgentInterface
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENTINTERFACE_AGENT_LOCALEINTERFACE_H_
diff --git a/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/AgentManagerInterface.h b/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/AgentManagerInterface.h
new file mode 100644
index 00000000..e375f870
--- /dev/null
+++ b/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/AgentManagerInterface.h
@@ -0,0 +1,334 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENTINTERFACE_AGENTMANAGERINTERFACE_H_
+#define ACSDK_MULTIAGENTINTERFACE_AGENTMANAGERINTERFACE_H_
+
+#include "Agent/LocaleInterface.h"
+#include "Connection/AgentConnectionManagerInterface.h"
+#include "Observer/AgentEnablementObserverInterface.h"
+#include "Observer/AgentGestureObserverInterface.h"
+#include "Observer/AgentLocaleObserverInterface.h"
+
+#include <AVSCommon/AVS/AgentId.h>
+#include <AVSCommon/AVS/AgentInitiator.h>
+
+#include <memory>
+#include <set>
+#include <string>
+
+namespace alexaClientSDK {
+namespace multiAgentInterface {
+
+/**
+ * This Interface provides the means for configuration of, and interaction with, all AVS-conformant agents as handled by
+ * the AVS SDK. The term 'AVS-conformant' means that 1) the agent is powered by a service which communicates via the AVS
+ * protocol, and 2) the AVS SDK manages connections to those agent services, and renders activities on behalf of those
+ * agent services. We may think in this case that the AVS SDK is multi-agent aware, with this class presenting concrete
+ * expression of agents as first-class objects, Alexa now being one of them.
+ *
+ * An agent is described by an 'Agent Configuration' which is a device-independent way of describing an Agent's
+ * characteristics, including such things as supported locales, supported wake words within those locales, supported AVS
+ * Interfaces, as well as other essential concerns such as the agent's service characteristics such as protocol and URL,
+ * and similarly for authorization.
+ *
+ * The AgentManager instantiates agents as described in an input JSON configuration stream, and then takes care of
+ * device-side concerns such as assigned gesture (eg. tap-to-talk button) to a given agent for its possible invocation.
+ *
+ * The AgentManager should be used for agent disambiguation and query of metadata, with the @c
+ * avsCommon::AgentId::IdType serving as an opaque handle guaranteed to be unique across all agents. There is no
+ * guarantee that any other agent metadata (such as agent names or wake words) should be unique as far as AgentManager
+ * is concerned; this aligns with the expectation that different agents, developed at different times and independently,
+ * may each happen to choose the same name or wake word, or other characteristic, and we expect in this case that the
+ * customer of the agents will choose which of the agents with the same name they wish to enable at a given point in
+ * time. This does not preclude AgentManager allowing multiple such agents to exist.
+ */
+class AgentManagerInterface {
+public:
+    /**
+     * Destructor.
+     */
+    virtual ~AgentManagerInterface() = default;
+
+    /**
+     * Returns the @c avsCommon::AgentId::IdType for all currently managed agents.
+     * @return The @c avsCommon::AgentId::IdType for all currently managed agents.
+     */
+    virtual std::set<avsCommon::avs::AgentId::IdType> getAllAgentIds() = 0;
+
+    /**
+     * Returns the name of the agent associated with the given @c avsCommon::AgentId::IdType. If there is no such agent,
+     * the empty string is returned.
+     *
+     * @param id The agent Id for which we seek the associated agent name.
+     * @return The name of the agent associated with the given agent Id. If there
+     * is no such agent, the empty string is returned.
+     */
+    virtual std::string getAgentName(avsCommon::avs::AgentId::IdType id) = 0;
+
+    /**
+     * Provides the agent Ids which may handle the AVS namespace & name pair as provided as parameters. This API allows
+     * varying levels of resolution, such as query of Interface only, Interface and name, or Interface, name and
+     * version. Querying for Interface only will return the agent ids which may handle any messages within that
+     * namespace, however this does not imply that all messages are supported by those agents. For specific message
+     * support, the API must be called with the namespace and name pair.
+     *
+     * The version is expected to follow Semantic Versioning, defined as a MAJOR.MINOR integer pair, similar to the
+     * definition provided at https://semver.org/.
+     *
+     * @param avsNamespace The AVS Interface being queried.
+     * @param avsName The AVS message within the Interface being queried. If not provided, or if the parameter is '*',
+     * this API will query for all agents which may support any message within the provided Interface.
+     * @param version The semantic version of the Interface which agents must support.
+     * @return The collection of agent Ids which may handle the Interface or message being queried.
+     */
+    virtual std::set<avsCommon::avs::AgentId::IdType> getAVSInterfaceEnabledAgentIds(
+        const std::string& avsNamespace,
+        const std::string& avsName = "",
+        const std::pair<int, int>& version = std::pair<int, int>{0, 0}) = 0;
+
+    /**
+     * Returns the possible @c Locales for the given agent id.
+     *
+     * @param id The id of the agent being queried.
+     * @return The possible @c Locales associated with the given agent id.
+     */
+    virtual std::set<std::shared_ptr<agent::LocaleInterface>> getAgentLocales(avsCommon::avs::AgentId::IdType id) = 0;
+
+    /**
+     * Returns the active @c Locales for the given agent id. An active @c Locale may not have active wake words, since
+     * an agent may still be invoked by gesture.
+     *
+     * @param id The id of the agent being queried.
+     * @return The active @c Locales associated with the given agent id.
+     */
+    virtual std::set<std::shared_ptr<agent::LocaleInterface>> getAgentActiveLocales(
+        avsCommon::avs::AgentId::IdType id) = 0;
+
+    /**
+     * Returns the assigned gestures for a given agent id.
+     *
+     * @param id The id for the agent being queried.
+     * @return The gestures assigned to the given agent.
+     */
+    virtual std::set<avsCommon::avs::AgentInitiator> getAgentGestures(avsCommon::avs::AgentId::IdType id) = 0;
+
+    /**
+     * Returns whether the given agent is enabled.
+     *
+     * @param id The id of the agent to be queried.
+     * @return Whether the agent is enabled.
+     */
+    virtual bool isAgentEnabled(avsCommon::avs::AgentId::IdType id) = 0;
+
+    /**
+     * Enables the given agent.
+     *
+     * @param id The id of the agent to be enabled.
+     * @return Whether the agent was successfully enabled.
+     */
+    virtual bool enableAgent(avsCommon::avs::AgentId::IdType id) = 0;
+
+    /**
+     * Disables the given agent.
+     *
+     * @param id The id of the agent to be disabled.
+     * @return Whether the agent was successfully disabled.
+     */
+    virtual bool disableAgent(avsCommon::avs::AgentId::IdType id) = 0;
+
+    /**
+     *
+     * @param connectionManager
+     */
+    virtual void setAgentConnectionManager(
+        const std::shared_ptr<connection::AgentConnectionManagerInterface>& connectionManager) = 0;
+
+    /**
+     * Sets the service baseURL for a given agent. If the baseURL is the empty string, it is assumed that the agent is
+     * locally known to the device, and is therefore considered a valid parameter.
+     *
+     * @param id The id of the agent for which the baseURL should be set.
+     * @param baseURL The URL to use.
+     */
+    virtual bool setBaseURL(avsCommon::avs::AgentId::IdType id, const std::string& baseURL) = 0;
+
+    /**
+     * Sets the active locales for a given agent. The locales must contain at least one locale, since it is not
+     * meaningful for a voice agent to be unable to speak to the customer. The locales must also be a valid subset of
+     * the locales supported by the agent per the Agent Configuration.
+     *
+     * @param id The id of the agent which should be configured.
+     * @param localeNames The names of the locales which should be set.
+     */
+    virtual bool setActiveLocales(avsCommon::avs::AgentId::IdType id, const std::set<std::string>& localeNames) = 0;
+
+    /**
+     * Sets the active wake words within a locale for a given agent. The locale must be active for this to take effect,
+     * and the wake words provided must be a valid subset of the wake words within the locale, as expressed in the Agent
+     * Configuration. An empty set of wake words is valid, for example should the customer disable the agent's wake
+     * words, however still wish to interact with the agent via gesture.
+     *
+     * @param id The id of the agent for which the wake words should be set.
+     * @param localeName The name of the locale for which the wake words should be set.
+     * @param wakeWords The wake words to enable for the locale.
+     * @return Whether the wake words were successfully set for the agent's locale.
+     */
+    virtual bool setActiveWakeWords(
+        avsCommon::avs::AgentId::IdType id,
+        const std::string& localeName,
+        const std::set<std::string>& wakeWords) = 0;
+
+    /**
+     * Sets a gesture for a given agent. This is a device-side detail, and so does not have any dependencies on an
+     * agent's Agent Configuration. To un-assign a gesture, use the value @c avsCommon::avs::AgentId::AGENT_ID_NONE with
+     * a particular gesture.
+     *
+     * @param id The Agent id which should be assigned to a given gesture.
+     * @param gesture The gesture which should be assigned.
+     * @return whether the gesture was successfully assigned.
+     */
+    virtual bool setAgentGesture(avsCommon::avs::AgentId::IdType id, avsCommon::avs::AgentInitiator gesture) = 0;
+
+    /**
+     * Resolves which gesture is assigned to a particular agent id.
+     *
+     * @param gesture The gesture being queried.
+     * @return The agent id which is assigned to the gesture.
+     */
+    virtual avsCommon::avs::AgentId::IdType resolveGesture(avsCommon::avs::AgentInitiator gesture) = 0;
+
+    /**
+     * Resolves which wake word is assigned to a particular agent id.
+     *
+     * @param gesture The wake word being queried.
+     * @return The agent id which is assigned to the wake word.
+     */
+    virtual avsCommon::avs::AgentId::IdType resolveWakeWord(const std::string& wakeWord) = 0;
+
+    /**
+     * Adds a connection observer which should observe the given agent id. If the value @c
+     * avsCommon::avs::AgentId::AGENT_ID_ALL is provided, then the observer will be understood to observe all agents
+     * managed by this class.
+     *
+     * @param id The agent id to be observed.
+     * @param observer The observer.
+     */
+    virtual void addAgentConnectionObserverInterface(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<connection::AgentConnectionObserverInterface>& observer) = 0;
+
+    /**
+     * Removes a connection observer from observing the given agent id. If the value @c
+     * avsCommon::avs::AgentId::AGENT_ID_ALL is provided, then the observer will be understood to be removed from
+     * observing all agents managed by this class.
+     *
+     * @param id The agent id which should no longer be observed.
+     * @param observer The observer.
+     */
+    virtual void removeAgentConnectionObserverInterface(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<connection::AgentConnectionObserverInterface>& observer) = 0;
+
+    /**
+     * Adds an agent enablement observer which should observe the given agent id. If the value @c
+     * avsCommon::avs::AgentId::AGENT_ID_ALL is provided, then the observer will be understood to observe all agents
+     * managed by this class.
+     *
+     * @param id The agent id to be observed.
+     * @param observer The observer.
+     */
+    virtual void addAgentEnablementObserverInterface(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<observer::AgentEnablementObserverInterface>& observer) = 0;
+
+    /**
+     * Removes an enablement observer from observing the given agent id. If the value @c
+     * avsCommon::avs::AgentId::AGENT_ID_ALL is provided, then the observer will be understood to be removed from
+     * observing all agents managed by this class.
+     *
+     * @param id The agent id which should no longer be observed.
+     * @param observer The observer.
+     */
+    virtual void removeAgentEnablementObserverInterface(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<observer::AgentEnablementObserverInterface>& observer) = 0;
+
+    /**
+     * Adds a gesture observer which should observe the given agent id. If the value @c
+     * avsCommon::avs::AgentId::AGENT_ID_ALL is provided, then the observer will be understood to observe all agents
+     * managed by this class.
+     *
+     * @param id The agent id to be observed.
+     * @param observer The observer.
+     */
+    virtual void addAgentGestureObserverInterface(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<observer::AgentGestureObserverInterface>& observer) = 0;
+
+    /**
+     * Removes a gesture observer from observing the given agent id. If the value @c
+     * avsCommon::avs::AgentId::AGENT_ID_ALL is provided, then the observer will be understood to be removed from
+     * observing all agents managed by this class.
+     *
+     * @param id The agent id which should no longer be observed.
+     * @param observer The observer.
+     */
+    virtual void removeAgentGestureObserverInterface(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<observer::AgentGestureObserverInterface>& observer) = 0;
+
+    /**
+     * Adds a locale observer which should observe the given agent id. If the value @c
+     * avsCommon::avs::AgentId::AGENT_ID_ALL is provided, then the observer will be understood to observe all agents
+     * managed by this class.
+     *
+     * @param id The agent id to be observed.
+     * @param observer The observer.
+     */
+    virtual void addAgentLocaleObserverInterface(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<observer::AgentLocaleObserverInterface>& observer) = 0;
+
+    /**
+     * Removes a locale observer from observing the given agent id. If the value @c
+     * avsCommon::avs::AgentId::AGENT_ID_ALL is provided, then the observer will be understood to be removed from
+     * observing all agents managed by this class.
+     *
+     * @param id The agent id which should no longer be observed.
+     * @param observer The observer.
+     */
+    virtual void removeAgentLocaleObserverInterface(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<observer::AgentLocaleObserverInterface>& observer) = 0;
+
+    /**
+     * Utility function to print a given agent's details to std::cout.
+     *
+     * @param id The agent id of the agent to be printed.
+     */
+    virtual void printAgentDetails(avsCommon::avs::AgentId::IdType id) = 0;
+
+    /**
+     * This will remove all instantiated agent objects and data, ensuring correct and complete destruction given the
+     * inter-dependencies which may exist between objects internally. This should be called at application exit.
+     */
+    virtual void clearAgents() = 0;
+};
+
+}  // namespace multiAgentInterface
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENTINTERFACE_AGENTMANAGERINTERFACE_H_
diff --git a/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Connection/AgentConnectionManagerInterface.h b/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Connection/AgentConnectionManagerInterface.h
new file mode 100644
index 00000000..fa92ceac
--- /dev/null
+++ b/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Connection/AgentConnectionManagerInterface.h
@@ -0,0 +1,99 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENTINTERFACE_CONNECTION_AGENTCONNECTIONMANAGERINTERFACE_H_
+#define ACSDK_MULTIAGENTINTERFACE_CONNECTION_AGENTCONNECTIONMANAGERINTERFACE_H_
+
+#include "AgentConnectionObserverInterface.h"
+
+#include <AVSCommon/AVS/AgentId.h>
+
+#include <memory>
+#include <string>
+
+namespace alexaClientSDK {
+namespace multiAgentInterface {
+namespace connection {
+
+/**
+ * This Interface defines how an AVS-conformant agent service shall be connected to and managed from an agent management
+ * point of view. Connections to such agent services are expressed in terms of connectivity to a given gateway URL, and
+ * whether the agent is thereby to be considered available to the customer at any point in time.
+ *
+ * Agents are identified by their agent id.
+ *
+ * Agent availability is expressed via the @c AgentConnectionObserverInterface, which implementations of this Interface
+ * shall notify as connections to the agent service are established, maintained and closed.
+ */
+class AgentConnectionManagerInterface {
+public:
+    /**
+     * Destructor.
+     */
+    virtual ~AgentConnectionManagerInterface() = default;
+
+    /**
+     * Allows the URL of the AVS-conformant agent, as identified by its id, to be modified. If the empty string is
+     * provided, then any connection to a previously configured agent service URL is expected to be closed.
+     *
+     * @param id The id of the agent to be configured.
+     * @param avsGateway The URL to be used for the agent service. If the empty string is provided, then it is assumed
+     * that the agent service may be local to the device instead, at the discretion of the implementation of this
+     * Interface.
+     * @param agentName The name of the agent, to be used primarily for debugging purposes.
+     * @return Whether the agent was successfully configured.
+     */
+    virtual bool configureAgent(
+        avsCommon::avs::AgentId::IdType id,
+        const std::string& avsGateway,
+        const std::string& agentName) = 0;
+
+    /**
+     * Remove an agent from the set of managed agent connections. If the agent service with respect to the id is
+     * currently active, then its connection will be closed.
+     *
+     * @param id The id of the agent to remove.
+     */
+    virtual void removeAgent(avsCommon::avs::AgentId::IdType id) = 0;
+
+    /**
+     * Adds an observer for the given agent id. The observer will be provided an immediate notification of the agent's
+     * connection status, and then notified upon any subsequent change to the connection. connection. If the id
+     * avsCommon::avs::AgentId::AGENT_ID_ALL is provided, then the observer is understood to observe all agents which
+     * are managed.
+     *
+     * @param id The agent to observe.
+     * @param observer The observer.
+     */
+    virtual void addObserver(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<AgentConnectionObserverInterface>& observer) = 0;
+
+    /**
+     * Removes a connection observer for a particular agent.
+     *
+     * @param id The id of the agent being observed.
+     * @param observer The observer to remove.
+     */
+    virtual void removeObserver(
+        avsCommon::avs::AgentId::IdType id,
+        const std::shared_ptr<AgentConnectionObserverInterface>& observer) = 0;
+};
+
+}  // namespace connection
+}  // namespace multiAgentInterface
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENTINTERFACE_CONNECTION_AGENTCONNECTIONMANAGERINTERFACE_H_
diff --git a/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Connection/AgentConnectionObserverInterface.h b/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Connection/AgentConnectionObserverInterface.h
new file mode 100644
index 00000000..fdcdc70e
--- /dev/null
+++ b/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Connection/AgentConnectionObserverInterface.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENTINTERFACE_CONNECTION_AGENTCONNECTIONOBSERVERINTERFACE_H_
+#define ACSDK_MULTIAGENTINTERFACE_CONNECTION_AGENTCONNECTIONOBSERVERINTERFACE_H_
+
+#include <AVSCommon/AVS/AgentId.h>
+
+#include <string>
+
+namespace alexaClientSDK {
+namespace multiAgentInterface {
+namespace connection {
+
+/**
+ * This Interface provides the ability to observe the connection status of an agent service, expressed in terms of
+ * availability. For lower-level details of connection state, such as HTTP/2 headers and response codes, underlying
+ * libraries and logs should be inspected.
+ *
+ * Availability of an agent does not strictly require connection to an external cloud service, since some agents provide
+ * local processing of audio data, and text-to-speech responses, and so from a customer point of view the agent appears
+ * available in this case. So, our definition of agent availability is based upon the notion that a customer may
+ * interact by voice with the agent. It is at the discretion of each agent service, whether local or remote, and an
+ * implementation's ability to connect to either or both, to determine what satisfies our definition here of
+ * 'availability', thus simplifying implementation of the observers.
+ */
+class AgentConnectionObserverInterface {
+public:
+    /**
+     * An enum expressing an agent's availability.
+     */
+    enum class AvailabilityState {
+        /// The agent is available for voice interaction with the customer.
+        AVAILABLE,
+        /// The agent is not available for voice interaction with the customer.
+        UNAVAILABLE
+    };
+
+    /**
+     * Destructor.
+     */
+    virtual ~AgentConnectionObserverInterface() = default;
+
+    /**
+     * A notification that the agent's availability state has changed.
+     *
+     * @param id The id of the agent whose availability has changed.
+     * @param status The status reflecting the current availability of the agent.
+     * @param reason A reason for the change, provided for potential aid during debugging.
+     */
+    virtual void onAgentAvailabilityStateChanged(
+        avsCommon::avs::AgentId::IdType id,
+        AvailabilityState status,
+        const std::string& reason) = 0;
+};
+
+}  // namespace connection
+}  // namespace multiAgentInterface
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENTINTERFACE_CONNECTION_AGENTCONNECTIONOBSERVERINTERFACE_H_
diff --git a/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Observer/AgentEnablementObserverInterface.h b/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Observer/AgentEnablementObserverInterface.h
new file mode 100644
index 00000000..23796efe
--- /dev/null
+++ b/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Observer/AgentEnablementObserverInterface.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENTINTERFACE_OBSERVER_AGENTENABLEMENTOBSERVERINTERFACE_H_
+#define ACSDK_MULTIAGENTINTERFACE_OBSERVER_AGENTENABLEMENTOBSERVERINTERFACE_H_
+
+#include <AVSCommon/AVS/AgentId.h>
+
+namespace alexaClientSDK {
+namespace multiAgentInterface {
+namespace observer {
+
+/**
+ * An Interface allowing a component to be informed of the enablement state changes of a given agent.
+ */
+class AgentEnablementObserverInterface {
+public:
+    /**
+     * Destructor.
+     */
+    virtual ~AgentEnablementObserverInterface() = default;
+
+    /**
+     * Notification that the agent represented by its id has been enabled.
+     *
+     * @param id The id of the agent which has been enabled.
+     */
+    virtual void onEnabled(avsCommon::avs::AgentId::IdType id) = 0;
+
+    /**
+     * Notification that the agent represented by its id has been disabled.
+     *
+     * @param id The id of the agent which has been disabled.
+     */
+    virtual void onDisabled(avsCommon::avs::AgentId::IdType id) = 0;
+};
+
+}  // namespace observer
+}  // namespace multiAgentInterface
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENTINTERFACE_OBSERVER_AGENTENABLEMENTOBSERVERINTERFACE_H_
diff --git a/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Observer/AgentGestureObserverInterface.h b/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Observer/AgentGestureObserverInterface.h
new file mode 100644
index 00000000..f1784e3e
--- /dev/null
+++ b/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Observer/AgentGestureObserverInterface.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENTINTERFACE_OBSERVER_AGENTGESTUREOBSERVERINTERFACE_H_
+#define ACSDK_MULTIAGENTINTERFACE_OBSERVER_AGENTGESTUREOBSERVERINTERFACE_H_
+
+#include "AVSCommon/AVS/AgentInitiator.h"
+#include <AVSCommon/AVS/AgentId.h>
+
+#include <set>
+
+namespace alexaClientSDK {
+namespace multiAgentInterface {
+namespace observer {
+
+/**
+ * An Interface allowing a component to be informed of changes of the assigned gesture for a given agent.
+ */
+class AgentGestureObserverInterface {
+public:
+    /**
+     * Destructor.
+     */
+    virtual ~AgentGestureObserverInterface() = default;
+
+    /**
+     * Notification that the agent represented by its id has an updated set of gestures for potential invocation.
+     *
+     * @param id The agent whose gestures have been modified.
+     * @param gestures The current set of gestures which may now invoke the agent.
+     */
+    virtual void onGesturesChanged(
+        avsCommon::avs::AgentId::IdType id,
+        const std::set<avsCommon::avs::AgentInitiator>& gestures) = 0;
+};
+
+}  // namespace observer
+}  // namespace multiAgentInterface
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENTINTERFACE_OBSERVER_AGENTGESTUREOBSERVERINTERFACE_H_
diff --git a/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Observer/AgentLocaleObserverInterface.h b/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Observer/AgentLocaleObserverInterface.h
new file mode 100644
index 00000000..177ca714
--- /dev/null
+++ b/core/MultiAgent/MultiAgentInterface/include/acsdk/MultiAgentInterface/Observer/AgentLocaleObserverInterface.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENTINTERFACE_OBSERVER_AGENTLOCALEOBSERVERINTERFACE_H_
+#define ACSDK_MULTIAGENTINTERFACE_OBSERVER_AGENTLOCALEOBSERVERINTERFACE_H_
+
+#include <acsdk/MultiAgentInterface/Agent/LocaleInterface.h>
+
+#include <AVSCommon/AVS/AgentId.h>
+
+#include <memory>
+#include <set>
+
+namespace alexaClientSDK {
+namespace multiAgentInterface {
+namespace observer {
+
+/**
+ * An Interface allowing a component to be informed of changes of the enabled locales, or changes of the active wake
+ * words within locales, for a given agent.
+ */
+class AgentLocaleObserverInterface {
+public:
+    /**
+     * Destructor.
+     */
+    virtual ~AgentLocaleObserverInterface() = default;
+
+    /**
+     * Notification that the agent represented by its id has an updated set of locales, including enabled wake words
+     * within those locales.
+     *
+     * @param id The agent whose locales have been modified.
+     * @param gestures The current set of locales now active for the agent.
+     */
+    virtual void onLocalesChanged(
+        avsCommon::avs::AgentId::IdType id,
+        const std::set<std::shared_ptr<agent::LocaleInterface>>& currentLocales) = 0;
+};
+
+}  // namespace observer
+}  // namespace multiAgentInterface
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENTINTERFACE_OBSERVER_AGENTLOCALEOBSERVERINTERFACE_H_
diff --git a/core/MultiAgent/MultiAgentInterface/test/CMakeLists.txt b/core/MultiAgent/MultiAgentInterface/test/CMakeLists.txt
new file mode 100644
index 00000000..1677e594
--- /dev/null
+++ b/core/MultiAgent/MultiAgentInterface/test/CMakeLists.txt
@@ -0,0 +1,7 @@
+cmake_minimum_required(VERSION 3.1)
+
+include(${AVS_CMAKE_BUILD}/BuildDefaults.cmake)
+
+add_library(MultiAgentInterfaceTestUtils INTERFACE)
+target_include_directories(MultiAgentInterfaceTestUtils INTERFACE "${MultiAgentInterface_SOURCE_DIR}/test/include")
+target_link_libraries(MultiAgentInterfaceTestUtils INTERFACE MultiAgentInterface)
\ No newline at end of file
diff --git a/core/MultiAgent/MultiAgentInterface/test/include/acsdk/MultiAgentInterface/MockAgentManager.h b/core/MultiAgent/MultiAgentInterface/test/include/acsdk/MultiAgentInterface/MockAgentManager.h
new file mode 100644
index 00000000..c1d201c5
--- /dev/null
+++ b/core/MultiAgent/MultiAgentInterface/test/include/acsdk/MultiAgentInterface/MockAgentManager.h
@@ -0,0 +1,110 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENTINTERFACE_MOCKAGENTMANAGER_H_
+#define ACSDK_MULTIAGENTINTERFACE_MOCKAGENTMANAGER_H_
+
+#include <acsdk/MultiAgentInterface/AgentManagerInterface.h>
+
+#include <gmock/gmock.h>
+
+namespace alexaClientSDK {
+namespace multiAgentInterface {
+
+class MockAgentManager : public AgentManagerInterface {
+public:
+    /// @name AgentManagerInterface methods
+    /// @{
+    MOCK_METHOD0(getAllAgentIds, std::set<avsCommon::avs::AgentId::IdType>());
+    MOCK_METHOD1(getAgentName, std::string(avsCommon::avs::AgentId::IdType id));
+    MOCK_METHOD3(
+        getAVSInterfaceEnabledAgentIds,
+        std::set<avsCommon::avs::AgentId::IdType>(
+            const std::string& avsNamespace,
+            const std::string& avsName,
+            const std::pair<int, int>&));
+    MOCK_METHOD1(
+        getAgentLocales,
+        std::set<std::shared_ptr<agent::LocaleInterface>>(avsCommon::avs::AgentId::IdType id));
+    MOCK_METHOD1(
+        getAgentActiveLocales,
+        std::set<std::shared_ptr<agent::LocaleInterface>>(avsCommon::avs::AgentId::IdType id));
+    MOCK_METHOD1(getAgentGestures, std::set<avsCommon::avs::AgentInitiator>(avsCommon::avs::AgentId::IdType id));
+    MOCK_METHOD1(isAgentEnabled, bool(avsCommon::avs::AgentId::IdType id));
+    MOCK_METHOD1(enableAgent, bool(avsCommon::avs::AgentId::IdType id));
+    MOCK_METHOD1(disableAgent, bool(avsCommon::avs::AgentId::IdType id));
+    MOCK_METHOD1(
+        setAgentConnectionManager,
+        void(const std::shared_ptr<connection::AgentConnectionManagerInterface>& connectionManager));
+    MOCK_METHOD2(setBaseURL, bool(avsCommon::avs::AgentId::IdType id, const std::string& baseURL));
+    MOCK_METHOD2(setActiveLocales, bool(avsCommon::avs::AgentId::IdType id, const std::set<std::string>& localeNames));
+    MOCK_METHOD3(
+        setActiveWakeWords,
+        bool(
+            avsCommon::avs::AgentId::IdType id,
+            const std::string& localeName,
+            const std::set<std::string>& wakeWords));
+    MOCK_METHOD2(setAgentGesture, bool(avsCommon::avs::AgentId::IdType id, avsCommon::avs::AgentInitiator gesture));
+    MOCK_METHOD1(resolveGesture, avsCommon::avs::AgentId::IdType(avsCommon::avs::AgentInitiator gesture));
+    MOCK_METHOD1(resolveWakeWord, avsCommon::avs::AgentId::IdType(const std::string& wakeWord));
+    MOCK_METHOD2(
+        addAgentConnectionObserverInterface,
+        void(
+            avsCommon::avs::AgentId::IdType id,
+            const std::shared_ptr<connection::AgentConnectionObserverInterface>& observer));
+    MOCK_METHOD2(
+        removeAgentConnectionObserverInterface,
+        void(
+            avsCommon::avs::AgentId::IdType id,
+            const std::shared_ptr<connection::AgentConnectionObserverInterface>& observer));
+    MOCK_METHOD2(
+        addAgentEnablementObserverInterface,
+        void(
+            avsCommon::avs::AgentId::IdType id,
+            const std::shared_ptr<observer::AgentEnablementObserverInterface>& observer));
+    MOCK_METHOD2(
+        removeAgentEnablementObserverInterface,
+        void(
+            avsCommon::avs::AgentId::IdType id,
+            const std::shared_ptr<observer::AgentEnablementObserverInterface>& observer));
+    MOCK_METHOD2(
+        addAgentGestureObserverInterface,
+        void(
+            avsCommon::avs::AgentId::IdType id,
+            const std::shared_ptr<observer::AgentGestureObserverInterface>& observer));
+    MOCK_METHOD2(
+        removeAgentGestureObserverInterface,
+        void(
+            avsCommon::avs::AgentId::IdType id,
+            const std::shared_ptr<observer::AgentGestureObserverInterface>& observer));
+    MOCK_METHOD2(
+        addAgentLocaleObserverInterface,
+        void(
+            avsCommon::avs::AgentId::IdType id,
+            const std::shared_ptr<observer::AgentLocaleObserverInterface>& observer));
+    MOCK_METHOD2(
+        removeAgentLocaleObserverInterface,
+        void(
+            avsCommon::avs::AgentId::IdType id,
+            const std::shared_ptr<observer::AgentLocaleObserverInterface>& observer));
+    MOCK_METHOD1(printAgentDetails, void(avsCommon::avs::AgentId::IdType id));
+    MOCK_METHOD0(clearAgents, void());
+    /// @}
+};
+
+}  // namespace multiAgentInterface
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENTINTERFACE_MOCKAGENTMANAGER_H_
diff --git a/core/MultiAgent/MultiAgentInterface/test/include/acsdk/MultiAgentInterface/Observer/MockAgentEnablementObserver.h b/core/MultiAgent/MultiAgentInterface/test/include/acsdk/MultiAgentInterface/Observer/MockAgentEnablementObserver.h
new file mode 100644
index 00000000..05df34b4
--- /dev/null
+++ b/core/MultiAgent/MultiAgentInterface/test/include/acsdk/MultiAgentInterface/Observer/MockAgentEnablementObserver.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDK_MULTIAGENTINTERFACE_OBSERVER_MOCKAGENTENABLEMENTOBSERVER_H_
+#define ACSDK_MULTIAGENTINTERFACE_OBSERVER_MOCKAGENTENABLEMENTOBSERVER_H_
+
+#include <acsdk/MultiAgentInterface/Observer/AgentEnablementObserverInterface.h>
+
+#include <gmock/gmock.h>
+
+namespace alexaClientSDK {
+namespace multiAgentInterface {
+namespace observer {
+
+class MockAgentEnablementObserver : public AgentEnablementObserverInterface {
+public:
+    /// @name AgentEnablementObserverInterface methods
+    /// @{
+    MOCK_METHOD1(onEnabled, void(avsCommon::avs::AgentId::IdType id));
+    MOCK_METHOD1(onDisabled, void(avsCommon::avs::AgentId::IdType id));
+    /// @}
+};
+
+}  // namespace observer
+}  // namespace multiAgentInterface
+}  // namespace alexaClientSDK
+
+#endif  // ACSDK_MULTIAGENTINTERFACE_OBSERVER_MOCKAGENTENABLEMENTOBSERVER_H_
diff --git a/core/MultiAgent/README.md b/core/MultiAgent/README.md
new file mode 100644
index 00000000..269b0a6f
--- /dev/null
+++ b/core/MultiAgent/README.md
@@ -0,0 +1,2 @@
+This is the beginning of the Mini-MAX Repository
+
diff --git a/core/acsdkCore/include/acsdkCore/CoreComponent.h b/core/acsdkCore/include/acsdkCore/CoreComponent.h
index 63bd23f3..d1ae034b 100644
--- a/core/acsdkCore/include/acsdkCore/CoreComponent.h
+++ b/core/acsdkCore/include/acsdkCore/CoreComponent.h
@@ -18,6 +18,7 @@
 
 #include <memory>
 
+#include <acsdk/MultiAgentInterface/AgentManagerInterface.h>
 #include <acsdkAlexaEventProcessedNotifierInterfaces/AlexaEventProcessedNotifierInterface.h>
 #include <acsdkManufactory/Component.h>
 #include <acsdkPostConnectOperationProviderRegistrarInterfaces/PostConnectOperationProviderRegistrarInterface.h>
@@ -85,6 +86,7 @@ using CoreComponent = acsdkManufactory::Component<
     std::shared_ptr<registrationManager::CustomerDataManagerInterface>,
     std::shared_ptr<registrationManager::RegistrationManagerInterface>,
     std::shared_ptr<registrationManager::RegistrationNotifierInterface>,
+    acsdkManufactory::Import<std::shared_ptr<multiAgentInterface::AgentManagerInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>>,
     acsdkManufactory::Import<std::shared_ptr<avsCommon::utils::timing::MultiTimer>>,
diff --git a/core/acsdkRegistrationManager/include/RegistrationManager/RegistrationManagerFactory.h b/core/acsdkRegistrationManager/include/RegistrationManager/RegistrationManagerFactory.h
new file mode 100644
index 00000000..4e858fd0
--- /dev/null
+++ b/core/acsdkRegistrationManager/include/RegistrationManager/RegistrationManagerFactory.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef REGISTRATIONMANAGER_REGISTRATIONMANAGERFACTORY_H_
+#define REGISTRATIONMANAGER_REGISTRATIONMANAGERFACTORY_H_
+
+#include <memory>
+
+#include <AVSCommon/SDKInterfaces/AVSConnectionManagerInterface.h>
+#include <AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h>
+#include <AVSCommon/Utils/Metrics/MetricRecorderInterface.h>
+#include <AVSCommon/Utils/Optional.h>
+#include <RegistrationManager/CustomerDataManagerInterface.h>
+#include <RegistrationManager/RegistrationManagerInterface.h>
+#include <RegistrationManager/RegistrationNotifierInterface.h>
+
+namespace alexaClientSDK {
+namespace registrationManager {
+
+/// This structure contains the interfaces to interact with the RegistrationManager.
+struct RegistrationManagerFactoryInterfaces {
+    /// Registration Manager instance
+    std::shared_ptr<registrationManager::RegistrationManagerInterface> registrationManager;
+
+    /// Interface for Notifier.
+    std::shared_ptr<registrationManager::RegistrationNotifierInterface> notifier;
+};
+
+/**
+ * Creates a new instance of @c RegistrationManagerFactoryInterfaces.
+ *
+ * @note This method is @deprecated. Consider using RegistrationManagerComponent to create an instance of
+ * @c RegistrationManagerInterface.
+ * @return A pointer to the @c RegistrationManagerInterface.
+ */
+avsCommon::utils::Optional<RegistrationManagerFactoryInterfaces> createRegistrationManagerInterfaces(
+    const std::shared_ptr<registrationManager::CustomerDataManagerInterface>& customerDataManager,
+    const std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface>& connectionManager,
+    const std::shared_ptr<avsCommon::sdkInterfaces::DirectiveSequencerInterface>& directiveSequencer,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder);
+
+}  // namespace registrationManager
+}  // namespace alexaClientSDK
+
+#endif  // REGISTRATIONMANAGER_REGISTRATIONMANAGERFACTORY_H_
diff --git a/core/acsdkRegistrationManager/src/CMakeLists.txt b/core/acsdkRegistrationManager/src/CMakeLists.txt
index 2c6ecc3c..19f6742d 100644
--- a/core/acsdkRegistrationManager/src/CMakeLists.txt
+++ b/core/acsdkRegistrationManager/src/CMakeLists.txt
@@ -4,6 +4,7 @@ add_library(RegistrationManager
         CustomerDataHandler.cpp
         CustomerDataManager.cpp
         CustomerDataManagerFactory.cpp
+        RegistrationManagerFactory.cpp
         RegistrationManager.cpp
         RegistrationManagerComponent.cpp
         RegistrationNotifier.cpp)
diff --git a/core/acsdkRegistrationManager/src/RegistrationManagerFactory.cpp b/core/acsdkRegistrationManager/src/RegistrationManagerFactory.cpp
new file mode 100644
index 00000000..8544b878
--- /dev/null
+++ b/core/acsdkRegistrationManager/src/RegistrationManagerFactory.cpp
@@ -0,0 +1,51 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <RegistrationManager/CustomerDataManager.h>
+#include <RegistrationManager/RegistrationManager.h>
+#include <RegistrationManager/RegistrationNotifier.h>
+
+#include "RegistrationManager/RegistrationManagerFactory.h"
+
+namespace alexaClientSDK {
+namespace registrationManager {
+
+using namespace avsCommon::utils;
+
+Optional<RegistrationManagerFactoryInterfaces> createRegistrationManagerInterfaces(
+    const std::shared_ptr<registrationManager::CustomerDataManagerInterface>& customerDataManager,
+    const std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface>& connectionManager,
+    const std::shared_ptr<avsCommon::sdkInterfaces::DirectiveSequencerInterface>& directiveSequencer,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder) {
+    auto notifier = RegistrationNotifier::createRegistrationNotifierInterface();
+    if (!notifier) {
+        return Optional<RegistrationManagerFactoryInterfaces>();
+    }
+
+    auto registrationManager = RegistrationManager::createRegistrationManagerInterface(
+        customerDataManager, notifier, connectionManager, directiveSequencer, metricRecorder);
+    if (!registrationManager) {
+        return Optional<RegistrationManagerFactoryInterfaces>();
+    }
+
+    RegistrationManagerFactoryInterfaces interfaces;
+    interfaces.registrationManager = registrationManager;
+    interfaces.notifier = notifier;
+
+    return Optional<RegistrationManagerFactoryInterfaces>(interfaces);
+}
+
+}  // namespace registrationManager
+}  // namespace alexaClientSDK
-- 
2.37.1 (Apple Git-137.1)

